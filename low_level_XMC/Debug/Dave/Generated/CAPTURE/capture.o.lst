   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "capture.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.XMC_CCU4_EnableClock,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	XMC_CCU4_EnableClock:
  25              	.LFB139:
  26              	 .file 1 "C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc/xmc_ccu4.h"
   1:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
   2:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @file xmc_ccu4.h
   3:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @date 2019-03-30
   4:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
   5:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @cond
   6:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *****************************************************************************
   7:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMClib v2.2.0 - XMC Peripheral Driver Library
   8:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
   9:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  10:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * All rights reserved.
  11:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  12:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Boost Software License - Version 1.0 - August 17th, 2003
  13:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  14:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Permission is hereby granted, free of charge, to any person or organization
  15:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * obtaining a copy of the software and accompanying documentation covered by
  16:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * this license (the "Software") to use, reproduce, display, distribute,
  17:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * execute, and transmit the Software, and to prepare derivative works of the
  18:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Software, and to permit third-parties to whom the Software is furnished to
  19:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * do so, all subject to the following:
  20:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  21:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * The copyright notices in the Software and this entire statement, including
  22:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * the above license grant, this restriction and the following disclaimer,
  23:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * must be included in all copies of the Software, in whole or in part, and
  24:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * all derivative works of the Software, unless such copies or derivative
  25:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * works are solely in the form of machine-executable object code generated by
  26:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * a source language processor.
  27:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  28:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  29:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  30:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  31:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  32:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  33:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  34:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * DEALINGS IN THE SOFTWARE.
  35:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  36:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * To improve the quality of the software, users are encouraged to share
  37:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * modifications, enhancements or bug fixes with Infineon Technologies AG
  38:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * at XMCSupport@infineon.com.
  39:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *****************************************************************************
  40:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  41:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Change History
  42:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * --------------
  43:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  44:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2015-02-20:
  45:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - Initial <br>
  46:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - Documentation updates <br>
  47:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  48:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2015-06-20:
  49:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - Removed version macros and declaration of GetDriverVersion API <br>
  50:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  51:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2015-07-22:
  52:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent() is updated to support XMC14 device. <br>
  53:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  54:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2015-08-17:
  55:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - XMC_CCU4_SLICE_PRESCALER_t enum is added to set the prescaler divider. <br>
  56:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_t enum item names are updated according to the guideli
  57:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - XMC_CCU4_EnableShadowTransfer() API is made as inline, to improve the speed. <br>
  58:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  59:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2015-09-29:
  60:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - In XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_t, two more enum items are added to support exte
  61:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *       settings.
  62:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  63:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2015-10-07:
  64:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - XMC_CCU4_SLICE_GetEvent() is made as inline.
  65:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - XMC_CCU4_SLICE_MULTI_IRQ_ID_t is added to support the XMC_CCU4_SLICE_EnableMultipleEvents(
  66:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *       XMC_CCU4_SLICE_DisableMultipleEvents() APIs.
  67:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - DOC updates for the newly added APIs.
  68:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  69:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2016-03-09:
  70:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - Optimization of write only registers
  71:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  72:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2016-05-20:
  73:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - Added XMC_CCU4_SLICE_StopClearTimer()
  74:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - Changed implementation of XMC_CCU4_SLICE_StopTimer() and XMC_CCU4_SLICE_ClearTimer() to av
  75:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  76:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2017-04-27:
  77:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - XMC_CCU4_SLICE_SetPrescaler() changed div_val parameter to type XMC_CCU4_SLICE_PRESCALER_t
  78:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  79:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2017-09-15:
  80:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - Fix XMC_CCU4_SLICE_SetShadowTransferMode()
  81:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  82:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2019-03-30:
  83:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - Changed XMC_CCU4_StartPrescaler(), XMC_CCU4_StopPrescaler(), XMC_CCU4_EnableMultipleClocks
  84:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - Changed XMC_CCU4_SLICE_SetEvent(), XMC_CCU4_SLICE_ClearEvent() to avoid RMW access
  85:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - Added XMC_CCU4_SetSuspendMode(), XMC_CCU4_SLICE_GetPrescaler()
  86:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  87:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2019-07-29:
  88:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *     - Added XMC_CCU4_GetSliceStatusBit()
  89:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
  90:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @endcond
  91:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
  92:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
  93:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #ifndef XMC_CCU4_H
  94:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #define XMC_CCU4_H
  95:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
  96:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**************************************************************************************************
  97:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * HEADER FILES
  98:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  **************************************************************************************************
  99:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #include "xmc_common.h"
 100:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU40)
 101:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 102:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if UC_FAMILY == XMC1
 103:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #include "xmc1_ccu4_map.h"
 104:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 105:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 106:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if UC_FAMILY == XMC4
 107:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #include "xmc4_ccu4_map.h"
 108:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 109:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 110:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 111:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @addtogroup XMClib XMC Peripheral Library
 112:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @{
 113:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 114:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 115:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 116:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @addtogroup CCU4
 117:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @brief Capture Compare Unit 4 (CCU4) low level driver for XMC family of microcontrollers<br>
 118:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 119:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * The CCU4 peripheral is a major component for systems that need general purpose timers for signal
 120:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * monitoring/conditioning and Pulse Width Modulation (PWM) signal generation. Power electronic con
 121:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * switched mode power supplies or interruptible power supplies, can easily be implemented with the
 122:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * CCU4 peripheral.\n
 123:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Each CCU4 module is comprised of four identical 16 bit Capture/Compare Timer slices, CC4y (where
 124:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * timer slice can work in compare mode or in capture mode.
 125:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 126:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * APIs provided in this file cover the following functional blocks of CCU4:\n
 127:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * -- Timer configuration, Capture configuration, Function/Event configuration, Interrupt configura
 128:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par Note:
 129:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 1. SLICE (APIs prefixed with e.g. XMC_CCU4_SLICE_)
 130:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * 2. Module (APIs are not having any prefix e.g. XMC_CCU4_)
 131:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 132:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par Timer(Compare mode) configuration:
 133:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This section of the LLD provides the configuration structure XMC_CCU4_SLICE_COMPARE_CONFIG_t and
 134:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * function XMC_CCU4_SLICE_CompareInit().
 135:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 136:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * It can be used to:
 137:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * -# Start and Stop the timer. (XMC_CCU4_SLICE_StartTimer(), XMC_CCU4_SLICE_StopTimer())
 138:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * -# Update the period, compare, Dither, Prescaler  and Passive values. (XMC_CCU4_SLICE_SetTimerPe
 139:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    XMC_CCU4_SLICE_SetTimerCompareMatch(), XMC_CCU4_SLICE_SetPrescaler(), XMC_CCU4_SLICE_SetDithe
 140:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    XMC_CCU4_SLICE_SetPassiveLevel())
 141:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * -# Enable the slices to support multichannel mode. (XMC_CCU4_SLICE_EnableMultiChannelMode())
 142:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 143:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par Capture configuration:
 144:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This section of the LLD provides the configuration structure XMC_CCU4_SLICE_CAPTURE_CONFIG_t and
 145:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * function XMC_CCU4_SLICE_CaptureInit().
 146:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 147:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * It can be used to:
 148:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * -# Configure the capture functionality. (XMC_CCU4_SLICE_Capture0Config(), XMC_CCU4_SLICE_Capture
 149:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * -# Read the captured values along with the status, which indicate the value is latest or not.
 150:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    (XMC_CCU4_SLICE_GetCaptureRegisterValue())
 151:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 152:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par Function/Event configuration:
 153:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This section of the LLD provides the configuration structure XMC_CCU4_SLICE_EVENT_CONFIG_t.\n
 154:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 155:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * It can be used to:
 156:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * -# Enable and Disable the events. (XMC_CCU4_SLICE_EnableEvent(), XMC_CCU4_SLICE_DisableEvent())
 157:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * -# Configure to start and stop the timer on external events.(XMC_CCU4_SLICE_StartConfig(), XMC_C
 158:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * -# Modulation, external load and Gating of the timer output.(XMC_CCU4_SLICE_ModulationConfig(),
 159:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    XMC_CCU4_SLICE_LoadConfig(), XMC_CCU4_SLICE_GateConfig())
 160:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * -# Control the count direction of the timer based on the external event. (XMC_CCU4_SLICE_Directi
 161:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * -# Count the external events.(XMC_CCU4_SLICE_CountConfig())
 162:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * -# External Trap. Which can be used as protective feature.(XMC_CCU4_SLICE_EnableTrap(), XMC_CCU4
 163:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    XMC_CCU4_SLICE_TrapConfig())
 164:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 165:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par Interrupt configuration:
 166:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This section of the LLD provides the function to configure the interrupt node to each event (XMC
 167:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @{
 168:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 169:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 170:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**************************************************************************************************
 171:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * MACROS
 172:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  **************************************************************************************************
 173:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /* Macro to check if the interrupt enum passed is valid */
 174:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #define XMC_CCU4_SLICE_CHECK_INTERRUPT(interrupt) \
 175:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****     ((interrupt == XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH)           || \
 176:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****      (interrupt == XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH)              || \
 177:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****      (interrupt == XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP)  || \
 178:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****      (interrupt == XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN)|| \
 179:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****      (interrupt == XMC_CCU4_SLICE_IRQ_ID_EVENT0)                 || \
 180:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****      (interrupt == XMC_CCU4_SLICE_IRQ_ID_EVENT1)                 || \
 181:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****      (interrupt == XMC_CCU4_SLICE_IRQ_ID_EVENT2)                 || \
 182:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****      (interrupt == XMC_CCU4_SLICE_IRQ_ID_TRAP))
 183:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 184:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**************************************************************************************************
 185:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * ENUMS
 186:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  **************************************************************************************************
 187:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 188:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 189:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Typedef for CCU4 Global data structure
 190:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 191:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef CCU4_GLOBAL_TypeDef XMC_CCU4_MODULE_t;
 192:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 193:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 194:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Typedef for CCU4 Slice data structure
 195:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 196:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef CCU4_CC4_TypeDef XMC_CCU4_SLICE_t;
 197:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 198:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 199:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Return Value of an API
 200:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 201:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_STATUS
 202:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 203:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_STATUS_OK      = 0U, /**< API fulfils request */
 204:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_STATUS_ERROR,        /**< API cannot fulfil the request */
 205:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_STATUS_RUNNING,      /**< The timer slice is currently running */
 206:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_STATUS_IDLE          /**< The timer slice is currently idle */
 207:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_STATUS_t;
 208:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 209:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 210:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  CCU4 module clock
 211:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 212:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_CLOCK
 213:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 214:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_CLOCK_SCU        = 0U, /**< Select the fCCU as the clock */
 215:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_CLOCK_EXTERNAL_A,      /**< External clock-A */
 216:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_CLOCK_EXTERNAL_B,      /**< External clock-B */
 217:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_CLOCK_EXTERNAL_C       /**< External clock-C */
 218:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_CLOCK_t;
 219:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 220:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 221:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * CCU4 set the shadow transfer type for multichannel mode
 222:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 223:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER
 224:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 225:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE0       = (uint32_t)0x4000000, /**< Shadow transfe
 226:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                      only for slice
 227:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_MCSS_SLICE0  = (uint32_t)0x4000400, /**< Shadow transfe
 228:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                      and hardware f
 229:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE1       = (uint32_t)0x8000000, /**< Shadow transfe
 230:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                      only for slice
 231:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_MCSS_SLICE1  = (uint32_t)0x8000800, /**< Shadow transfe
 232:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                      and hardware f
 233:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE2       = (uint32_t)0x10000000, /**< Shadow transf
 234:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                       only for slic
 235:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_MCSS_SLICE2  = (uint32_t)0x10001000, /**< Shadow transf
 236:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                       and hardware 
 237:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_SLICE3       = (uint32_t)0x20000000, /**< Shadow transf
 238:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                       only for slic
 239:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_SW_MCSS_SLICE3  = (uint32_t)0x20002000  /**< Shadow transf
 240:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                       and hardware 
 241:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_MULTI_CHANNEL_SHADOW_TRANSFER_t;
 242:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 243:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 244:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Operational modes of CCU4 slice
 245:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 246:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_MODE
 247:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 248:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MODE_COMPARE  = 0U, /**< slice(CC4y) operates in Compare Mode */
 249:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MODE_CAPTURE        /**< slice(CC4y) operates in Capture Mode */
 250:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_MODE_t;
 251:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 252:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 253:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Timer counting modes for the slice
 254:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 255:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_TIMER_COUNT_MODE
 256:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 257:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_TIMER_COUNT_MODE_EA  = 0U, /**< Edge Aligned Mode */
 258:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_TIMER_COUNT_MODE_CA        /**< Center Aligned Mode */
 259:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_TIMER_COUNT_MODE_t;
 260:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 261:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 262:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Timer repetition mode for the slice
 263:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 264:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_TIMER_REPEAT_MODE
 265:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 266:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_TIMER_REPEAT_MODE_REPEAT = 0U,  /**< Repetitive mode: continuous mode of operation
 267:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_TIMER_REPEAT_MODE_SINGLE        /**< Single shot mode: Once a Period match/One mat
 268:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                       occurs timer goes to idle state */
 269:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t;
 270:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 271:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 272:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Timer counting direction for the CCU4 slice
 273:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 274:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_TIMER_COUNT_DIR
 275:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 276:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_TIMER_COUNT_DIR_UP   = 0U, /**< Counting up */
 277:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_TIMER_COUNT_DIR_DOWN       /**< Counting down */
 278:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_TIMER_COUNT_DIR_t;
 279:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 280:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 281:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Capture mode register sets
 282:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 283:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_CAP_REG_SET
 284:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 285:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_CAP_REG_SET_LOW  = 0U, /**< Capture register-0, Capture register-1 used */
 286:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_CAP_REG_SET_HIGH       /**< Capture register-2, Capture register-3 used */
 287:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_CAP_REG_SET_t;
 288:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 289:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 290:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Prescaler mode
 291:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 292:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_PRESCALER_MODE
 293:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 294:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_MODE_NORMAL = 0U, /**< Fixed division of module clock */
 295:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_MODE_FLOAT        /**< Floating divider. */
 296:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_PRESCALER_MODE_t;
 297:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 298:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 299:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Timer output passive level
 300:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 301:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL
 302:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 303:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_LOW  = 0U, /**< Passive level = Low */
 304:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_HIGH       /**< Passive level = High */
 305:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_t;
 306:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 307:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 308:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Timer clock Divider
 309:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 310:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_PRESCALER
 311:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 312:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_1  = 0U, /**< Slice Clock = fccu4 */
 313:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_2,       /**< Slice Clock = fccu4/2 */
 314:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_4,       /**< Slice Clock = fccu4/4 */
 315:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_8,       /**< Slice Clock = fccu4/8 */
 316:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_16,      /**< Slice Clock = fccu4/16 */
 317:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_32,      /**< Slice Clock = fccu4/32 */
 318:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_64,      /**< Slice Clock = fccu4/64 */
 319:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_128,     /**< Slice Clock = fccu4/128 */
 320:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_256,     /**< Slice Clock = fccu4/256 */
 321:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_512,     /**< Slice Clock = fccu4/512 */
 322:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_1024,    /**< Slice Clock = fccu4/1024 */
 323:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_2048,    /**< Slice Clock = fccu4/2048 */
 324:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_4096,    /**< Slice Clock = fccu4/4096 */
 325:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_8192,    /**< Slice Clock = fccu4/8192 */
 326:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_16384,   /**< Slice Clock = fccu4/16384 */
 327:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_PRESCALER_32768    /**< Slice Clock = fccu4/32768 */
 328:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_PRESCALER_t;
 329:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 330:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 331:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  External Function list
 332:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 333:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_FUNCTION
 334:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 335:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_FUNCTION_START           = 0U, /**< Start function */
 336:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_FUNCTION_STOP,                 /**< Stop function */
 337:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_FUNCTION_CAPTURE_EVENT0, /**< Capture Event-0 function, CCycapt0 signal is used fo
 338:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                      generation */
 339:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_FUNCTION_CAPTURE_EVENT1, /**< Capture Event-1 function, CCycapt1 signal is used fo
 340:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                      generation */
 341:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_FUNCTION_GATING,               /**< Gating function */
 342:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_FUNCTION_DIRECTION,            /**< Direction function */
 343:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_FUNCTION_LOAD,                 /**< Load function */
 344:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_FUNCTION_COUNT,                /**< Counting function */
 345:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_FUNCTION_OVERRIDE,             /**< Override function */
 346:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_FUNCTION_MODULATION,           /**< Modulation function */
 347:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_FUNCTION_TRAP                  /**< Trap function */
 348:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_FUNCTION_t;
 349:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 350:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 351:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  External Event list
 352:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 353:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_EVENT
 354:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 355:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_NONE  = 0U, /**< None */
 356:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_0,          /**< Event-0 */
 357:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_1,          /**< Event-1 */
 358:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_2           /**< Event-2 */
 359:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_EVENT_t;
 360:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 361:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 362:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  External Event trigger criteria  - Edge sensitivity
 363:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 364:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY
 365:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 366:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_NONE         = 0U, /**< None */
 367:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_RISING_EDGE,       /**< Rising Edge of the input signal gen
 368:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_FALLING_EDGE, /**< Falling Edge of the input signal generat
 369:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                 trigger */
 370:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_DUAL_EDGE          /**< Both Rising and Falling edges cause
 371:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_t;
 372:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 373:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 374:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  External Event trigger criteria  - Level sensitivity
 375:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 376:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY
 377:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 378:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_HIGH = 0U, /**< Level sensitive functions react to 
 379:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW  = 1U, /**< Level sensitive functions react to 
 380:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   /* Below enum items can be utilised specific to the functionality */
 381:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_COUNT_UP_ON_LOW = 0U, /**< Timer counts up, during Low sta
 382:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_COUNT_UP_ON_HIGH = 1U /**< Timer counts up, during High st
 383:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_t;
 384:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 385:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 386:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Low pass filter Configuration. The External Event input should be stable for a selected number 
 387:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 388:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_EVENT_FILTER
 389:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 390:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_FILTER_DISABLED  = 0U, /**< No Low Pass Filter */
 391:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_FILTER_3_CYCLES,       /**< 3 clock cycles */
 392:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_FILTER_5_CYCLES,       /**< 5 clock cycles */
 393:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_FILTER_7_CYCLES        /**< 7 clock cycles */
 394:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_EVENT_FILTER_t;
 395:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 396:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 397:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  External Event Input list. This list depicts the possible input connections to the CCU4 slice.
 398:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Interconnects are specific to each device.
 399:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 400:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef uint8_t XMC_CCU4_SLICE_INPUT_t;
 401:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 402:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 403:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Actions that can be performed upon detection of an external Timer STOP event
 404:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 405:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_END_MODE
 406:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 407:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_END_MODE_TIMER_STOP       = 0U, /**< Stops the timer, without clearing TIMER regis
 408:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_END_MODE_TIMER_CLEAR,           /**< Without stopping timer, clears the TIMER regi
 409:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_END_MODE_TIMER_STOP_CLEAR       /**< Stops the timer and clears the TIMER register
 410:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_END_MODE_t;
 411:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 412:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 413:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Actions that can be performed upon detection of an external Timer START event
 414:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 415:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_START_MODE
 416:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 417:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_START_MODE_TIMER_START       = 0U, /**< Start the timer from the current count of 
 418:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_START_MODE_TIMER_START_CLEAR       /**< Clears the TIMER register and start the ti
 419:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_START_MODE_t;
 420:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 421:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 422:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Modulation of timer output signals
 423:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 424:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_MODULATION_MODE
 425:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 426:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_ST_OUT  = 0U, /**< Clear ST and OUT signals */
 427:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MODULATION_MODE_CLEAR_OUT           /**< Clear only the OUT signal */
 428:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_MODULATION_MODE_t;
 429:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 430:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 431:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Trap exit mode
 432:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 433:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_TRAP_EXIT_MODE
 434:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 435:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_TRAP_EXIT_MODE_AUTOMATIC = 0U, /**< Clear trap state as soon as the trap signal is
 436:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_TRAP_EXIT_MODE_SW              /**< Clear only when acknowledged by software */
 437:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_TRAP_EXIT_MODE_t;
 438:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 439:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 440:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Timer clear on capture
 441:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 442:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_TIMER_CLEAR_MODE
 443:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 444:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_TIMER_CLEAR_MODE_NEVER    = 0U, /**< Never clear the timer on any capture event */
 445:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_TIMER_CLEAR_MODE_CAP_HIGH,      /**< Clear only when timer value has been captured
 446:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_TIMER_CLEAR_MODE_CAP_LOW,       /**< Clear only when timer value has been captured
 447:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_TIMER_CLEAR_MODE_ALWAYS         /**< Always clear the timer upon detection of any 
 448:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_TIMER_CLEAR_MODE_t;
 449:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 450:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 451:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Multi Channel Shadow transfer request configuration options
 452:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 453:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_MCMS_ACTION
 454:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 455:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR          = 0U, /**< Transfer Compare and Period Shadow 
 456:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                 the actual registers upon MCS xfer 
 457:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR_PCMP     = 1U, /**< Transfer Compare, Period and Presca
 458:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                 register values to the actual regis
 459:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                 request */
 460:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MCMS_ACTION_TRANSFER_PR_CR_PCMP_DIT = 3U  /**< Transfer Compare, Period ,Prescaler
 461:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                 Compare register values to the actu
 462:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                 MCS xfer request */
 463:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_MCMS_ACTION_t;
 464:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 465:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 466:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Available Interrupt Event Ids
 467:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 468:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_IRQ_ID
 469:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 470:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH       = 0U,  /**< Period match counting up */
 471:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH          = 1U,  /**< Period match -> One match counting down */
 472:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP   = 2U,  /**< Compare match counting up */
 473:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN = 3U,  /**< Compare match counting down */
 474:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_IRQ_ID_EVENT0             = 8U,  /**< Event-0 occurrence */
 475:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_IRQ_ID_EVENT1             = 9U,  /**< Event-1 occurrence */
 476:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_IRQ_ID_EVENT2             = 10U, /**< Event-2 occurrence */
 477:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_IRQ_ID_TRAP               = 11U  /**< Trap occurrence */
 478:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_IRQ_ID_t;
 479:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 480:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 481:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Available Interrupt Event Ids, which is added to support multi event APIs
 482:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 483:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_MULTI_IRQ_ID
 484:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 485:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MULTI_IRQ_ID_PERIOD_MATCH       = 0x1U,   /**< Period match counting up */
 486:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MULTI_IRQ_ID_ONE_MATCH          = 0x2U,   /**< Period match -> One match counting 
 487:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MULTI_IRQ_ID_COMPARE_MATCH_UP   = 0x4U,   /**< Compare match counting up */
 488:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MULTI_IRQ_ID_COMPARE_MATCH_DOWN = 0x8U,   /**< Compare match counting down */
 489:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MULTI_IRQ_ID_EVENT0             = 0x100U, /**< Event-0 occurrence */
 490:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MULTI_IRQ_ID_EVENT1             = 0x200U, /**< Event-1 occurrence */
 491:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MULTI_IRQ_ID_EVENT2             = 0x400U, /**< Event-2 occurrence */
 492:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_MULTI_IRQ_ID_t;
 493:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 494:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 495:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Service Request Lines for CCU4. Event are mapped to these SR lines and these are used to generat
 496:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 497:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_SR_ID
 498:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 499:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_SR_ID_0    = 0U, /**< Service Request Line-0 selected  */
 500:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_SR_ID_1,         /**< Service Request Line-1 selected  */
 501:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_SR_ID_2,         /**< Service Request Line-2 selected  */
 502:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_SR_ID_3          /**< Service Request Line-3 selected  */
 503:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_SR_ID_t;
 504:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 505:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 506:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Slice shadow transfer options.
 507:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 508:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SHADOW_TRANSFER
 509:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 510:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SHADOW_TRANSFER_SLICE_0            = CCU4_GCSS_S0SE_Msk, /**< Transfer Period, Compare a
 511:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           shadow register values to
 512:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           SLICE-0 */
 513:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SHADOW_TRANSFER_DITHER_SLICE_0     = CCU4_GCSS_S0DSE_Msk, /**< Transfer Dither compare s
 514:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           to actual register for SL
 515:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SHADOW_TRANSFER_PRESCALER_SLICE_0  = CCU4_GCSS_S0PSE_Msk, /**< Transfer Prescaler shadow
 516:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           actual register for SLICE
 517:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SHADOW_TRANSFER_SLICE_1            = CCU4_GCSS_S1SE_Msk, /**< Transfer Period, Compare a
 518:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           shadow register values to
 519:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           SLICE-1 */
 520:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SHADOW_TRANSFER_DITHER_SLICE_1     = CCU4_GCSS_S1DSE_Msk, /**< Transfer Dither compare s
 521:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           to actual registers for S
 522:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SHADOW_TRANSFER_PRESCALER_SLICE_1  = CCU4_GCSS_S1PSE_Msk, /**< Transfer Prescaler shadow
 523:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           actual register for SLICE
 524:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SHADOW_TRANSFER_SLICE_2            = CCU4_GCSS_S2SE_Msk, /**< Transfer Period, Compare a
 525:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           shadow register values to
 526:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           SLICE-2 */
 527:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SHADOW_TRANSFER_DITHER_SLICE_2     = CCU4_GCSS_S2DSE_Msk, /**< Transfer Dither compare s
 528:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           to actual register for SL
 529:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SHADOW_TRANSFER_PRESCALER_SLICE_2  = CCU4_GCSS_S2PSE_Msk, /**< Transfer Prescaler shadow
 530:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           actual register for SLICE
 531:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SHADOW_TRANSFER_SLICE_3            = CCU4_GCSS_S3SE_Msk, /**< Transfer Period, Compare a
 532:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           shadow register values to
 533:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           SLICE-3 */
 534:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SHADOW_TRANSFER_DITHER_SLICE_3     = CCU4_GCSS_S3DSE_Msk, /**< Transfer Dither compare s
 535:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           to actual register for SL
 536:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SHADOW_TRANSFER_PRESCALER_SLICE_3  = CCU4_GCSS_S3PSE_Msk  /**< Transfer Prescaler shadow
 537:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                           actual register for SLICE
 538:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SHADOW_TRANSFER_t;
 539:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 540:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU4V3) || defined(DOXYGEN)/* Defined for XMC1400 devices only */
 541:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 542:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Slice shadow transfer mode options.
 543:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @note Only available for XMC1400 series
 544:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 545:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE
 546:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 547:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_IN_PERIOD_MATCH_AND_ONE_MATCH = 0U,  /**< Shadow transfer is 
 548:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                 One match. */
 549:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_ONLY_IN_PERIOD_MATCH = 1U,  /**< Shadow transfer is done only
 550:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_ONLY_IN_ONE_MATCH = 2U  /**< Shadow transfer is done only in 
 551:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_SHADOW_TRANSFER_MODE_t;
 552:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 553:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 554:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 555:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Immediate write into configuration register
 556:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  @note Only available for XMC1400 series
 557:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 558:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_WRITE_INTO
 559:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 560:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_WRITE_INTO_PERIOD_CONFIGURATION = CCU4_CC4_STC_IRPC_Msk,                  /**< Imm
 561:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                 Wri
 562:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                 Con
 563:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_WRITE_INTO_COMPARE_CONFIGURATION = CCU4_CC4_STC_IRCC_Msk,                 /**< Imm
 564:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                 Wri
 565:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                 Con
 566:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_WRITE_INTO_PASSIVE_LEVEL_CONFIGURATION = CCU4_CC4_STC_IRLC_Msk,           /**< Imm
 567:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                 Wri
 568:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 	                                                                                            Config
 569:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_WRITE_INTO_DITHER_VALUE_CONFIGURATION = CCU4_CC4_STC_IRDC_Msk,            /**< Imm
 570:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                 Wri
 571:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 	                                                                                            Config
 572:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_WRITE_INTO_FLOATING_PRESCALER_VALUE_CONFIGURATION = CCU4_CC4_STC_IRFC_Msk /**< Imm
 573:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                 Wri
 574:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                 Val
 575:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_WRITE_INTO_t;
 576:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 577:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 578:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 579:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Automatic Shadow Transfer request when writing into shadow register
 580:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  @note Only available for XMC1400 series
 581:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 582:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO
 583:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 584:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_PERIOD_SHADOW = CCU4_CC4_STC_ASPC_Msk,        
 585:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 	                                                                                                  
 586:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                    
 587:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                    
 588:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_COMPARE_SHADOW = CCU4_CC4_STC_ASCC_Msk,       
 589:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 	                                                                                                  
 590:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 	                                                                                                  
 591:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 	                                                                                                  
 592:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_PASSIVE_LEVEL = CCU4_CC4_STC_ASLC_Msk,        
 593:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 	                                                                                                  
 594:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                    
 595:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_DITHER_SHADOW = CCU4_CC4_STC_ASDC_Msk,        
 596:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                    
 597:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                    
 598:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_FLOATING_PRESCALER_SHADOW = CCU4_CC4_STC_ASFC_
 599:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 	                                                                                                  
 600:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                    
 601:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                                                                    
 602:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 603:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_AUTOMAIC_SHADOW_TRANSFER_WRITE_INTO_t;
 604:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 605:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 606:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Used to create Mask needed for Multi-channel Shadow transfer enable/disable
 607:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 608:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_MASK
 609:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 610:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MASK_SLICE_0  = 1U,  /**< SLICE-0 */
 611:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MASK_SLICE_1  = 2U,  /**< SLICE-1 */
 612:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MASK_SLICE_2  = 4U,  /**< SLICE-2 */
 613:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_MASK_SLICE_3  = 8U   /**< SLICE-3 */
 614:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_MASK_t;
 615:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 616:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 617:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Selects suspend mode
 618:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 619:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SUSPEND_MODE
 620:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 621:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SUSPEND_MODE_IGNORE = 0 << CCU4_GCTRL_SUSCFG_Pos, /**< Suspend request ignored. The modu
 622:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SUSPEND_MODE_STOPS_INMEDIATELLY = 1 << CCU4_GCTRL_SUSCFG_Pos, /**< Stops all the running
 623:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SUSPEND_MODE_SAFE_STOP = 2 << CCU4_GCTRL_SUSCFG_Pos, /**< Stops the block immediately an
 624:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SUSPEND_MODE_WAIT_ROLL_OVER = 3 << CCU4_GCTRL_SUSCFG_Pos /**< Waits for the roll over of
 625:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SUSPEND_MODE_t;
 626:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 627:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 628:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 629:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  CCU4 slice status bit
 630:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 631:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef enum XMC_CCU4_SLICE_STATUS_BIT
 632:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 633:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_STATUS_BIT_PASSIVE = false, /**< Passive */
 634:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_STATUS_BIT_ACTIVE  = true   /**< Active  */
 635:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_STATUS_BIT_t;
 636:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 637:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 638:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**************************************************************************************************
 639:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * DATA STRUCTURES
 640:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  **************************************************************************************************
 641:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 642:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 643:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Configuration data structure of an External Event(Event-0/1/2).
 644:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Needed to configure the various aspects of an External Event.
 645:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  This structure will not connect the external event with an external function.
 646:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 647:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef struct XMC_CCU4_SLICE_EVENT_CONFIG
 648:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 649:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_INPUT_t                   mapped_input; /**< Required input signal for the Event *
 650:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_EDGE_SENSITIVITY_t  edge;         /**< Select the event edge of the input si
 651:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                               This is needed for an edge sensitive 
 652:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_LEVEL_SENSITIVITY_t level;        /**< Select the event level of the input s
 653:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                                               This is needed for an level sensitive
 654:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_CCU4_SLICE_EVENT_FILTER_t            duration;     /**< Low Pass filter duration in terms of 
 655:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_EVENT_CONFIG_t;
 656:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 657:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /*Anonymous structure/union guard start*/
 658:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(__CC_ARM)
 659:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #pragma push
 660:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #pragma anon_unions
 661:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #elif defined(__TASKING__)
 662:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #pragma warning 586
 663:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 664:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 665:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 666:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Configuration data structure for CCU4 slice. Specifically configures the CCU4 slice to compare 
 667:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  This excludes event and function configuration.
 668:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 669:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef struct XMC_CCU4_SLICE_COMPARE_CONFIG
 670:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 671:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   union
 672:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   {
 673:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****     struct
 674:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****     {
 675:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t timer_mode : 1;         /**< Edge aligned or Centre Aligned.
 676:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                              Accepts enum ::XMC_CCU4_SLICE_TIMER_COUNT_MODE_t */
 677:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t monoshot : 1;           /**< Single shot or Continuous mode .
 678:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                              Accepts enum :: XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t*/
 679:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t shadow_xfer_clear : 1;  /**< Should PR and CR shadow xfer happen when timer is clear
 680:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t : 10;
 681:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t dither_timer_period: 1; /**< Can the period of the timer dither? */
 682:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t dither_duty_cycle : 1;  /**< Can the compare match of the timer dither? */
 683:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t : 1;
 684:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t prescaler_mode: 1;      /**< Normal or floating prescaler mode.
 685:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                              Accepts enum :: XMC_CCU4_SLICE_PRESCALER_MODE_t*/
 686:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t : 8;
 687:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t mcm_enable : 1;         /**< Multi-Channel mode enable? */
 688:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t : 6;
 689:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****     };
 690:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****     uint32_t tc;
 691:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   };
 692:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   uint32_t prescaler_initval : 4;      /**< Initial prescaler divider value
 693:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                             Accepts enum :: XMC_CCU4_SLICE_PRESCALER_t */
 694:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   uint32_t float_limit : 4;            /**< The max value which the prescaler divider can increment
 695:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   uint32_t dither_limit : 4;           /**< The value that determines the spreading of dithering */
 696:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   uint32_t passive_level : 1;          /**< Configuration of ST and OUT passive levels.
 697:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                              Accepts enum :: XMC_CCU4_SLICE_OUTPUT_PASSIVE_LEVEL_t*
 698:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   uint32_t timer_concatenation : 1;    /**< Enables the concatenation of the timer if true.*/
 699:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_COMPARE_CONFIG_t;
 700:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 701:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 702:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Configuration data structure for CCU4 slice. Specifically configures the CCU4 slice to capture 
 703:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  This excludes event and function configuration.
 704:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 705:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** typedef struct XMC_CCU4_SLICE_CAPTURE_CONFIG
 706:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 707:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   union
 708:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   {
 709:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****     struct
 710:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****     {
 711:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t : 4;
 712:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t fifo_enable : 1;      /**< Should the capture registers be setup as a FIFO?(Extended
 713:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t timer_clear_mode : 2; /**< How should the timer register be cleared upon detection o
 714:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                           Accepts enum ::XMC_CCU4_SLICE_TIMER_CLEAR_MODE_t*/
 715:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t : 4;
 716:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t same_event : 1;       /**< Should the capture event for C1V/C0V and C3V/C2V be same 
 717:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t ignore_full_flag : 1; /**< Should updates to capture registers follow full flag rule
 718:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t : 3;
 719:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t prescaler_mode: 1;    /**< Normal or floating prescaler Accepts enum :: XMC_CCU4_SLI
 720:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****       uint32_t : 15;
 721:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****     };
 722:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****     uint32_t tc;
 723:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   };
 724:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   uint32_t prescaler_initval : 4;    /**< Prescaler divider value */
 725:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   uint32_t float_limit : 4;          /**< The max value which the prescaler divider can increment t
 726:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   uint32_t timer_concatenation : 1;  /**< Enables the concatenation of the timer */
 727:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** } XMC_CCU4_SLICE_CAPTURE_CONFIG_t;
 728:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /*Anonymous structure/union guard end*/
 729:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(__CC_ARM)
 730:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #pragma pop
 731:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #elif defined(__TASKING__)
 732:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #pragma warning restore
 733:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 734:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**************************************************************************************************
 735:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * API Prototypes
 736:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  **************************************************************************************************
 737:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 738:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #ifdef __cplusplus
 739:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** extern "C" {
 740:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 741:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 742:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE bool XMC_CCU4_IsValidModule(const XMC_CCU4_MODULE_t *const module)
 743:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 744:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   bool tmp = false;
 745:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 746:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = (module == CCU40);
 747:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 748:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU41)
 749:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (module == CCU41);
 750:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 751:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 752:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU42)
 753:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (module == CCU42);
 754:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 755:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 756:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU43)
 757:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (module == CCU43);
 758:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 759:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 760:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   return tmp;
 761:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
 762:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 763:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE bool XMC_CCU4_IsValidSlice(const XMC_CCU4_SLICE_t *const slice)
 764:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 765:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   bool tmp = false;
 766:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 767:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = (slice == CCU40_CC40);
 768:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU40_CC41)
 769:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU40_CC41);
 770:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 771:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU40_CC42)
 772:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU40_CC42);
 773:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 774:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU40_CC43)
 775:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU40_CC43);
 776:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 777:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU41)
 778:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU41_CC40);
 779:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU41_CC41)
 780:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU41_CC41);
 781:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 782:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU41_CC42)
 783:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU41_CC42);
 784:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 785:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU41_CC43)
 786:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU41_CC43);
 787:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 788:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 789:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU42)
 790:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU42_CC40);
 791:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU42_CC41)
 792:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU42_CC41);
 793:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 794:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU42_CC42)
 795:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU42_CC42);
 796:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 797:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU42_CC43)
 798:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU42_CC43);
 799:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 800:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 801:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU43)
 802:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU43_CC40);
 803:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU43_CC41)
 804:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU43_CC41);
 805:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 806:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU43_CC42)
 807:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU43_CC42);
 808:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 809:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU43_CC43)
 810:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   tmp = tmp || (slice == CCU43_CC43);
 811:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 812:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
 813:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 814:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   return tmp;
 815:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
 816:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 817:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 818:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU4 module
 819:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param mcs_action multi-channel shadow transfer request configuration
 820:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
 821:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
 822:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 823:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
 824:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Initialization of global register GCTRL.<br>\n
 825:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  As part of module initialization, behaviour of the module upon detection
 826:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Multi-Channel Mode trigger is configured. Will also invoke the XMC_CCU4_EnableModule().
 827:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  The API call would bring up the required CCU4 module and also initialize the module for
 828:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  the required multi-channel shadow transfer.
 829:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 830:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
 831:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_SLICE_CompareInit()<BR> XMC_CCU4_SLICE_CaptureInit().
 832:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 833:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action);
 834:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 835:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 836:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU4 module
 837:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param clock Choice of input clock to the module
 838:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
 839:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
 840:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 841:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
 842:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Selects the Module Clock by configuring GCTRL.PCIS bits.<BR>\n
 843:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  There are 3 potential clock sources. This API helps to select the required clock source.
 844:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Call to this API is valid after the XMC_CCU4_Init().
 845:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 846:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
 847:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * None.<BR>
 848:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 849:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SetModuleClock(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_CLOCK_t clock);
 850:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 851:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 852:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU4 module
 853:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
 854:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
 855:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 856:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
 857:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Enables the CCU4 module and brings it to active state.<BR>\n
 858:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Also disables the gating of the clock signal (if applicable depending on the device being select
 859:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Invoke this API before any operations are done on the CCU4 module. Invoked from  XMC_CCU4_Init()
 860:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 861:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
 862:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_SetModuleClock()<BR> XMC_CCU4_DisableModule()<BR> XMC_CCU4_StartPrescaler().
 863:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 864:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_EnableModule(XMC_CCU4_MODULE_t *const module);
 865:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 866:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 867:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU4 module
 868:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
 869:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
 870:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 871:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
 872:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Brings the CCU4 module to reset state and enables gating of the clock signal(if applicable depen
 873:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * on the device being selected).<BR>\n
 874:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Invoke this API when a CCU4 module needs to be disabled completely.
 875:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Any operation on the CCU4 module will have no effect after this API is called.
 876:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 877:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
 878:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_EnableModule()<BR> XMC_CCU4_DisableModule().
 879:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 880:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_DisableModule(XMC_CCU4_MODULE_t *const module);
 881:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 882:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 883:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU4 module
 884:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
 885:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
 886:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 887:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
 888:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Starts the prescaler and restores clocks to the timer slices, by setting GIDLC.SPRB bit.<BR>\n
 889:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Once the input to the prescaler has been chosen and the prescaler divider of all slices program
 890:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  the prescaler itself may be started. Invoke this  API after XMC_CCU4_Init()
 891:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  (Mandatory to fully initialize the module).Directly accessed register is GIDLC.
 892:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 893:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
 894:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_Init()<BR> XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock()<BR> XMC_CCU4_StartPrescal
 895:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_StopPrescaler().
 896:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 897:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
 898:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 899:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
 900:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
 901:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
 902:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 903:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 904:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU4 module
 905:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
 906:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
 907:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 908:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
 909:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Stops the prescaler and blocks clocks to the timer slices, by setting GIDLS.CPRB bit.<BR>\n
 910:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Opposite of the StartPrescaler routine.
 911:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Clears the run bit of the prescaler. Ensures that the module clock is not supplied to
 912:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * the slices of the module.Registers directly accessed is GIDLS.
 913:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 914:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
 915:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock()<BR> XMC_CCU4_StartPrescaler()<BR> XMC_CCU4_St
 916:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 917:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_StopPrescaler(XMC_CCU4_MODULE_t *const module)
 918:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 919:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_StopPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
 920:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   module->GIDLS = (uint32_t) CCU4_GIDLS_CPRB_Msk;
 921:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
 922:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 923:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 924:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU4 module
 925:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
 926:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
 927:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 928:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
 929:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Returns the state of the prescaler, by reading GSTAT.PRB bit.<BR>\n
 930:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This will return true if the prescaler is running. If clock is being supplied to the slices of t
 931:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * module then returns as true.
 932:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 933:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
 934:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_StartPrescaler()<BR> XMC_CCU4_StopPrescaler()<BR> XMC_CCU4_EnableClock()<BR> XMC_CCU4_D
 935:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 936:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE bool XMC_CCU4_IsPrescalerRunning(XMC_CCU4_MODULE_t *const module)
 937:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 938:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_IsPrescalerRunning:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
 939:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   return ((bool)((module->GSTAT & (uint32_t) CCU4_GSTAT_PRB_Msk) == (uint32_t)CCU4_GSTAT_PRB_Msk));
 940:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
 941:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 942:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 943:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU4 module
 944:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param clock_mask Slices whose clocks are to be enabled simultaneously.
 945:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *                   Bit location 0/1/2/3 represents slice-0/1/2/3 respectively.
 946:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *                   Range: [0x1 to 0xF]
 947:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
 948:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
 949:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 950:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
 951:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Enables clocks of multiple slices at a time, by configuring GIDLC.CS0I, GIDLC.CS1I, GIDLC.CS2I,
 952:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * GIDLC.CS3I bits.\n\n
 953:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Takes an input clock_mask, which determines the slices that would receive the clock. Bring them 
 954:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * of the idle state simultaneously.
 955:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 956:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
 957:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock().
 958:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 959:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_EnableMultipleClocks(XMC_CCU4_MODULE_t *const module, const uint8_t c
 960:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 961:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_EnableMultipleClocks:Invalid Module Pointer", XMC_CCU4_IsValidModule(module)
 962:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_EnableMultipleClocks:Wrong clock mask", (clock_mask < 16U));
 963:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 964:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   module->GIDLC = (uint32_t) clock_mask;
 965:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
 966:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 967:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 968:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU4 module
 969:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice_number Slice for which the clock should be Enabled.
 970:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *                   Range: [0x0 to 0x3]
 971:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
 972:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
 973:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 974:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
 975:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Enables the slice timer clock, by configuring GIDLC.CS0I, GIDLC.CS1I, GIDLC.CS2I,
 976:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  GIDLC.CS3I bits according to the selected \a slice_number.\n\n
 977:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  It is possible to enable/disable clock at slice level. This uses the \b slice_number to indicat
 978:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  slice whose clock needs to be enabled.
 979:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 980:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
 981:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_DisableClock()<BR> XMC_CCU4_EnableMultipleClocks()<BR> XMC_CCU4_StartPrescaler()<BR> XM
 982:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
 983:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_numb
 984:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
  27              	 .loc 1 984 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 83B0     	 sub sp,sp,#12
  37              	.LCFI1:
  38              	 .cfi_def_cfa_offset 16
  39 0004 00AF     	 add r7,sp,#0
  40              	.LCFI2:
  41              	 .cfi_def_cfa_register 7
  42 0006 7860     	 str r0,[r7,#4]
  43 0008 0B46     	 mov r3,r1
  44 000a FB70     	 strb r3,[r7,#3]
 985:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
 986:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));
 987:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 988:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   module->GIDLC = ((uint32_t) 1) << slice_number;
  45              	 .loc 1 988 0
  46 000c FB78     	 ldrb r3,[r7,#3]
  47 000e 0122     	 movs r2,#1
  48 0010 9A40     	 lsls r2,r2,r3
  49 0012 7B68     	 ldr r3,[r7,#4]
  50 0014 DA60     	 str r2,[r3,#12]
 989:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
  51              	 .loc 1 989 0
  52 0016 0C37     	 adds r7,r7,#12
  53              	.LCFI3:
  54              	 .cfi_def_cfa_offset 4
  55 0018 BD46     	 mov sp,r7
  56              	.LCFI4:
  57              	 .cfi_def_cfa_register 13
  58              	 
  59 001a 5DF8047B 	 ldr r7,[sp],#4
  60              	.LCFI5:
  61              	 .cfi_restore 7
  62              	 .cfi_def_cfa_offset 0
  63 001e 7047     	 bx lr
  64              	 .cfi_endproc
  65              	.LFE139:
  67              	 .section .text.XMC_CCU4_SLICE_IsTimerRunning,"ax",%progbits
  68              	 .align 2
  69              	 .thumb
  70              	 .thumb_func
  72              	XMC_CCU4_SLICE_IsTimerRunning:
  73              	.LFB145:
 990:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
 991:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
 992:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU4 module
 993:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice_number Slice for which the clock should be disabled.
 994:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *                   Range: [0x0 to 0x3]
 995:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
 996:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
 997:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
 998:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
 999:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Disables the slice timer clock, by configuring GIDLS.SS0I, GIDLS.SSS1I, GIDLS.SSS2I,
1000:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * GIDLS.SSS3I bits according to the selected \a slice_number .\n\n
1001:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * It is possible to disable clock at slice level using the module pointer.
1002:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \b slice_number is used to disable the clock to a given slice of the module.
1003:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Directly accessed Register is GIDLS.
1004:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1005:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1006:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_EnableClock()<BR> XMC_CCU4_EnableMultipleClocks()<BR> XMC_CCU4_StartPrescaler()<BR> XMC
1007:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1008:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_DisableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_num
1009:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
1010:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_DisableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
1011:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_DisableClock:Invalid Slice Number", (slice_number < 4U));
1012:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1013:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   module->GIDLS = ((uint32_t) 1) << slice_number;
1014:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
1015:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1016:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1017:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU8 module
1018:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param mode   Selects suspend mode
1019:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1020:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1021:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1022:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1023:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures the entering in suspend mode for all the CCU8 slices.
1024:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1025:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1026:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * None.
1027:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1028:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_SetSuspendMode(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SUSPEN
1029:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
1030:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_EnableMultipleClocks:Invalid Module Pointer", XMC_CCU4_IsValidModule(module)
1031:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   module->GCTRL = (module->GCTRL & (uint32_t)~CCU4_GCTRL_SUSCFG_Msk) | mode;
1032:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
1033:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1034:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1035:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1036:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param compare_init Pointer to slice configuration structure
1037:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1038:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1039:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1040:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1041:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Initialization of a CC4 slice to compare mode, by configuring CC4yTC, CC4yCMC, CC4yPSC, CC4yDITH
1042:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * CC4yFPCS, CC4yCHC registers.\n\n
1043:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * CC4 slice is configured with Timer configurations in this routine.
1044:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * After initialization user has to explicitly enable the shadow transfer for the required values b
1045:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_EnableShadowTransfer() with appropriate mask.
1046:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1047:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1048:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * None.
1049:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1050:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_CompareInit(XMC_CCU4_SLICE_t *const slice,
1051:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                 const XMC_CCU4_SLICE_COMPARE_CONFIG_t *const compare_init);
1052:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1053:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1054:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1055:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param capture_init Pointer to slice configuration structure
1056:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1057:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1058:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1059:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1060:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Initialization of a CC4 slice to capture mode, by configuring CC4yTC, CC4yCMC, CC4yPSC,CC4yFPCS 
1061:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * CC4 slice is configured with Capture configurations in  this routine.After initialization user h
1062:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * enable the shadow transfer for the required  values by calling XMC_CCU4_EnableShadowTransfer()
1063:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * with appropriate mask.
1064:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1065:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1066:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_SLICE_Capture0Config()<BR> XMC_CCU4_SLICE_Capture1Config().
1067:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1068:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_CaptureInit(XMC_CCU4_SLICE_t *const slice,
1069:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                 const XMC_CCU4_SLICE_CAPTURE_CONFIG_t *const capture_init);
1070:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1071:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1072:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1073:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1074:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param event Map an External event to the External Start Function
1075:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param start_mode Behavior of slice when the start function is activated
1076:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1077:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1078:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1079:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1080:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Configures the Start Function of the slice, by configuring CC4yCMC.ENDS and CC4yTC.ENDM bits.\n
1081:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Start function is mapped with one of the 3 events. An external signal can control when a CC4 ti
1082:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Additionally, the behaviour of the slice upon activation of the start function is configured as
1083:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1084:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1085:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_SLICE_StopConfig()<BR> XMC_CCU4_SLICE_ConfigureEvent()<BR> XMC_CCU4_SLICE_SetInput().
1086:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1087:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_StartConfig(XMC_CCU4_SLICE_t *const slice,
1088:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                 const XMC_CCU4_SLICE_EVENT_t event,
1089:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                 const XMC_CCU4_SLICE_START_MODE_t start_mode);
1090:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1091:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1092:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1093:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param event Map an External event to the External Stop Function
1094:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param end_mode Behavior of slice when the stop function is activated
1095:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1096:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1097:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1098:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1099:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures the Stop function for the slice, by configuring CC4yCMC.STRTS and CC4yTC.STRM bits.\n
1100:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Stop function is mapped with one of the 3 events. An external signal can control when a CCU4 tim
1101:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Additionally, the behaviour of the slice upon activation of the stop function is configured as w
1102:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1103:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1104:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_SLICE_StartConfig()<BR> XMC_CCU4_SLICE_ConfigureEvent()<BR> XMC_CCU4_SLICE_SetInput().
1105:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1106:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_StopConfig(XMC_CCU4_SLICE_t *const slice,
1107:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                const XMC_CCU4_SLICE_EVENT_t event,
1108:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                const XMC_CCU4_SLICE_END_MODE_t end_mode);
1109:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1110:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1111:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1112:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param event Map an External event to the External load Function
1113:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1114:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1115:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1116:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1117:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Configures the Load Function for the slice, by configuring CC4yCMC.LDS bit.\n\n
1118:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  Load function is mapped with one of the 3 events. Up on occurrence of the event,\n
1119:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  if CC4yTCST.CDIR set to 0,CC4yTIMER register is reloaded with the value from compare register\n
1120:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  if CC4yTCST.CDIR set to 1,CC4yTIMER register is reloaded with the value from period register\n
1121:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1122:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1123:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_ConfigureEvent()<BR> XMC_CCU4_SLICE_SetInput().
1124:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1125:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_LoadConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event);
1126:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1127:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1128:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1129:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1130:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param event Map an External event to the External Modulation Function
1131:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param mod_mode Desired Modulation mode
1132:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param synch_with_pwm Option to synchronize modulation with PWM start
1133:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *                       Pass \b true if the modulation needs to be synchronized with PWM signal.
1134:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1135:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1136:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1137:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1138:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures the Output Modulation Function of the slice, by configuring CCeyCMC.MOS, CC4yTC.EMT a
1139:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * CC4yTC.EMS bits.\n\n
1140:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Modulation function is mapped with one of the 3 events. The output signal of the CCU can
1141:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * be modulated according to a external input.  Additionally, the behaviour of the slice upon activ
1142:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * of the modulation function is configured as well.
1143:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1144:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1145:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_ConfigureEvent()<BR> XMC_CCU4_SLICE_SetInput().
1146:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1147:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_ModulationConfig(XMC_CCU4_SLICE_t *const slice,
1148:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                      const XMC_CCU4_SLICE_EVENT_t event,
1149:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                      const XMC_CCU4_SLICE_MODULATION_MODE_t mod_mode,
1150:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                      const bool synch_with_pwm);
1151:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1152:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1153:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1154:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param event Map an External event to the External Count Function
1155:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1156:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1157:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1158:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1159:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures the Count Function of the slice, by configuring CC4yCMC.CNTS bit.\n\n
1160:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Count function is mapped with one of the 3 events. CCU4 slice can take an external
1161:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * signal to act as the counting event. The CCU4 slice would count the
1162:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * edges present on the \b event selected.
1163:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1164:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1165:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_ConfigureEvent()<BR> XMC_CCU4_SLICE_SetInput().
1166:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1167:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_CountConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event);
1168:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1169:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1170:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1171:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param event  Map an External event to the External Gating Function
1172:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1173:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1174:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1175:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1176:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures the Gating Function of the slice, by configuring CC4yCMC.GATES bit.\n\n
1177:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Gating function is mapped with one of the 3 events.  A CCU4 slice can use an input signal that w
1178:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * operate as counter gating. If the configured Active level is detected the counter will gate all 
1179:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1180:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1181:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_ConfigureEvent()<BR> XMC_CCU4_SLICE_SetInput().
1182:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1183:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_GateConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t event);
1184:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1185:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1186:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1187:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param event Map an External event to the Capture-0 Function
1188:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1189:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1190:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1191:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1192:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures the Capture-0 Function of the slice, by configuring CC4yCMC.CAP0S bit.\n\n
1193:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Capture function is mapped with one of the 3 events.  A CCU4 slice can be configured into captur
1194:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * with the selected \b event. In this mode the CCU4 will capture the timer value into CC4yC0V and 
1195:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1196:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1197:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_ConfigureEvent()<BR> XMC_CCU4_SLICE_SetInput().
1198:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1199:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_Capture0Config(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t even
1200:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1201:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1202:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1203:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param event Map an External event to the Capture-1 Function
1204:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1205:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1206:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1207:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1208:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures the Capture-1 Function of the slice, by configuring CC4yCMC.CAP1S bit.\n\n
1209:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Capture function is mapped with one of the 3 events. A CCU4 slice can be configured into capture
1210:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * mode with the selected \b event. In this mode the CCU4 will capture the timer value into CC4yC2V
1211:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1212:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1213:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_ConfigureEvent()<BR> XMC_CCU4_SLICE_SetInput().
1214:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1215:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_Capture1Config(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t even
1216:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1217:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1218:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1219:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1220:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    bool would return true if the extended capture read back mode is enabled<BR>
1221:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1222:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1223:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Checks if Extended capture mode read is enabled for particular slice or not, by reading CC4yTC.E
1224:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * In this mode the there is only one associated read address for all the capture registers.
1225:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Individual capture registers can still be accessed in this mode.
1226:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1227:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1228:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_GetCapturedValueFromFifo().
1229:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1230:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE bool XMC_CCU4_SLICE_IsExtendedCapReadEnabled(const XMC_CCU4_SLICE_t *const slice)
1231:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
1232:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_IsExtendedCapReadEnabled:Invalid Module Pointer", XMC_CCU4_IsValidSlic
1233:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   return ((bool)((slice->TC & (uint32_t) CCU4_CC4_TC_ECM_Msk) == (uint32_t)CCU4_CC4_TC_ECM_Msk));
1234:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
1235:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1236:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #if defined(CCU4V1) /* Defined for XMC4500, XMC4400, XMC4200, XMC4100 devices only */
1237:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1238:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU4 module
1239:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice_number to check whether read value belongs to required slice or not
1240:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1241:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *   int32_t   Returns -1 if the FIFO value being retrieved is not from the \b slice_number.
1242:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *             Returns the value captured in the \b slice_number, if captured value is from the cor
1243:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *                     Range: [0x0 to 0xFFFF]
1244:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1245:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1246:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Read captured value from FIFO(ECRD register).\n\n
1247:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This is applicable only in the Capture mode of operation. The signal whose timing characteristic
1248:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * must be mapped to an event which in turn must be mapped to the capture function. Based on the ca
1249:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * instant timer values are captured into capture registers. Timing characteristics of the input si
1250:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * derived/inferred from the captured values.
1251:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1252:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1253:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_IsExtendedCapReadEnabled().
1254:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  @note Only available for XMC4500, XMC4400, XMC4200 and XMC4100 series
1255:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1256:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** int32_t XMC_CCU4_GetCapturedValueFromFifo(const XMC_CCU4_MODULE_t *const module, const uint8_t slic
1257:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #else
1258:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1259:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1260:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param set The capture register set from which the captured value is to be retrieved
1261:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1262:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    uint32_t Returns the value captured in the \b slice_number
1263:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *             Range: [0x0 to 0xFFFF]
1264:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1265:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1266:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Read captured value from FIFO(CC4yECRD0 and CC4yECRD1).\n\n
1267:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This is applicable only in the Capture mode of operation. The signal whose timing characteristic
1268:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * must be mapped to an event which in turn must be mapped to the capture function. Based on the ca
1269:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * instant timer values are captured into capture registers. Timing characteristics of the input si
1270:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * derived/inferred from the captured values.
1271:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1272:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1273:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_IsExtendedCapReadEnabled().
1274:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @note Defined for XMC4800, XMC4700, XMC4500, XMC4400, XMC4200, XMC4100 devices only. For other d
1275:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1276:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** uint32_t XMC_CCU4_SLICE_GetCapturedValueFromFifo(const XMC_CCU4_SLICE_t *const slice,
1277:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****     const XMC_CCU4_SLICE_CAP_REG_SET_t set);
1278:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** #endif
1279:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1280:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1281:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1282:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param event Map an External event to the External Count Direction Function
1283:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1284:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1285:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1286:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1287:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures the Count Direction of the slice, by configuring CC4yCMC.UDS bit.\n\n
1288:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Count direction function is mapped with one of the 3 events. A slice can be configured to change
1289:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * CC4yTIMER count direction depending on an external signal.
1290:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1291:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1292:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_ConfigureEvent()<BR> XMC_CCU4_SLICE_SetInput().
1293:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1294:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_DirectionConfig(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_EVENT_t eve
1295:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1296:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1297:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1298:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1299:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1300:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1301:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1302:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures the status bit override Function of the slice, by configuring CC4yCMC.OFS bit.\n\n
1303:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Status bit override function is mapped with one of the 3 events. A slice can be configured to ch
1304:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * output of the timer's CC4yST signal depending on an external signal.
1305:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1306:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1307:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent().
1308:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1309:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_StatusBitOverrideConfig(XMC_CCU4_SLICE_t *const slice);
1310:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1311:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1312:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1313:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param exit_mode How should a previously logged trap state be exited?
1314:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param synch_with_pwm Should exit of trap state be synchronized with PWM cycle start?
1315:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1316:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1317:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1318:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1319:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures the Trap Function of the slice, by configuring CC4yCMC.TS, CC4yTC.TRPSE, and CC4yTC.T
1320:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Trap function is mapped with Event-2. Criteria for exiting the trap state is configured.
1321:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This trap function allows PWM outputs to react on the state of an input pin.
1322:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Thus PWM output can be forced to inactive state upon detection of a trap.
1323:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * It is also possible to synchronize the trap function with the PWM signal using the \b synch_with
1324:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1325:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1326:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_ConfigureEvent()<BR> XMC_CCU4_SLICE_SetInput().
1327:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1328:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_TrapConfig(XMC_CCU4_SLICE_t *const slice,
1329:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                const XMC_CCU4_SLICE_TRAP_EXIT_MODE_t exit_mode,
1330:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                bool synch_with_pwm);
1331:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1332:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1333:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1334:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1335:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param ev1_config Pointer to event 1 configuration data
1336:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param ev2_config Pointer to event 2 configuration data
1337:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1338:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1339:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1340:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1341:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1342:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Map Status bit override function with an Event1 & Event 2 of the slice and configure CC4yINS reg
1343:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Details such as the input mapped to the event, event detection criteria and Low Pass filter opti
1344:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * by this routine for the events 1 & 2.  Event-1 input would be the trigger to override the value.
1345:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Event-2 input would be the override value.
1346:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1347:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1348:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_StatusBitOverrideConfig().
1349:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1350:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_ConfigureStatusBitOverrideEvent(XMC_CCU4_SLICE_t *const slice,
1351:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****     const XMC_CCU4_SLICE_EVENT_CONFIG_t *const ev1_config,
1352:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****     const XMC_CCU4_SLICE_EVENT_CONFIG_t *const ev2_config);
1353:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1354:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1355:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1356:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param event The External Event which needs to be configured.
1357:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param config Pointer to event configuration data.
1358:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1359:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1360:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1361:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1362:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures an External Event of the slice, by updating CC4yINS register .\n\n
1363:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Details such as the input mapped to the event, event detection criteria and low pass filter
1364:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * options are programmed by this routine. The Event \b config  will configure the input selection,
1365:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * the edge selection, the level selection and the Low pass filter for the  event.
1366:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1367:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1368:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_StartConfig()<BR> XMC_CCU4_SLICE_StopConfig()<BR> XMC_CCU4_SLICE_LoadConfig()<BR
1369:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_ModulationConfig()<BR> XMC_CCU4_SLICE_CountConfig()<BR> XMC_CCU4_SLICE_GateConfi
1370:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_Capture0Config()<BR> XMC_CCU4_SLICE_Capture1Config()<BR> XMC_CCU4_SLICE_Directio
1371:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_StatusBitOverrideConfig()<BR> XMC_CCU4_SLICE_TrapConfig().
1372:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1373:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_ConfigureEvent(XMC_CCU4_SLICE_t *const slice,
1374:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                    const XMC_CCU4_SLICE_EVENT_t event,
1375:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                                    const XMC_CCU4_SLICE_EVENT_CONFIG_t *const config);
1376:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1377:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1378:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1379:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param event The External Event which needs to be configured.
1380:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param input One of the 16 inputs meant to be mapped to the desired event
1381:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1382:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1383:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1384:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1385:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1386:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Selects an input for an external event, by configuring CC4yINS register.\n\n
1387:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * It is possible to select one of the possible 16 input signals for a given Event.
1388:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This configures the CC4yINS.EVxIS for the selected event.
1389:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1390:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1391:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_StartConfig()<BR> XMC_CCU4_SLICE_StopConfig()<BR> XMC_CCU4_SLICE_LoadConfig()<BR
1392:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_ModulationConfig()<BR> XMC_CCU4_SLICE_CountConfig()<BR> XMC_CCU4_SLICE_GateConfi
1393:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_Capture0Config()<BR> XMC_CCU4_SLICE_Capture1Config()<BR> XMC_CCU4_SLICE_Directio
1394:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_StatusBitOverrideConfig()<BR> XMC_CCU4_SLICE_TrapConfig().
1395:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1396:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_SetInput(XMC_CCU4_SLICE_t *const slice,
1397:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                              const XMC_CCU4_SLICE_EVENT_t event,
1398:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****                              const XMC_CCU4_SLICE_INPUT_t input);
1399:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1400:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1401:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1402:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1403:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1404:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1405:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1406:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Enables the trap feature, by setting CC4yTC.TRAPE0, CC4yTC.TRAPE1, CC4yTC.TRAPE2 and CC4yTC.TRAP
1407:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \a out_mask.\n\n
1408:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * A particularly useful feature where the PWM output can be forced inactive upon detection of a tr
1409:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * can be the output of a sensing element which has just detected an abnormal electrical condition.
1410:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1411:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1412:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_TrapConfig()<BR> XMC_CCU4_SLICE_DisableTrap()<BR> XMC_CCU4_SLICE_ConfigureEvent(
1413:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_SetInput().
1414:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1415:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_SLICE_EnableTrap(XMC_CCU4_SLICE_t *const slice)
1416:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
1417:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_EnableTrap:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
1418:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   slice->TC |= (uint32_t) CCU4_CC4_TC_TRAPE_Msk;
1419:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
1420:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1421:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1422:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1423:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1424:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1425:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1426:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1427:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Disables the trap feature, by clearing CC4yTC.TRAPE0, CC4yTC.TRAPE1, CC4yTC.TRAPE2 and CC4yTC.TR
1428:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \a out_mask.\n\n.\n\n
1429:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This API will revert the changes done by XMC_CCU4_SLICE_EnableTrap().
1430:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This Ensures that the TRAP function has no effect on the output of the CCU4 slice.
1431:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1432:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1433:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_EnableTrap().
1434:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1435:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_SLICE_DisableTrap(XMC_CCU4_SLICE_t *const slice)
1436:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
1437:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_DisableTrap:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
1438:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   slice->TC &= ~((uint32_t) CCU4_CC4_TC_TRAPE_Msk);
1439:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
1440:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1441:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1442:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1443:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1444:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    bool returns \b true if the Timer is running else it returns \b false.
1445:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1446:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1447:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Returns the state of the timer (Either Running or stopped(idle)), by reading CC4yTCST.TRB bit.
1448:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1449:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1450:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_StartTimer()<BR> XMC_CCU4_SLICE_StopTimer().
1451:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1452:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE bool XMC_CCU4_SLICE_IsTimerRunning(const XMC_CCU4_SLICE_t *const slice)
1453:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
  74              	 .loc 1 1453 0
  75              	 .cfi_startproc
  76              	 
  77              	 
  78              	 
  79 0000 80B4     	 push {r7}
  80              	.LCFI6:
  81              	 .cfi_def_cfa_offset 4
  82              	 .cfi_offset 7,-4
  83 0002 83B0     	 sub sp,sp,#12
  84              	.LCFI7:
  85              	 .cfi_def_cfa_offset 16
  86 0004 00AF     	 add r7,sp,#0
  87              	.LCFI8:
  88              	 .cfi_def_cfa_register 7
  89 0006 7860     	 str r0,[r7,#4]
1454:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
1455:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   return (bool)(((slice->TCST) & CCU4_CC4_TCST_TRB_Msk) == CCU4_CC4_TCST_TRB_Msk);
  90              	 .loc 1 1455 0
  91 0008 7B68     	 ldr r3,[r7,#4]
  92 000a 9B68     	 ldr r3,[r3,#8]
  93 000c 03F00103 	 and r3,r3,#1
  94 0010 002B     	 cmp r3,#0
  95 0012 14BF     	 ite ne
  96 0014 0123     	 movne r3,#1
  97 0016 0023     	 moveq r3,#0
  98 0018 DBB2     	 uxtb r3,r3
1456:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
  99              	 .loc 1 1456 0
 100 001a 1846     	 mov r0,r3
 101 001c 0C37     	 adds r7,r7,#12
 102              	.LCFI9:
 103              	 .cfi_def_cfa_offset 4
 104 001e BD46     	 mov sp,r7
 105              	.LCFI10:
 106              	 .cfi_def_cfa_register 13
 107              	 
 108 0020 5DF8047B 	 ldr r7,[sp],#4
 109              	.LCFI11:
 110              	 .cfi_restore 7
 111              	 .cfi_def_cfa_offset 0
 112 0024 7047     	 bx lr
 113              	 .cfi_endproc
 114              	.LFE145:
 116 0026 00BF     	 .section .text.XMC_CCU4_SLICE_StartTimer,"ax",%progbits
 117              	 .align 2
 118              	 .thumb
 119              	 .thumb_func
 121              	XMC_CCU4_SLICE_StartTimer:
 122              	.LFB147:
1457:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1458:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1459:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1460:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1461:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *   ::XMC_CCU4_SLICE_TIMER_COUNT_DIR_t returns the direction in which the timer is counting.
1462:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1463:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1464:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Returns the timer counting direction, by reading CC4yTCST.CDIR bit.\n\n
1465:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This API will return the direction in which the timer is currently
1466:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * incrementing(XMC_CCU4_SLICE_TIMER_COUNT_DIR_UP) or decrementing (XMC_CCU4_SLICE_TIMER_COUNT_DIR_
1467:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1468:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1469:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  None.
1470:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1471:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE XMC_CCU4_SLICE_TIMER_COUNT_DIR_t XMC_CCU4_SLICE_GetCountingDir(const XMC_CCU4_SLICE
1472:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
1473:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_GetCountingDir:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
1474:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   return ((XMC_CCU4_SLICE_TIMER_COUNT_DIR_t)(((slice->TCST) & CCU4_CC4_TCST_CDIR_Msk) >> CCU4_CC4_T
1475:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
1476:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1477:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1478:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1479:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1480:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1481:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1482:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1483:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Starts the timer counting operation, by setting CC4yTCSET.TRBS bit.\n\n
1484:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * It is necessary to have configured the CC4 slice before starting its timer.
1485:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Before the Timer is started ensure that the clock is provided to the slice.
1486:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1487:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1488:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_StopTimer().
1489:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1490:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
1491:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 123              	 .loc 1 1491 0
 124              	 .cfi_startproc
 125              	 
 126              	 
 127              	 
 128 0000 80B4     	 push {r7}
 129              	.LCFI12:
 130              	 .cfi_def_cfa_offset 4
 131              	 .cfi_offset 7,-4
 132 0002 83B0     	 sub sp,sp,#12
 133              	.LCFI13:
 134              	 .cfi_def_cfa_offset 16
 135 0004 00AF     	 add r7,sp,#0
 136              	.LCFI14:
 137              	 .cfi_def_cfa_register 7
 138 0006 7860     	 str r0,[r7,#4]
1492:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
1493:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 139              	 .loc 1 1493 0
 140 0008 7B68     	 ldr r3,[r7,#4]
 141 000a 0122     	 movs r2,#1
 142 000c DA60     	 str r2,[r3,#12]
1494:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
 143              	 .loc 1 1494 0
 144 000e 0C37     	 adds r7,r7,#12
 145              	.LCFI15:
 146              	 .cfi_def_cfa_offset 4
 147 0010 BD46     	 mov sp,r7
 148              	.LCFI16:
 149              	 .cfi_def_cfa_register 13
 150              	 
 151 0012 5DF8047B 	 ldr r7,[sp],#4
 152              	.LCFI17:
 153              	 .cfi_restore 7
 154              	 .cfi_def_cfa_offset 0
 155 0016 7047     	 bx lr
 156              	 .cfi_endproc
 157              	.LFE147:
 159              	 .section .text.XMC_CCU4_SLICE_StopTimer,"ax",%progbits
 160              	 .align 2
 161              	 .thumb
 162              	 .thumb_func
 164              	XMC_CCU4_SLICE_StopTimer:
 165              	.LFB148:
1495:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1496:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1497:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1498:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1499:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1500:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1501:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1502:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Stops the Timer.<BR>\n
1503:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Timer counting operation can be stopped by invoking this API, by setting CC4yTCCLR.TRBC bit.
1504:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1505:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1506:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_StartTimer().
1507:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1508:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_SLICE_StopTimer(XMC_CCU4_SLICE_t *const slice)
1509:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 166              	 .loc 1 1509 0
 167              	 .cfi_startproc
 168              	 
 169              	 
 170              	 
 171 0000 80B4     	 push {r7}
 172              	.LCFI18:
 173              	 .cfi_def_cfa_offset 4
 174              	 .cfi_offset 7,-4
 175 0002 83B0     	 sub sp,sp,#12
 176              	.LCFI19:
 177              	 .cfi_def_cfa_offset 16
 178 0004 00AF     	 add r7,sp,#0
 179              	.LCFI20:
 180              	 .cfi_def_cfa_register 7
 181 0006 7860     	 str r0,[r7,#4]
1510:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
1511:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 182              	 .loc 1 1511 0
 183 0008 7B68     	 ldr r3,[r7,#4]
 184 000a 0122     	 movs r2,#1
 185 000c 1A61     	 str r2,[r3,#16]
1512:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
 186              	 .loc 1 1512 0
 187 000e 0C37     	 adds r7,r7,#12
 188              	.LCFI21:
 189              	 .cfi_def_cfa_offset 4
 190 0010 BD46     	 mov sp,r7
 191              	.LCFI22:
 192              	 .cfi_def_cfa_register 13
 193              	 
 194 0012 5DF8047B 	 ldr r7,[sp],#4
 195              	.LCFI23:
 196              	 .cfi_restore 7
 197              	 .cfi_def_cfa_offset 0
 198 0016 7047     	 bx lr
 199              	 .cfi_endproc
 200              	.LFE148:
 202              	 .section .text.XMC_CCU4_SLICE_ClearTimer,"ax",%progbits
 203              	 .align 2
 204              	 .thumb
 205              	 .thumb_func
 207              	XMC_CCU4_SLICE_ClearTimer:
 208              	.LFB149:
1513:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1514:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1515:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1516:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1517:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1518:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1519:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1520:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Resets the timer count to zero, by setting CC4yTCCLR.TCC bit.\n\n
1521:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * A timer which has been stopped can still retain the last counted value.
1522:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * After invoking this API the timer value will be cleared.
1523:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1524:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1525:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_StartTimer().
1526:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1527:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
1528:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 209              	 .loc 1 1528 0
 210              	 .cfi_startproc
 211              	 
 212              	 
 213              	 
 214 0000 80B4     	 push {r7}
 215              	.LCFI24:
 216              	 .cfi_def_cfa_offset 4
 217              	 .cfi_offset 7,-4
 218 0002 83B0     	 sub sp,sp,#12
 219              	.LCFI25:
 220              	 .cfi_def_cfa_offset 16
 221 0004 00AF     	 add r7,sp,#0
 222              	.LCFI26:
 223              	 .cfi_def_cfa_register 7
 224 0006 7860     	 str r0,[r7,#4]
1529:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
1530:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 225              	 .loc 1 1530 0
 226 0008 7B68     	 ldr r3,[r7,#4]
 227 000a 0222     	 movs r2,#2
 228 000c 1A61     	 str r2,[r3,#16]
1531:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
 229              	 .loc 1 1531 0
 230 000e 0C37     	 adds r7,r7,#12
 231              	.LCFI27:
 232              	 .cfi_def_cfa_offset 4
 233 0010 BD46     	 mov sp,r7
 234              	.LCFI28:
 235              	 .cfi_def_cfa_register 13
 236              	 
 237 0012 5DF8047B 	 ldr r7,[sp],#4
 238              	.LCFI29:
 239              	 .cfi_restore 7
 240              	 .cfi_def_cfa_offset 0
 241 0016 7047     	 bx lr
 242              	 .cfi_endproc
 243              	.LFE149:
 245              	 .section .text.XMC_CCU4_SLICE_SetTimerPeriodMatch,"ax",%progbits
 246              	 .align 2
 247              	 .thumb
 248              	 .thumb_func
 250              	XMC_CCU4_SLICE_SetTimerPeriodMatch:
 251              	.LFB154:
1532:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1533:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1534:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1535:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1536:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1537:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1538:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1539:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Stops and resets the timer count to zero, by setting CC4yTCCLR.TCC and CC4yTCCLR.TRBC bit.\n\n
1540:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1541:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1542:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_StartTimer().
1543:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1544:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_SLICE_StopClearTimer(XMC_CCU4_SLICE_t *const slice)
1545:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
1546:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_StopClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
1547:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   slice->TCCLR = CCU4_CC4_TCCLR_TRBC_Msk | CCU4_CC4_TCCLR_TCC_Msk;
1548:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
1549:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1550:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1551:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1552:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1553:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    ::XMC_CCU4_SLICE_MODE_t returns XMC_CCU4_SLICE_MODE_COMPARE if the slice is operating in comp
1554:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *                          returns XMC_CCU4_SLICE_MODE_CAPTURE if the slice is operating in captur
1555:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1556:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1557:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Retrieves the current mode of operation in the slice (either Capture mode or Compare mode), by r
1558:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * CC4yTC.CMOD bit.\n\n
1559:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Ensure that before invoking this API the CCU4 slice should be configured otherwise the output of
1560:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * invalid.
1561:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1562:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1563:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  None.
1564:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1565:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE XMC_CCU4_SLICE_MODE_t XMC_CCU4_SLICE_GetSliceMode(const XMC_CCU4_SLICE_t *const sli
1566:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
1567:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_GetSliceMode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
1568:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   return ((XMC_CCU4_SLICE_MODE_t)(((slice->TC) & CCU4_CC4_TC_CMOD_Msk) >> CCU4_CC4_TC_CMOD_Pos));
1569:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
1570:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1571:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1572:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param mode Desired repetition mode (Either single shot or Continuous)
1573:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1574:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1575:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1576:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1577:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures the Timer to either Single shot mode or continuous mode, by configuring CC4yTC.TSSM b
1578:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * The timer will count up to the terminal count as specified in the period register and stops imme
1579:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * mode has been set to single shot. In the continuous mode of operation, the timer starts counting
1580:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * reaching the terminal count.
1581:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1582:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1583:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_GetTimerRepeatMode().
1584:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1585:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_SetTimerRepeatMode(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_TIMER_RE
1586:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1587:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1588:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1589:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <br>
1590:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  ::XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t returns XMC_CCU4_SLICE_TIMER_REPEAT_MODE_REPEAT if continu
1591:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *                                     returns XMC_CCU4_SLICE_TIMER_REPEAT_MODE_SINGLE if single sh
1592:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1593:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1594:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Retrieves the Timer repeat mode, either Single shot mode or continuous mode, by reading CC4yTC.T
1595:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * The timer will count up to the terminal count as specified in the period register and stops imme
1596:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * mode has been set to single shot mode. In the continuous mode of operation, the timer starts cou
1597:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * all over again after reaching the terminal count.
1598:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1599:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1600:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_SetTimerRepeatMode().
1601:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1602:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t XMC_CCU4_SLICE_GetTimerRepeatMode(
1603:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   const XMC_CCU4_SLICE_t *const slice)
1604:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
1605:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_GetTimerRepeatMode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice
1606:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   return ((XMC_CCU4_SLICE_TIMER_REPEAT_MODE_t)(((slice->TC) & CCU4_CC4_TC_TSSM_Msk) >> CCU4_CC4_TC_
1607:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
1608:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1609:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1610:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param mode Desired counting mode (Either Edge Aligned or Center Aligned)
1611:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1612:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1613:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1614:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1615:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Configures the timer counting mode either Edge Aligned or Center Aligned, by configuring CC4yTC.
1616:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * In the edge aligned mode, the timer counts from 0 to the terminal count. Once the timer count ha
1617:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * compare value, the timer status output asserts itself. It will now deassert only after the timer
1618:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * terminal count.\n In the center aligned mode, the timer first counts from 0 to the terminal coun
1619:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * During this upward and downward counting, the timer status output stays asserted as long as the 
1620:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * greater than the compare value.
1621:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1622:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1623:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_GetTimerCountingMode().
1624:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1625:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** void XMC_CCU4_SLICE_SetTimerCountingMode(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_TIMER_
1626:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1627:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1628:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1629:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <br>
1630:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  ::XMC_CCU4_SLICE_TIMER_COUNT_MODE_t returns XMC_CCU4_SLICE_TIMER_COUNT_MODE_EA if edge aligned 
1631:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *                                     returns XMC_CCU4_SLICE_TIMER_COUNT_MODE_CA if center aligned
1632:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1633:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1634:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Retrieves timer counting mode either Edge aligned or Center Aligned, by reading CC4yTC.TCM bit.\
1635:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1636:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1637:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_SetTimerCountingMode().
1638:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1639:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE XMC_CCU4_SLICE_TIMER_COUNT_MODE_t XMC_CCU4_SLICE_GetTimerCountingMode(
1640:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   const XMC_CCU4_SLICE_t *const slice)
1641:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
1642:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_GetTimerCountingMode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(sli
1643:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   return ((XMC_CCU4_SLICE_TIMER_COUNT_MODE_t)(((slice->TC) & CCU4_CC4_TC_TCM_Msk) >> CCU4_CC4_TC_TC
1644:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
1645:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1646:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1647:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param period_val Timer period value
1648:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *        Range: [0x0 to 0xFFFF]
1649:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1650:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1651:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1652:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1653:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Programs the timer period, by writing CC4yPRS register.\n\n
1654:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * The frequency of counting/ PWM frequency is determined by this value. The period value is writte
1655:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * register. Explicitly enable the shadow transfer for the the period value by calling
1656:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_EnableShadowTransfer() with appropriate mask. If shadow transfer is enabled and the tim
1657:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * a period match transfers the value from the shadow register to the actual period register.
1658:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1659:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1660:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
1661:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1662:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16
1663:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 252              	 .loc 1 1663 0
 253              	 .cfi_startproc
 254              	 
 255              	 
 256              	 
 257 0000 80B4     	 push {r7}
 258              	.LCFI30:
 259              	 .cfi_def_cfa_offset 4
 260              	 .cfi_offset 7,-4
 261 0002 83B0     	 sub sp,sp,#12
 262              	.LCFI31:
 263              	 .cfi_def_cfa_offset 16
 264 0004 00AF     	 add r7,sp,#0
 265              	.LCFI32:
 266              	 .cfi_def_cfa_register 7
 267 0006 7860     	 str r0,[r7,#4]
 268 0008 0B46     	 mov r3,r1
 269 000a 7B80     	 strh r3,[r7,#2]
1664:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slic
1665:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   slice->PRS = (uint32_t) period_val;
 270              	 .loc 1 1665 0
 271 000c 7A88     	 ldrh r2,[r7,#2]
 272 000e 7B68     	 ldr r3,[r7,#4]
 273 0010 5A63     	 str r2,[r3,#52]
1666:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
 274              	 .loc 1 1666 0
 275 0012 0C37     	 adds r7,r7,#12
 276              	.LCFI33:
 277              	 .cfi_def_cfa_offset 4
 278 0014 BD46     	 mov sp,r7
 279              	.LCFI34:
 280              	 .cfi_def_cfa_register 13
 281              	 
 282 0016 5DF8047B 	 ldr r7,[sp],#4
 283              	.LCFI35:
 284              	 .cfi_restore 7
 285              	 .cfi_def_cfa_offset 0
 286 001a 7047     	 bx lr
 287              	 .cfi_endproc
 288              	.LFE154:
 290              	 .section .text.XMC_CCU4_SLICE_SetTimerCompareMatch,"ax",%progbits
 291              	 .align 2
 292              	 .thumb
 293              	 .thumb_func
 295              	XMC_CCU4_SLICE_SetTimerCompareMatch:
 296              	.LFB156:
1667:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1668:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1669:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1670:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1671:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *   uint16_t returns the current timer period value
1672:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *            Range: [0x0 to 0xFFFF]
1673:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1674:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1675:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Retrieves the timer period value currently effective, by reading CC4yPR register.\n\n
1676:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * If the timer is active then the value being returned is currently being used for the PWM period.
1677:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1678:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Note:</b><br>
1679:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * The XMC_CCU4_SLICE_SetTimerPeriodMatch() would set the new period value to a shadow register.
1680:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This would only transfer the new values into the actual period register if the shadow transfer r
1681:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * is enabled and if a period match occurs. Hence a consecutive call to XMC_CCU4_SLICE_GetTimerPeri
1682:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * would not reflect the new values until the shadow transfer completes.
1683:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1684:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1685:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_SetTimerPeriodMatch().
1686:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1687:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE uint16_t XMC_CCU4_SLICE_GetTimerPeriodMatch(const XMC_CCU4_SLICE_t *const slice)
1688:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
1689:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slic
1690:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   return ((uint16_t)slice->PR);
1691:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
1692:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1693:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1694:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1695:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param compare_val Timer compare value
1696:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1697:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1698:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1699:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1700:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Programs the timer compare value, by writing CC4yCRS register.<BR>\n
1701:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  The PWM duty cycle is determined by this value.
1702:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * The compare value is written to a shadow register. Explicitly enable the shadow transfer for
1703:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * the the period/compare value by calling XMC_CCU4_EnableShadowTransfer() with
1704:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * appropriate mask.If shadow transfer is enabled and the timer is running,
1705:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * a period match transfers the value from the shadow register to the actual compare register.
1706:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1707:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1708:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
1709:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1710:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint1
1711:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 297              	 .loc 1 1711 0
 298              	 .cfi_startproc
 299              	 
 300              	 
 301              	 
 302 0000 80B4     	 push {r7}
 303              	.LCFI36:
 304              	 .cfi_def_cfa_offset 4
 305              	 .cfi_offset 7,-4
 306 0002 83B0     	 sub sp,sp,#12
 307              	.LCFI37:
 308              	 .cfi_def_cfa_offset 16
 309 0004 00AF     	 add r7,sp,#0
 310              	.LCFI38:
 311              	 .cfi_def_cfa_register 7
 312 0006 7860     	 str r0,[r7,#4]
 313 0008 0B46     	 mov r3,r1
 314 000a 7B80     	 strh r3,[r7,#2]
1712:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(sli
1713:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   slice->CRS = (uint32_t) compare_val;
 315              	 .loc 1 1713 0
 316 000c 7A88     	 ldrh r2,[r7,#2]
 317 000e 7B68     	 ldr r3,[r7,#4]
 318 0010 DA63     	 str r2,[r3,#60]
1714:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
 319              	 .loc 1 1714 0
 320 0012 0C37     	 adds r7,r7,#12
 321              	.LCFI39:
 322              	 .cfi_def_cfa_offset 4
 323 0014 BD46     	 mov sp,r7
 324              	.LCFI40:
 325              	 .cfi_def_cfa_register 13
 326              	 
 327 0016 5DF8047B 	 ldr r7,[sp],#4
 328              	.LCFI41:
 329              	 .cfi_restore 7
 330              	 .cfi_def_cfa_offset 0
 331 001a 7047     	 bx lr
 332              	 .cfi_endproc
 333              	.LFE156:
 335              	 .section .text.XMC_CCU4_EnableShadowTransfer,"ax",%progbits
 336              	 .align 2
 337              	 .thumb
 338              	 .thumb_func
 340              	XMC_CCU4_EnableShadowTransfer:
 341              	.LFB158:
1715:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1716:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1717:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param slice Constant pointer to CC4 Slice
1718:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1719:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *   uint16_t returns the current timer compare value
1720:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *            Range: [0x0 to 0xFFFF]
1721:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1722:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1723:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Retrieves the timer compare value currently effective, by reading CC4yCRS register.\n\n
1724:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * If the timer is active then the value being returned is currently being for the PWM duty cycle( 
1725:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1726:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Note:</b><br>
1727:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * The XMC_CCU4_SLICE_SetTimerCompareMatch() would set the new compare value to a shadow register.
1728:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * This would only transfer the new values into the actual compare register if the shadow transfer 
1729:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * is enabled and if a period match occurs. Hence a consecutive call to XMC_CCU4_SLICE_GetTimerComp
1730:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * would not reflect the new values until the shadow transfer completes.
1731:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Directly accessed Register is CC4yCR.
1732:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1733:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1734:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  XMC_CCU4_SLICE_SetTimerCompareMatch().
1735:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1736:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE uint16_t XMC_CCU4_SLICE_GetTimerCompareMatch(const XMC_CCU4_SLICE_t *const slice)
1737:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
1738:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_SLICE_GetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(sli
1739:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   return ((uint16_t)slice->CR);
1740:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
1741:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** 
1742:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** /**
1743:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param module Constant pointer to CCU4 module
1744:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @param shadow_transfer_msk Shadow transfer request mask for various transfers.
1745:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *                             Use ::XMC_CCU4_SHADOW_TRANSFER_t enum items to create a mask of choi
1746:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *                              using a bit wise OR operation.
1747:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * @return <BR>
1748:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *    None<BR>
1749:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1750:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Description:</b><br>
1751:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Requests of shadow transfer for Period, Compare, Passive level, dither and prescaler, by configu
1752:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * the GCSS register.\n\n
1753:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * The transfer from the shadow registers to the actual registers is done in the immediate next occ
1754:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * shadow transfer trigger after the API is called.
1755:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1756:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Any call to XMC_CCU4_SLICE_SetTimerPeriodMatch()<BR> XMC_CCU4_SLICE_SetTimerCompareMatch()<BR>
1757:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * XMC_CCU4_SLICE_SetPrescaler()<BR> XMC_CCU4_SLICE_CompareInit()<BR> XMC_CCU4_SLICE_CaptureInit().
1758:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * must be succeeded by this API.
1759:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * Directly accessed Register is GCSS.
1760:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *
1761:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  * \par<b>Related APIs:</b><br>
1762:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  *  None.
1763:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****  */
1764:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** __STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t 
1765:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** {
 342              	 .loc 1 1765 0
 343              	 .cfi_startproc
 344              	 
 345              	 
 346              	 
 347 0000 80B4     	 push {r7}
 348              	.LCFI42:
 349              	 .cfi_def_cfa_offset 4
 350              	 .cfi_offset 7,-4
 351 0002 83B0     	 sub sp,sp,#12
 352              	.LCFI43:
 353              	 .cfi_def_cfa_offset 16
 354 0004 00AF     	 add r7,sp,#0
 355              	.LCFI44:
 356              	 .cfi_def_cfa_register 7
 357 0006 7860     	 str r0,[r7,#4]
 358 0008 3960     	 str r1,[r7]
1766:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module))
1767:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h ****   module->GCSS = (uint32_t)shadow_transfer_msk;
 359              	 .loc 1 1767 0
 360 000a 7B68     	 ldr r3,[r7,#4]
 361 000c 3A68     	 ldr r2,[r7]
 362 000e 1A61     	 str r2,[r3,#16]
1768:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc\xmc_ccu4.h **** }
 363              	 .loc 1 1768 0
 364 0010 0C37     	 adds r7,r7,#12
 365              	.LCFI45:
 366              	 .cfi_def_cfa_offset 4
 367 0012 BD46     	 mov sp,r7
 368              	.LCFI46:
 369              	 .cfi_def_cfa_register 13
 370              	 
 371 0014 5DF8047B 	 ldr r7,[sp],#4
 372              	.LCFI47:
 373              	 .cfi_restore 7
 374              	 .cfi_def_cfa_offset 0
 375 0018 7047     	 bx lr
 376              	 .cfi_endproc
 377              	.LFE158:
 379 001a 00BF     	 .section .text.CAPTURE_GetAppVersion,"ax",%progbits
 380              	 .align 2
 381              	 .global CAPTURE_GetAppVersion
 382              	 .thumb
 383              	 .thumb_func
 385              	CAPTURE_GetAppVersion:
 386              	.LFB227:
 387              	 .file 2 "../Dave/Generated/CAPTURE/capture.c"
   1:../Dave/Generated/CAPTURE/capture.c **** /**
   2:../Dave/Generated/CAPTURE/capture.c ****  * @file capture.h
   3:../Dave/Generated/CAPTURE/capture.c ****  * @date 2016-07-01
   4:../Dave/Generated/CAPTURE/capture.c ****  *
   5:../Dave/Generated/CAPTURE/capture.c ****  *
   6:../Dave/Generated/CAPTURE/capture.c ****  * @cond
   7:../Dave/Generated/CAPTURE/capture.c ****  **************************************************************************************************
   8:../Dave/Generated/CAPTURE/capture.c ****  * CAPTURE v4.0.4 - Configures the properties of CCU4 or CCU8 peripheral as a capture.
   9:../Dave/Generated/CAPTURE/capture.c ****  *
  10:../Dave/Generated/CAPTURE/capture.c ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  11:../Dave/Generated/CAPTURE/capture.c ****  * All rights reserved.
  12:../Dave/Generated/CAPTURE/capture.c ****  *
  13:../Dave/Generated/CAPTURE/capture.c ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  14:../Dave/Generated/CAPTURE/capture.c ****  * following conditions are met:
  15:../Dave/Generated/CAPTURE/capture.c ****  *
  16:../Dave/Generated/CAPTURE/capture.c ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  17:../Dave/Generated/CAPTURE/capture.c ****  *   disclaimer.
  18:../Dave/Generated/CAPTURE/capture.c ****  *
  19:../Dave/Generated/CAPTURE/capture.c ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  20:../Dave/Generated/CAPTURE/capture.c ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  21:../Dave/Generated/CAPTURE/capture.c ****  *
  22:../Dave/Generated/CAPTURE/capture.c ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  23:../Dave/Generated/CAPTURE/capture.c ****  *   products derived from this software without specific prior written permission.
  24:../Dave/Generated/CAPTURE/capture.c ****  *
  25:../Dave/Generated/CAPTURE/capture.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  26:../Dave/Generated/CAPTURE/capture.c ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  27:../Dave/Generated/CAPTURE/capture.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  28:../Dave/Generated/CAPTURE/capture.c ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  29:../Dave/Generated/CAPTURE/capture.c ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  30:../Dave/Generated/CAPTURE/capture.c ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  31:../Dave/Generated/CAPTURE/capture.c ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  32:../Dave/Generated/CAPTURE/capture.c ****  *
  33:../Dave/Generated/CAPTURE/capture.c ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  34:../Dave/Generated/CAPTURE/capture.c ****  * with Infineon Technologies AG (dave@infineon.com).
  35:../Dave/Generated/CAPTURE/capture.c ****  **************************************************************************************************
  36:../Dave/Generated/CAPTURE/capture.c ****  *
  37:../Dave/Generated/CAPTURE/capture.c ****  * Change History
  38:../Dave/Generated/CAPTURE/capture.c ****  * --------------
  39:../Dave/Generated/CAPTURE/capture.c ****  *
  40:../Dave/Generated/CAPTURE/capture.c ****  * 2016-07-01:
  41:../Dave/Generated/CAPTURE/capture.c ****  *     - Initial version<br>
  42:../Dave/Generated/CAPTURE/capture.c ****  *
  43:../Dave/Generated/CAPTURE/capture.c ****  * @endcond
  44:../Dave/Generated/CAPTURE/capture.c ****  *
  45:../Dave/Generated/CAPTURE/capture.c ****  */
  46:../Dave/Generated/CAPTURE/capture.c **** 
  47:../Dave/Generated/CAPTURE/capture.c **** /**************************************************************************************************
  48:../Dave/Generated/CAPTURE/capture.c ****  * HEADER FILES
  49:../Dave/Generated/CAPTURE/capture.c ****  **************************************************************************************************
  50:../Dave/Generated/CAPTURE/capture.c **** #include "capture.h"
  51:../Dave/Generated/CAPTURE/capture.c **** 
  52:../Dave/Generated/CAPTURE/capture.c **** /**************************************************************************************************
  53:../Dave/Generated/CAPTURE/capture.c ****  * MACROS
  54:../Dave/Generated/CAPTURE/capture.c ****  **************************************************************************************************
  55:../Dave/Generated/CAPTURE/capture.c **** #define CAPTURE_PERIOD_16BIT_MAX         (0xFFFFU)  /* Maximum period value */
  56:../Dave/Generated/CAPTURE/capture.c **** 
  57:../Dave/Generated/CAPTURE/capture.c **** /**************************************************************************************************
  58:../Dave/Generated/CAPTURE/capture.c ****  * LOCAL DATA
  59:../Dave/Generated/CAPTURE/capture.c ****  **************************************************************************************************
  60:../Dave/Generated/CAPTURE/capture.c **** 
  61:../Dave/Generated/CAPTURE/capture.c **** /**************************************************************************************************
  62:../Dave/Generated/CAPTURE/capture.c ****  * LOCAL ROUTINES
  63:../Dave/Generated/CAPTURE/capture.c ****  **************************************************************************************************
  64:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
  65:../Dave/Generated/CAPTURE/capture.c **** static void CAPTURE_CCU4_lInit(const CAPTURE_t *const handler);
  66:../Dave/Generated/CAPTURE/capture.c **** static void CAPTURE_CCU4_lShadowTransfer(const CAPTURE_t *const handler);
  67:../Dave/Generated/CAPTURE/capture.c **** /* @brief Retrieves the latest captured timer value */
  68:../Dave/Generated/CAPTURE/capture.c **** static CAPTURE_STATUS_t CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(const XMC_CCU4_SLICE_t *co
  69:../Dave/Generated/CAPTURE/capture.c ****                                                                          const XMC_CCU4_SLICE_CAP_R
  70:../Dave/Generated/CAPTURE/capture.c ****                                                                          uint32_t *const val_ptr);
  71:../Dave/Generated/CAPTURE/capture.c **** #endif
  72:../Dave/Generated/CAPTURE/capture.c **** 
  73:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
  74:../Dave/Generated/CAPTURE/capture.c **** static void CAPTURE_CCU8_lInit(const CAPTURE_t *const handler);
  75:../Dave/Generated/CAPTURE/capture.c **** static void CAPTURE_CCU8_lShadowTransfer(const CAPTURE_t *const handler);
  76:../Dave/Generated/CAPTURE/capture.c **** /* @brief Retrieves the latest captured timer value */
  77:../Dave/Generated/CAPTURE/capture.c **** static CAPTURE_STATUS_t CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(const XMC_CCU8_SLICE_t *co
  78:../Dave/Generated/CAPTURE/capture.c ****                                                                          const XMC_CCU8_SLICE_CAP_R
  79:../Dave/Generated/CAPTURE/capture.c ****                                                                          uint32_t *const val_ptr);
  80:../Dave/Generated/CAPTURE/capture.c **** #endif
  81:../Dave/Generated/CAPTURE/capture.c **** 
  82:../Dave/Generated/CAPTURE/capture.c **** static void CAPTURE_lCalculateTimeTickFromTimerValue(const CAPTURE_t * const handler,
  83:../Dave/Generated/CAPTURE/capture.c ****                                                      uint32_t * const timer_val_ptr,
  84:../Dave/Generated/CAPTURE/capture.c ****                                                      bool is_increment);
  85:../Dave/Generated/CAPTURE/capture.c **** 
  86:../Dave/Generated/CAPTURE/capture.c **** static uint32_t CAPTURE_lCalculateTimeInNanoSecFromTimerTick(const CAPTURE_t * const handler,
  87:../Dave/Generated/CAPTURE/capture.c ****                                                              uint32_t timer_val);
  88:../Dave/Generated/CAPTURE/capture.c **** 
  89:../Dave/Generated/CAPTURE/capture.c ****  /*************************************************************************************************
  90:../Dave/Generated/CAPTURE/capture.c ****  * API IMPLEMENTATION
  91:../Dave/Generated/CAPTURE/capture.c ****  **************************************************************************************************
  92:../Dave/Generated/CAPTURE/capture.c ****  /* Returns the version of the capture APP. */
  93:../Dave/Generated/CAPTURE/capture.c **** DAVE_APP_VERSION_t CAPTURE_GetAppVersion(void)
  94:../Dave/Generated/CAPTURE/capture.c **** {
 388              	 .loc 2 94 0
 389              	 .cfi_startproc
 390              	 
 391              	 
 392              	 
 393 0000 80B4     	 push {r7}
 394              	.LCFI48:
 395              	 .cfi_def_cfa_offset 4
 396              	 .cfi_offset 7,-4
 397 0002 83B0     	 sub sp,sp,#12
 398              	.LCFI49:
 399              	 .cfi_def_cfa_offset 16
 400 0004 00AF     	 add r7,sp,#0
 401              	.LCFI50:
 402              	 .cfi_def_cfa_register 7
  95:../Dave/Generated/CAPTURE/capture.c ****   DAVE_APP_VERSION_t version;
  96:../Dave/Generated/CAPTURE/capture.c **** 
  97:../Dave/Generated/CAPTURE/capture.c ****   version.major = CAPTURE_MAJOR_VERSION;
 403              	 .loc 2 97 0
 404 0006 0423     	 movs r3,#4
 405 0008 3B70     	 strb r3,[r7]
  98:../Dave/Generated/CAPTURE/capture.c ****   version.minor = CAPTURE_MINOR_VERSION;
 406              	 .loc 2 98 0
 407 000a 0023     	 movs r3,#0
 408 000c 7B70     	 strb r3,[r7,#1]
  99:../Dave/Generated/CAPTURE/capture.c ****   version.patch = CAPTURE_PATCH_VERSION;
 409              	 .loc 2 99 0
 410 000e 0423     	 movs r3,#4
 411 0010 BB70     	 strb r3,[r7,#2]
 100:../Dave/Generated/CAPTURE/capture.c **** 
 101:../Dave/Generated/CAPTURE/capture.c ****   return version;
 412              	 .loc 2 101 0
 413 0012 3B1D     	 adds r3,r7,#4
 414 0014 3A46     	 mov r2,r7
 415 0016 1268     	 ldr r2,[r2]
 416 0018 1146     	 mov r1,r2
 417 001a 1980     	 strh r1,[r3]
 418 001c 0233     	 adds r3,r3,#2
 419 001e 120C     	 lsrs r2,r2,#16
 420 0020 1A70     	 strb r2,[r3]
 421 0022 0023     	 movs r3,#0
 422 0024 3A79     	 ldrb r2,[r7,#4]
 423 0026 62F30703 	 bfi r3,r2,#0,#8
 424 002a 7A79     	 ldrb r2,[r7,#5]
 425 002c 62F30F23 	 bfi r3,r2,#8,#8
 426 0030 BA79     	 ldrb r2,[r7,#6]
 427 0032 62F31743 	 bfi r3,r2,#16,#8
 102:../Dave/Generated/CAPTURE/capture.c **** }
 428              	 .loc 2 102 0
 429 0036 1846     	 mov r0,r3
 430 0038 0C37     	 adds r7,r7,#12
 431              	.LCFI51:
 432              	 .cfi_def_cfa_offset 4
 433 003a BD46     	 mov sp,r7
 434              	.LCFI52:
 435              	 .cfi_def_cfa_register 13
 436              	 
 437 003c 5DF8047B 	 ldr r7,[sp],#4
 438              	.LCFI53:
 439              	 .cfi_restore 7
 440              	 .cfi_def_cfa_offset 0
 441 0040 7047     	 bx lr
 442              	 .cfi_endproc
 443              	.LFE227:
 445 0042 00BF     	 .section .text.CAPTURE_Init,"ax",%progbits
 446              	 .align 2
 447              	 .global CAPTURE_Init
 448              	 .thumb
 449              	 .thumb_func
 451              	CAPTURE_Init:
 452              	.LFB228:
 103:../Dave/Generated/CAPTURE/capture.c **** 
 104:../Dave/Generated/CAPTURE/capture.c **** /* This function initializes a capture APP based on user configuration. */
 105:../Dave/Generated/CAPTURE/capture.c **** CAPTURE_STATUS_t CAPTURE_Init(CAPTURE_t *const handler)
 106:../Dave/Generated/CAPTURE/capture.c **** {
 453              	 .loc 2 106 0
 454              	 .cfi_startproc
 455              	 
 456              	 
 457 0000 80B5     	 push {r7,lr}
 458              	.LCFI54:
 459              	 .cfi_def_cfa_offset 8
 460              	 .cfi_offset 7,-8
 461              	 .cfi_offset 14,-4
 462 0002 84B0     	 sub sp,sp,#16
 463              	.LCFI55:
 464              	 .cfi_def_cfa_offset 24
 465 0004 00AF     	 add r7,sp,#0
 466              	.LCFI56:
 467              	 .cfi_def_cfa_register 7
 468 0006 7860     	 str r0,[r7,#4]
 107:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status;
 108:../Dave/Generated/CAPTURE/capture.c **** 
 109:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_Init:handler NULL", (handler != NULL));
 110:../Dave/Generated/CAPTURE/capture.c **** 
 111:../Dave/Generated/CAPTURE/capture.c ****   status = CAPTURE_STATUS_SUCCESS;
 469              	 .loc 2 111 0
 470 0008 0023     	 movs r3,#0
 471 000a FB73     	 strb r3,[r7,#15]
 112:../Dave/Generated/CAPTURE/capture.c ****   /* Check for APP instance is initialized or not */
 113:../Dave/Generated/CAPTURE/capture.c ****   if (false == handler->initialized)
 472              	 .loc 2 113 0
 473 000c 7B68     	 ldr r3,[r7,#4]
 474 000e 93F83130 	 ldrb r3,[r3,#49]
 475 0012 83F00103 	 eor r3,r3,#1
 476 0016 DBB2     	 uxtb r3,r3
 477 0018 002B     	 cmp r3,#0
 478 001a 30D0     	 beq .L13
 114:../Dave/Generated/CAPTURE/capture.c ****   {
 115:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 116:../Dave/Generated/CAPTURE/capture.c ****     if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 479              	 .loc 2 116 0
 480 001c 7B68     	 ldr r3,[r7,#4]
 481 001e 93F82D30 	 ldrb r3,[r3,#45]
 482 0022 002B     	 cmp r3,#0
 483 0024 0CD1     	 bne .L14
 117:../Dave/Generated/CAPTURE/capture.c ****     {
 118:../Dave/Generated/CAPTURE/capture.c ****       status = (CAPTURE_STATUS_t) GLOBAL_CCU4_Init (handler->global_ccu4_handler);
 484              	 .loc 2 118 0
 485 0026 7B68     	 ldr r3,[r7,#4]
 486 0028 5B69     	 ldr r3,[r3,#20]
 487 002a 1846     	 mov r0,r3
 488 002c FFF7FEFF 	 bl GLOBAL_CCU4_Init
 489 0030 0346     	 mov r3,r0
 490 0032 FB73     	 strb r3,[r7,#15]
 119:../Dave/Generated/CAPTURE/capture.c ****       if (status == CAPTURE_STATUS_SUCCESS)
 491              	 .loc 2 119 0
 492 0034 FB7B     	 ldrb r3,[r7,#15]
 493 0036 002B     	 cmp r3,#0
 494 0038 02D1     	 bne .L14
 120:../Dave/Generated/CAPTURE/capture.c ****       {
 121:../Dave/Generated/CAPTURE/capture.c ****         /* Configure CCU4 capture for the required time tick settings */
 122:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_CCU4_lInit (handler);
 495              	 .loc 2 122 0
 496 003a 7868     	 ldr r0,[r7,#4]
 497 003c FFF7FEFF 	 bl CAPTURE_CCU4_lInit
 498              	.L14:
 123:../Dave/Generated/CAPTURE/capture.c ****       }
 124:../Dave/Generated/CAPTURE/capture.c ****     }
 125:../Dave/Generated/CAPTURE/capture.c **** #endif
 126:../Dave/Generated/CAPTURE/capture.c **** 
 127:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
 128:../Dave/Generated/CAPTURE/capture.c ****     if (CAPTURE_MODULE_CCU8 == handler->capture_module)
 129:../Dave/Generated/CAPTURE/capture.c ****     {
 130:../Dave/Generated/CAPTURE/capture.c ****       status = (CAPTURE_STATUS_t) GLOBAL_CCU8_Init (handler->global_ccu8_handler);
 131:../Dave/Generated/CAPTURE/capture.c ****       if (status == CAPTURE_STATUS_SUCCESS)
 132:../Dave/Generated/CAPTURE/capture.c ****       {
 133:../Dave/Generated/CAPTURE/capture.c ****         /* Configure CCU8 capture for the required time tick settings */
 134:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_CCU8_lInit (handler);
 135:../Dave/Generated/CAPTURE/capture.c ****       }
 136:../Dave/Generated/CAPTURE/capture.c ****     }
 137:../Dave/Generated/CAPTURE/capture.c **** #endif
 138:../Dave/Generated/CAPTURE/capture.c **** 
 139:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_GPIO_USED
 140:../Dave/Generated/CAPTURE/capture.c ****     if (handler->input != NULL)
 499              	 .loc 2 140 0
 500 0040 7B68     	 ldr r3,[r7,#4]
 501 0042 5B6A     	 ldr r3,[r3,#36]
 502 0044 002B     	 cmp r3,#0
 503 0046 0CD0     	 beq .L15
 141:../Dave/Generated/CAPTURE/capture.c ****     {
 142:../Dave/Generated/CAPTURE/capture.c ****       XMC_GPIO_Init (handler->input->port, handler->input->pin, handler->input_pin_config);
 504              	 .loc 2 142 0
 505 0048 7B68     	 ldr r3,[r7,#4]
 506 004a 5B6A     	 ldr r3,[r3,#36]
 507 004c 1968     	 ldr r1,[r3]
 508 004e 7B68     	 ldr r3,[r7,#4]
 509 0050 5B6A     	 ldr r3,[r3,#36]
 510 0052 1A79     	 ldrb r2,[r3,#4]
 511 0054 7B68     	 ldr r3,[r7,#4]
 512 0056 9B6A     	 ldr r3,[r3,#40]
 513 0058 0846     	 mov r0,r1
 514 005a 1146     	 mov r1,r2
 515 005c 1A46     	 mov r2,r3
 516 005e FFF7FEFF 	 bl XMC_GPIO_Init
 517              	.L15:
 143:../Dave/Generated/CAPTURE/capture.c ****     }
 144:../Dave/Generated/CAPTURE/capture.c **** #endif
 145:../Dave/Generated/CAPTURE/capture.c **** 
 146:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_INTERRUPT_ENABLED
 147:../Dave/Generated/CAPTURE/capture.c ****     if (handler->capture_event_enable == true)
 148:../Dave/Generated/CAPTURE/capture.c ****     {
 149:../Dave/Generated/CAPTURE/capture.c ****       /* Set priority of the Transmit interrupt */
 150:../Dave/Generated/CAPTURE/capture.c **** #if UC_FAMILY == XMC4
 151:../Dave/Generated/CAPTURE/capture.c ****       NVIC_SetPriority (handler->interrupt_node, NVIC_EncodePriority (NVIC_GetPriorityGrouping (),
 152:../Dave/Generated/CAPTURE/capture.c ****                                                                       handler->interrupt_priority,
 153:../Dave/Generated/CAPTURE/capture.c ****                                                                       handler->interrupt_sub_priori
 154:../Dave/Generated/CAPTURE/capture.c **** #else
 155:../Dave/Generated/CAPTURE/capture.c ****       NVIC_SetPriority(handler->interrupt_node, handler->interrupt_priority);
 156:../Dave/Generated/CAPTURE/capture.c **** #endif
 157:../Dave/Generated/CAPTURE/capture.c **** 
 158:../Dave/Generated/CAPTURE/capture.c **** #if UC_SERIES == XMC14
 159:../Dave/Generated/CAPTURE/capture.c ****       XMC_SCU_SetInterruptControl(handler->interrupt_node, handler->interrupt_request_source);
 160:../Dave/Generated/CAPTURE/capture.c **** #endif
 161:../Dave/Generated/CAPTURE/capture.c **** 
 162:../Dave/Generated/CAPTURE/capture.c ****     }
 163:../Dave/Generated/CAPTURE/capture.c **** #endif
 164:../Dave/Generated/CAPTURE/capture.c **** 
 165:../Dave/Generated/CAPTURE/capture.c ****     /* update the initialization flag as true for particular instance. */
 166:../Dave/Generated/CAPTURE/capture.c ****     handler->initialized = true;
 518              	 .loc 2 166 0
 519 0062 7B68     	 ldr r3,[r7,#4]
 520 0064 0122     	 movs r2,#1
 521 0066 83F83120 	 strb r2,[r3,#49]
 167:../Dave/Generated/CAPTURE/capture.c **** 
 168:../Dave/Generated/CAPTURE/capture.c ****     /* Check whether the start of the timer is enabled during initialization or not */
 169:../Dave/Generated/CAPTURE/capture.c ****     if (handler->start_control == true)
 522              	 .loc 2 169 0
 523 006a 7B68     	 ldr r3,[r7,#4]
 524 006c 93F82F30 	 ldrb r3,[r3,#47]
 525 0070 002B     	 cmp r3,#0
 526 0072 04D0     	 beq .L13
 170:../Dave/Generated/CAPTURE/capture.c ****     {
 171:../Dave/Generated/CAPTURE/capture.c ****       status = CAPTURE_Start(handler);
 527              	 .loc 2 171 0
 528 0074 7868     	 ldr r0,[r7,#4]
 529 0076 FFF7FEFF 	 bl CAPTURE_Start
 530 007a 0346     	 mov r3,r0
 531 007c FB73     	 strb r3,[r7,#15]
 532              	.L13:
 172:../Dave/Generated/CAPTURE/capture.c ****     }
 173:../Dave/Generated/CAPTURE/capture.c ****   }
 174:../Dave/Generated/CAPTURE/capture.c **** 
 175:../Dave/Generated/CAPTURE/capture.c ****   return (status);
 533              	 .loc 2 175 0
 534 007e FB7B     	 ldrb r3,[r7,#15]
 176:../Dave/Generated/CAPTURE/capture.c **** }
 535              	 .loc 2 176 0
 536 0080 1846     	 mov r0,r3
 537 0082 1037     	 adds r7,r7,#16
 538              	.LCFI57:
 539              	 .cfi_def_cfa_offset 8
 540 0084 BD46     	 mov sp,r7
 541              	.LCFI58:
 542              	 .cfi_def_cfa_register 13
 543              	 
 544 0086 80BD     	 pop {r7,pc}
 545              	 .cfi_endproc
 546              	.LFE228:
 548              	 .section .text.CAPTURE_Start,"ax",%progbits
 549              	 .align 2
 550              	 .global CAPTURE_Start
 551              	 .thumb
 552              	 .thumb_func
 554              	CAPTURE_Start:
 555              	.LFB229:
 177:../Dave/Generated/CAPTURE/capture.c **** 
 178:../Dave/Generated/CAPTURE/capture.c **** /* This function starts the capture timer. */
 179:../Dave/Generated/CAPTURE/capture.c **** CAPTURE_STATUS_t CAPTURE_Start(const CAPTURE_t *const handler)
 180:../Dave/Generated/CAPTURE/capture.c **** {
 556              	 .loc 2 180 0
 557              	 .cfi_startproc
 558              	 
 559              	 
 560 0000 80B5     	 push {r7,lr}
 561              	.LCFI59:
 562              	 .cfi_def_cfa_offset 8
 563              	 .cfi_offset 7,-8
 564              	 .cfi_offset 14,-4
 565 0002 84B0     	 sub sp,sp,#16
 566              	.LCFI60:
 567              	 .cfi_def_cfa_offset 24
 568 0004 00AF     	 add r7,sp,#0
 569              	.LCFI61:
 570              	 .cfi_def_cfa_register 7
 571 0006 7860     	 str r0,[r7,#4]
 181:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status;
 182:../Dave/Generated/CAPTURE/capture.c **** 
 183:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_Start:handler NULL", (handler != NULL));
 184:../Dave/Generated/CAPTURE/capture.c **** 
 185:../Dave/Generated/CAPTURE/capture.c ****   /* Check for APP instance is initialized or not */
 186:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->initialized)
 572              	 .loc 2 186 0
 573 0008 7B68     	 ldr r3,[r7,#4]
 574 000a 93F83130 	 ldrb r3,[r3,#49]
 575 000e 002B     	 cmp r3,#0
 576 0010 1ED0     	 beq .L18
 187:../Dave/Generated/CAPTURE/capture.c ****   {
 188:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 189:../Dave/Generated/CAPTURE/capture.c ****     if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 577              	 .loc 2 189 0
 578 0012 7B68     	 ldr r3,[r7,#4]
 579 0014 93F82D30 	 ldrb r3,[r3,#45]
 580 0018 002B     	 cmp r3,#0
 581 001a 16D1     	 bne .L19
 190:../Dave/Generated/CAPTURE/capture.c ****     {
 191:../Dave/Generated/CAPTURE/capture.c ****       (void)handler->ccu4_slice_ptr->CV[0];
 582              	 .loc 2 191 0
 583 001c 7B68     	 ldr r3,[r7,#4]
 584 001e 9B69     	 ldr r3,[r3,#24]
 585 0020 5B6F     	 ldr r3,[r3,#116]
 192:../Dave/Generated/CAPTURE/capture.c ****       (void)handler->ccu4_slice_ptr->CV[1];
 586              	 .loc 2 192 0
 587 0022 7B68     	 ldr r3,[r7,#4]
 588 0024 9B69     	 ldr r3,[r3,#24]
 589 0026 9B6F     	 ldr r3,[r3,#120]
 193:../Dave/Generated/CAPTURE/capture.c ****       (void)handler->ccu4_slice_ptr->CV[2];
 590              	 .loc 2 193 0
 591 0028 7B68     	 ldr r3,[r7,#4]
 592 002a 9B69     	 ldr r3,[r3,#24]
 593 002c DB6F     	 ldr r3,[r3,#124]
 194:../Dave/Generated/CAPTURE/capture.c ****       (void)handler->ccu4_slice_ptr->CV[3];
 594              	 .loc 2 194 0
 595 002e 7B68     	 ldr r3,[r7,#4]
 596 0030 9B69     	 ldr r3,[r3,#24]
 597 0032 D3F88030 	 ldr r3,[r3,#128]
 195:../Dave/Generated/CAPTURE/capture.c **** 
 196:../Dave/Generated/CAPTURE/capture.c ****       /* Start the capture manually */
 197:../Dave/Generated/CAPTURE/capture.c ****       XMC_CCU4_SLICE_ClearTimer (handler->ccu4_slice_ptr);
 598              	 .loc 2 197 0
 599 0036 7B68     	 ldr r3,[r7,#4]
 600 0038 9B69     	 ldr r3,[r3,#24]
 601 003a 1846     	 mov r0,r3
 602 003c FFF7FEFF 	 bl XMC_CCU4_SLICE_ClearTimer
 198:../Dave/Generated/CAPTURE/capture.c ****       /* Start the capture manually */
 199:../Dave/Generated/CAPTURE/capture.c ****       XMC_CCU4_SLICE_StartTimer (handler->ccu4_slice_ptr);
 603              	 .loc 2 199 0
 604 0040 7B68     	 ldr r3,[r7,#4]
 605 0042 9B69     	 ldr r3,[r3,#24]
 606 0044 1846     	 mov r0,r3
 607 0046 FFF7FEFF 	 bl XMC_CCU4_SLICE_StartTimer
 608              	.L19:
 200:../Dave/Generated/CAPTURE/capture.c ****     }
 201:../Dave/Generated/CAPTURE/capture.c **** #endif
 202:../Dave/Generated/CAPTURE/capture.c **** 
 203:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
 204:../Dave/Generated/CAPTURE/capture.c ****     if (CAPTURE_MODULE_CCU8 == handler->capture_module)
 205:../Dave/Generated/CAPTURE/capture.c ****     {
 206:../Dave/Generated/CAPTURE/capture.c ****       (void)handler->ccu8_slice_ptr->CV[0];
 207:../Dave/Generated/CAPTURE/capture.c ****       (void)handler->ccu8_slice_ptr->CV[1];
 208:../Dave/Generated/CAPTURE/capture.c ****       (void)handler->ccu8_slice_ptr->CV[2];
 209:../Dave/Generated/CAPTURE/capture.c ****       (void)handler->ccu8_slice_ptr->CV[3];
 210:../Dave/Generated/CAPTURE/capture.c ****       /* Start the capture manually */
 211:../Dave/Generated/CAPTURE/capture.c ****       XMC_CCU8_SLICE_ClearTimer (handler->ccu8_slice_ptr);
 212:../Dave/Generated/CAPTURE/capture.c ****       /* Start the capture manually */
 213:../Dave/Generated/CAPTURE/capture.c ****       XMC_CCU8_SLICE_StartTimer (handler->ccu8_slice_ptr);
 214:../Dave/Generated/CAPTURE/capture.c ****     }
 215:../Dave/Generated/CAPTURE/capture.c **** #endif
 216:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_STATUS_SUCCESS;
 609              	 .loc 2 216 0
 610 004a 0023     	 movs r3,#0
 611 004c FB73     	 strb r3,[r7,#15]
 612 004e 01E0     	 b .L20
 613              	.L18:
 217:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_INTERRUPT_ENABLED
 218:../Dave/Generated/CAPTURE/capture.c ****     if (handler->capture_event_enable == true)
 219:../Dave/Generated/CAPTURE/capture.c ****     {
 220:../Dave/Generated/CAPTURE/capture.c ****       NVIC_EnableIRQ (handler->interrupt_node);
 221:../Dave/Generated/CAPTURE/capture.c ****     }
 222:../Dave/Generated/CAPTURE/capture.c **** #endif
 223:../Dave/Generated/CAPTURE/capture.c ****   }
 224:../Dave/Generated/CAPTURE/capture.c ****   else
 225:../Dave/Generated/CAPTURE/capture.c ****   {
 226:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_STATUS_FAILURE;
 614              	 .loc 2 226 0
 615 0050 0123     	 movs r3,#1
 616 0052 FB73     	 strb r3,[r7,#15]
 617              	.L20:
 227:../Dave/Generated/CAPTURE/capture.c ****   }
 228:../Dave/Generated/CAPTURE/capture.c **** 
 229:../Dave/Generated/CAPTURE/capture.c ****   return (status);
 618              	 .loc 2 229 0
 619 0054 FB7B     	 ldrb r3,[r7,#15]
 230:../Dave/Generated/CAPTURE/capture.c **** }
 620              	 .loc 2 230 0
 621 0056 1846     	 mov r0,r3
 622 0058 1037     	 adds r7,r7,#16
 623              	.LCFI62:
 624              	 .cfi_def_cfa_offset 8
 625 005a BD46     	 mov sp,r7
 626              	.LCFI63:
 627              	 .cfi_def_cfa_register 13
 628              	 
 629 005c 80BD     	 pop {r7,pc}
 630              	 .cfi_endproc
 631              	.LFE229:
 633 005e 00BF     	 .section .text.CAPTURE_Stop,"ax",%progbits
 634              	 .align 2
 635              	 .global CAPTURE_Stop
 636              	 .thumb
 637              	 .thumb_func
 639              	CAPTURE_Stop:
 640              	.LFB230:
 231:../Dave/Generated/CAPTURE/capture.c **** 
 232:../Dave/Generated/CAPTURE/capture.c **** /* This function stops the capture timer. */
 233:../Dave/Generated/CAPTURE/capture.c **** CAPTURE_STATUS_t CAPTURE_Stop(const CAPTURE_t *const handler)
 234:../Dave/Generated/CAPTURE/capture.c **** {
 641              	 .loc 2 234 0
 642              	 .cfi_startproc
 643              	 
 644              	 
 645 0000 80B5     	 push {r7,lr}
 646              	.LCFI64:
 647              	 .cfi_def_cfa_offset 8
 648              	 .cfi_offset 7,-8
 649              	 .cfi_offset 14,-4
 650 0002 84B0     	 sub sp,sp,#16
 651              	.LCFI65:
 652              	 .cfi_def_cfa_offset 24
 653 0004 00AF     	 add r7,sp,#0
 654              	.LCFI66:
 655              	 .cfi_def_cfa_register 7
 656 0006 7860     	 str r0,[r7,#4]
 235:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status;
 236:../Dave/Generated/CAPTURE/capture.c **** 
 237:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_Stop:handler NULL", (handler != NULL));
 238:../Dave/Generated/CAPTURE/capture.c **** 
 239:../Dave/Generated/CAPTURE/capture.c ****   /* Check for APP instance is initialized or not */
 240:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->initialized)
 657              	 .loc 2 240 0
 658 0008 7B68     	 ldr r3,[r7,#4]
 659 000a 93F83130 	 ldrb r3,[r3,#49]
 660 000e 002B     	 cmp r3,#0
 661 0010 0CD0     	 beq .L23
 241:../Dave/Generated/CAPTURE/capture.c ****   {
 242:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 243:../Dave/Generated/CAPTURE/capture.c ****     if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 662              	 .loc 2 243 0
 663 0012 7B68     	 ldr r3,[r7,#4]
 664 0014 93F82D30 	 ldrb r3,[r3,#45]
 665 0018 002B     	 cmp r3,#0
 666 001a 04D1     	 bne .L24
 244:../Dave/Generated/CAPTURE/capture.c ****     {
 245:../Dave/Generated/CAPTURE/capture.c ****       XMC_CCU4_SLICE_StopTimer (handler->ccu4_slice_ptr);
 667              	 .loc 2 245 0
 668 001c 7B68     	 ldr r3,[r7,#4]
 669 001e 9B69     	 ldr r3,[r3,#24]
 670 0020 1846     	 mov r0,r3
 671 0022 FFF7FEFF 	 bl XMC_CCU4_SLICE_StopTimer
 672              	.L24:
 246:../Dave/Generated/CAPTURE/capture.c ****     }
 247:../Dave/Generated/CAPTURE/capture.c **** #endif
 248:../Dave/Generated/CAPTURE/capture.c **** 
 249:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
 250:../Dave/Generated/CAPTURE/capture.c ****     if (CAPTURE_MODULE_CCU8 == handler->capture_module)
 251:../Dave/Generated/CAPTURE/capture.c ****     {
 252:../Dave/Generated/CAPTURE/capture.c ****       XMC_CCU8_SLICE_StopTimer (handler->ccu8_slice_ptr);
 253:../Dave/Generated/CAPTURE/capture.c ****     }
 254:../Dave/Generated/CAPTURE/capture.c **** #endif
 255:../Dave/Generated/CAPTURE/capture.c **** 
 256:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_INTERRUPT_ENABLED
 257:../Dave/Generated/CAPTURE/capture.c ****     if (handler->capture_event_enable == true)
 258:../Dave/Generated/CAPTURE/capture.c ****     {
 259:../Dave/Generated/CAPTURE/capture.c ****       NVIC_DisableIRQ (handler->interrupt_node);
 260:../Dave/Generated/CAPTURE/capture.c ****     }
 261:../Dave/Generated/CAPTURE/capture.c **** #endif
 262:../Dave/Generated/CAPTURE/capture.c **** 
 263:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_STATUS_SUCCESS;
 673              	 .loc 2 263 0
 674 0026 0023     	 movs r3,#0
 675 0028 FB73     	 strb r3,[r7,#15]
 676 002a 01E0     	 b .L25
 677              	.L23:
 264:../Dave/Generated/CAPTURE/capture.c ****   }
 265:../Dave/Generated/CAPTURE/capture.c ****   else
 266:../Dave/Generated/CAPTURE/capture.c ****   {
 267:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_STATUS_FAILURE;
 678              	 .loc 2 267 0
 679 002c 0123     	 movs r3,#1
 680 002e FB73     	 strb r3,[r7,#15]
 681              	.L25:
 268:../Dave/Generated/CAPTURE/capture.c ****   }
 269:../Dave/Generated/CAPTURE/capture.c **** 
 270:../Dave/Generated/CAPTURE/capture.c ****   return (status);
 682              	 .loc 2 270 0
 683 0030 FB7B     	 ldrb r3,[r7,#15]
 271:../Dave/Generated/CAPTURE/capture.c **** }
 684              	 .loc 2 271 0
 685 0032 1846     	 mov r0,r3
 686 0034 1037     	 adds r7,r7,#16
 687              	.LCFI67:
 688              	 .cfi_def_cfa_offset 8
 689 0036 BD46     	 mov sp,r7
 690              	.LCFI68:
 691              	 .cfi_def_cfa_register 13
 692              	 
 693 0038 80BD     	 pop {r7,pc}
 694              	 .cfi_endproc
 695              	.LFE230:
 697 003a 00BF     	 .section .text.CAPTURE_GetTimerStatus,"ax",%progbits
 698              	 .align 2
 699              	 .global CAPTURE_GetTimerStatus
 700              	 .thumb
 701              	 .thumb_func
 703              	CAPTURE_GetTimerStatus:
 704              	.LFB231:
 272:../Dave/Generated/CAPTURE/capture.c **** 
 273:../Dave/Generated/CAPTURE/capture.c **** CAPTURE_TIMER_STATUS_t CAPTURE_GetTimerStatus(const CAPTURE_t *const handler)
 274:../Dave/Generated/CAPTURE/capture.c **** {
 705              	 .loc 2 274 0
 706              	 .cfi_startproc
 707              	 
 708              	 
 709 0000 80B5     	 push {r7,lr}
 710              	.LCFI69:
 711              	 .cfi_def_cfa_offset 8
 712              	 .cfi_offset 7,-8
 713              	 .cfi_offset 14,-4
 714 0002 84B0     	 sub sp,sp,#16
 715              	.LCFI70:
 716              	 .cfi_def_cfa_offset 24
 717 0004 00AF     	 add r7,sp,#0
 718              	.LCFI71:
 719              	 .cfi_def_cfa_register 7
 720 0006 7860     	 str r0,[r7,#4]
 275:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_TIMER_STATUS_t status = CAPTURE_TIMER_STATUS_IDLE;
 721              	 .loc 2 275 0
 722 0008 0123     	 movs r3,#1
 723 000a FB73     	 strb r3,[r7,#15]
 276:../Dave/Generated/CAPTURE/capture.c **** 
 277:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetTimerStatus:handler NULL", (handler != NULL));
 278:../Dave/Generated/CAPTURE/capture.c **** 
 279:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->initialized)
 724              	 .loc 2 279 0
 725 000c 7B68     	 ldr r3,[r7,#4]
 726 000e 93F83130 	 ldrb r3,[r3,#49]
 727 0012 002B     	 cmp r3,#0
 728 0014 0FD0     	 beq .L28
 280:../Dave/Generated/CAPTURE/capture.c ****   {
 281:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 282:../Dave/Generated/CAPTURE/capture.c ****     if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 729              	 .loc 2 282 0
 730 0016 7B68     	 ldr r3,[r7,#4]
 731 0018 93F82D30 	 ldrb r3,[r3,#45]
 732 001c 002B     	 cmp r3,#0
 733 001e 0CD1     	 bne .L30
 283:../Dave/Generated/CAPTURE/capture.c ****     {
 284:../Dave/Generated/CAPTURE/capture.c ****       if (XMC_CCU4_SLICE_IsTimerRunning (handler->ccu4_slice_ptr))
 734              	 .loc 2 284 0
 735 0020 7B68     	 ldr r3,[r7,#4]
 736 0022 9B69     	 ldr r3,[r3,#24]
 737 0024 1846     	 mov r0,r3
 738 0026 FFF7FEFF 	 bl XMC_CCU4_SLICE_IsTimerRunning
 739 002a 0346     	 mov r3,r0
 740 002c 002B     	 cmp r3,#0
 741 002e 04D0     	 beq .L30
 285:../Dave/Generated/CAPTURE/capture.c ****       {
 286:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_TIMER_STATUS_RUNNING;
 742              	 .loc 2 286 0
 743 0030 0223     	 movs r3,#2
 744 0032 FB73     	 strb r3,[r7,#15]
 745 0034 01E0     	 b .L30
 746              	.L28:
 287:../Dave/Generated/CAPTURE/capture.c ****       }
 288:../Dave/Generated/CAPTURE/capture.c ****     }
 289:../Dave/Generated/CAPTURE/capture.c **** #endif
 290:../Dave/Generated/CAPTURE/capture.c **** 
 291:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
 292:../Dave/Generated/CAPTURE/capture.c ****     if (CAPTURE_MODULE_CCU8 == handler->capture_module)
 293:../Dave/Generated/CAPTURE/capture.c ****     {
 294:../Dave/Generated/CAPTURE/capture.c ****       if (XMC_CCU8_SLICE_IsTimerRunning (handler->ccu8_slice_ptr))
 295:../Dave/Generated/CAPTURE/capture.c ****       {
 296:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_TIMER_STATUS_RUNNING;
 297:../Dave/Generated/CAPTURE/capture.c ****       }
 298:../Dave/Generated/CAPTURE/capture.c ****     }
 299:../Dave/Generated/CAPTURE/capture.c **** #endif
 300:../Dave/Generated/CAPTURE/capture.c ****   }
 301:../Dave/Generated/CAPTURE/capture.c ****   else
 302:../Dave/Generated/CAPTURE/capture.c ****   {
 303:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_TIMER_STATUS_NOT_INITIALISED;
 747              	 .loc 2 303 0
 748 0036 0023     	 movs r3,#0
 749 0038 FB73     	 strb r3,[r7,#15]
 750              	.L30:
 304:../Dave/Generated/CAPTURE/capture.c ****   }
 305:../Dave/Generated/CAPTURE/capture.c **** 
 306:../Dave/Generated/CAPTURE/capture.c ****   return (status);
 751              	 .loc 2 306 0
 752 003a FB7B     	 ldrb r3,[r7,#15]
 307:../Dave/Generated/CAPTURE/capture.c **** }
 753              	 .loc 2 307 0
 754 003c 1846     	 mov r0,r3
 755 003e 1037     	 adds r7,r7,#16
 756              	.LCFI72:
 757              	 .cfi_def_cfa_offset 8
 758 0040 BD46     	 mov sp,r7
 759              	.LCFI73:
 760              	 .cfi_def_cfa_register 13
 761              	 
 762 0042 80BD     	 pop {r7,pc}
 763              	 .cfi_endproc
 764              	.LFE231:
 766              	 .section .text.CAPTURE_GetCapturedTime,"ax",%progbits
 767              	 .align 2
 768              	 .global CAPTURE_GetCapturedTime
 769              	 .thumb
 770              	 .thumb_func
 772              	CAPTURE_GetCapturedTime:
 773              	.LFB232:
 308:../Dave/Generated/CAPTURE/capture.c **** 
 309:../Dave/Generated/CAPTURE/capture.c **** CAPTURE_STATUS_t CAPTURE_GetCapturedTime(const CAPTURE_t *const handler, uint32_t *const captured_t
 310:../Dave/Generated/CAPTURE/capture.c **** {
 774              	 .loc 2 310 0
 775              	 .cfi_startproc
 776              	 
 777              	 
 778 0000 80B5     	 push {r7,lr}
 779              	.LCFI74:
 780              	 .cfi_def_cfa_offset 8
 781              	 .cfi_offset 7,-8
 782              	 .cfi_offset 14,-4
 783 0002 86B0     	 sub sp,sp,#24
 784              	.LCFI75:
 785              	 .cfi_def_cfa_offset 32
 786 0004 00AF     	 add r7,sp,#0
 787              	.LCFI76:
 788              	 .cfi_def_cfa_register 7
 789 0006 7860     	 str r0,[r7,#4]
 790 0008 3960     	 str r1,[r7]
 311:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status = CAPTURE_STATUS_SUCCESS;
 791              	 .loc 2 311 0
 792 000a 0023     	 movs r3,#0
 793 000c FB75     	 strb r3,[r7,#23]
 312:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status1 = CAPTURE_STATUS_SUCCESS;
 794              	 .loc 2 312 0
 795 000e 0023     	 movs r3,#0
 796 0010 BB75     	 strb r3,[r7,#22]
 313:../Dave/Generated/CAPTURE/capture.c **** 
 314:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetCapturedTime:handler NULL", (handler != NULL));
 315:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetCapturedTime:NULL data pointer", (captured_time != NULL));
 316:../Dave/Generated/CAPTURE/capture.c **** 
 317:../Dave/Generated/CAPTURE/capture.c ****   /* Check for APP instance is initialized or not */
 318:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->initialized)
 797              	 .loc 2 318 0
 798 0012 7B68     	 ldr r3,[r7,#4]
 799 0014 93F83130 	 ldrb r3,[r3,#49]
 800 0018 002B     	 cmp r3,#0
 801 001a 52D0     	 beq .L33
 319:../Dave/Generated/CAPTURE/capture.c ****   {
 320:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 321:../Dave/Generated/CAPTURE/capture.c ****     if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 802              	 .loc 2 321 0
 803 001c 7B68     	 ldr r3,[r7,#4]
 804 001e 93F82D30 	 ldrb r3,[r3,#45]
 805 0022 002B     	 cmp r3,#0
 806 0024 4FD1     	 bne .L38
 322:../Dave/Generated/CAPTURE/capture.c ****     {
 323:../Dave/Generated/CAPTURE/capture.c ****       if ((handler->capture_edge_config == CAPTURE_EDGE_RISE_TO_RISE) ||
 807              	 .loc 2 323 0
 808 0026 7B68     	 ldr r3,[r7,#4]
 809 0028 93F82E30 	 ldrb r3,[r3,#46]
 810 002c 002B     	 cmp r3,#0
 811 002e 04D0     	 beq .L35
 324:../Dave/Generated/CAPTURE/capture.c ****           (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 812              	 .loc 2 324 0 discriminator 1
 813 0030 7B68     	 ldr r3,[r7,#4]
 814 0032 93F82E30 	 ldrb r3,[r3,#46]
 323:../Dave/Generated/CAPTURE/capture.c ****           (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 815              	 .loc 2 323 0 discriminator 1
 816 0036 032B     	 cmp r3,#3
 817 0038 33D1     	 bne .L36
 818              	.L35:
 819              	.LBB10:
 325:../Dave/Generated/CAPTURE/capture.c ****       {
 326:../Dave/Generated/CAPTURE/capture.c ****         uint32_t captured_time_low_reg = 0U;
 820              	 .loc 2 326 0
 821 003a 0023     	 movs r3,#0
 822 003c 3B61     	 str r3,[r7,#16]
 327:../Dave/Generated/CAPTURE/capture.c ****         uint32_t captured_time_high_reg = 0U;
 823              	 .loc 2 327 0
 824 003e 0023     	 movs r3,#0
 825 0040 FB60     	 str r3,[r7,#12]
 328:../Dave/Generated/CAPTURE/capture.c **** 
 329:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 826              	 .loc 2 329 0
 827 0042 7B68     	 ldr r3,[r7,#4]
 828 0044 9A69     	 ldr r2,[r3,#24]
 829 0046 07F11003 	 add r3,r7,#16
 830 004a 1046     	 mov r0,r2
 831 004c 0021     	 movs r1,#0
 832 004e 1A46     	 mov r2,r3
 833 0050 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 834 0054 0346     	 mov r3,r0
 835 0056 FB75     	 strb r3,[r7,#23]
 330:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU4_SLICE_CAP_REG_SET_LOW,
 331:../Dave/Generated/CAPTURE/capture.c ****                                                                   &captured_time_low_reg);
 332:../Dave/Generated/CAPTURE/capture.c **** 
 333:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 836              	 .loc 2 333 0
 837 0058 7B68     	 ldr r3,[r7,#4]
 838 005a 9A69     	 ldr r2,[r3,#24]
 839 005c 07F10C03 	 add r3,r7,#12
 840 0060 1046     	 mov r0,r2
 841 0062 0121     	 movs r1,#1
 842 0064 1A46     	 mov r2,r3
 843 0066 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 844 006a 0346     	 mov r3,r0
 845 006c BB75     	 strb r3,[r7,#22]
 334:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU4_SLICE_CAP_REG_SET_HIGH,
 335:../Dave/Generated/CAPTURE/capture.c ****                                                                    &captured_time_high_reg);
 336:../Dave/Generated/CAPTURE/capture.c **** 
 337:../Dave/Generated/CAPTURE/capture.c ****         /*calculate time tick from capture value and pre-scale value of captured register**/
 338:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &captured_time_low_reg, true);
 846              	 .loc 2 338 0
 847 006e 07F11003 	 add r3,r7,#16
 848 0072 7868     	 ldr r0,[r7,#4]
 849 0074 1946     	 mov r1,r3
 850 0076 0122     	 movs r2,#1
 851 0078 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 339:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time tick from capture value and pre-scale value of captured register**/
 340:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &captured_time_high_reg, false);
 852              	 .loc 2 340 0
 853 007c 07F10C03 	 add r3,r7,#12
 854 0080 7868     	 ldr r0,[r7,#4]
 855 0082 1946     	 mov r1,r3
 856 0084 0022     	 movs r2,#0
 857 0086 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 341:../Dave/Generated/CAPTURE/capture.c ****         /* add both high and lower register value*/
 342:../Dave/Generated/CAPTURE/capture.c ****         *captured_time = captured_time_low_reg + captured_time_high_reg;
 858              	 .loc 2 342 0
 859 008a 3A69     	 ldr r2,[r7,#16]
 860 008c FB68     	 ldr r3,[r7,#12]
 861 008e 1A44     	 add r2,r2,r3
 862 0090 3B68     	 ldr r3,[r7]
 863 0092 1A60     	 str r2,[r3]
 343:../Dave/Generated/CAPTURE/capture.c **** 
 344:../Dave/Generated/CAPTURE/capture.c ****         if (status1 == CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED)
 864              	 .loc 2 344 0
 865 0094 BB7D     	 ldrb r3,[r7,#22]
 866 0096 022B     	 cmp r3,#2
 867 0098 02D1     	 bne .L37
 345:../Dave/Generated/CAPTURE/capture.c ****         {
 346:../Dave/Generated/CAPTURE/capture.c ****           status = CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED;
 868              	 .loc 2 346 0
 869 009a 0223     	 movs r3,#2
 870 009c FB75     	 strb r3,[r7,#23]
 871              	.LBE10:
 325:../Dave/Generated/CAPTURE/capture.c ****         uint32_t captured_time_low_reg = 0U;
 872              	 .loc 2 325 0
 873 009e 0FE0     	 b .L34
 874              	.L37:
 875 00a0 0EE0     	 b .L34
 876              	.L36:
 347:../Dave/Generated/CAPTURE/capture.c ****         }
 348:../Dave/Generated/CAPTURE/capture.c ****       }
 349:../Dave/Generated/CAPTURE/capture.c ****       else
 350:../Dave/Generated/CAPTURE/capture.c ****       {
 351:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 877              	 .loc 2 351 0
 878 00a2 7B68     	 ldr r3,[r7,#4]
 879 00a4 9B69     	 ldr r3,[r3,#24]
 880 00a6 1846     	 mov r0,r3
 881 00a8 0121     	 movs r1,#1
 882 00aa 3A68     	 ldr r2,[r7]
 883 00ac FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 884 00b0 0346     	 mov r3,r0
 885 00b2 FB75     	 strb r3,[r7,#23]
 352:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU4_SLICE_CAP_REG_SET_HIGH,
 353:../Dave/Generated/CAPTURE/capture.c ****                                                                   captured_time);
 354:../Dave/Generated/CAPTURE/capture.c **** 
 355:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time tick from capture value and pre-scale value of captured register**/
 356:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, captured_time, false);
 886              	 .loc 2 356 0
 887 00b4 7868     	 ldr r0,[r7,#4]
 888 00b6 3968     	 ldr r1,[r7]
 889 00b8 0022     	 movs r2,#0
 890 00ba FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 891 00be 02E0     	 b .L38
 892              	.L34:
 893 00c0 01E0     	 b .L38
 894              	.L33:
 357:../Dave/Generated/CAPTURE/capture.c ****       }
 358:../Dave/Generated/CAPTURE/capture.c ****     }
 359:../Dave/Generated/CAPTURE/capture.c **** #endif
 360:../Dave/Generated/CAPTURE/capture.c **** 
 361:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
 362:../Dave/Generated/CAPTURE/capture.c ****     if (CAPTURE_MODULE_CCU8 == handler->capture_module)
 363:../Dave/Generated/CAPTURE/capture.c ****     {
 364:../Dave/Generated/CAPTURE/capture.c ****       if ((handler->capture_edge_config == CAPTURE_EDGE_RISE_TO_RISE) ||
 365:../Dave/Generated/CAPTURE/capture.c ****           (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 366:../Dave/Generated/CAPTURE/capture.c ****       {
 367:../Dave/Generated/CAPTURE/capture.c ****         uint32_t captured_time_low_reg = 0U;
 368:../Dave/Generated/CAPTURE/capture.c ****         uint32_t captured_time_high_reg = 0U;
 369:../Dave/Generated/CAPTURE/capture.c **** 
 370:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 371:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU8_SLICE_CAP_REG_SET_LOW,
 372:../Dave/Generated/CAPTURE/capture.c ****                                                                   &captured_time_low_reg);
 373:../Dave/Generated/CAPTURE/capture.c **** 
 374:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 375:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU8_SLICE_CAP_REG_SET_HIGH,
 376:../Dave/Generated/CAPTURE/capture.c ****                                                                    &captured_time_high_reg);
 377:../Dave/Generated/CAPTURE/capture.c **** 
 378:../Dave/Generated/CAPTURE/capture.c ****         /*calculate time tick from capture value and pre-scale value of captured register**/
 379:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &captured_time_low_reg, true);
 380:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time tick from capture value and pre-scale value of captured register**/
 381:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &captured_time_high_reg, false);
 382:../Dave/Generated/CAPTURE/capture.c ****         /* add both high and lower register value*/
 383:../Dave/Generated/CAPTURE/capture.c ****         *captured_time = captured_time_low_reg + captured_time_high_reg;
 384:../Dave/Generated/CAPTURE/capture.c **** 
 385:../Dave/Generated/CAPTURE/capture.c ****         if (status1 == CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED)
 386:../Dave/Generated/CAPTURE/capture.c ****         {
 387:../Dave/Generated/CAPTURE/capture.c ****           status = CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED;
 388:../Dave/Generated/CAPTURE/capture.c ****         }
 389:../Dave/Generated/CAPTURE/capture.c ****       }
 390:../Dave/Generated/CAPTURE/capture.c ****       else
 391:../Dave/Generated/CAPTURE/capture.c ****       {
 392:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 393:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU8_SLICE_CAP_REG_SET_HIGH,
 394:../Dave/Generated/CAPTURE/capture.c ****                                                                   captured_time);
 395:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time tick from capture value and pre-scale value of captured register**/
 396:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, captured_time, false);
 397:../Dave/Generated/CAPTURE/capture.c ****       }
 398:../Dave/Generated/CAPTURE/capture.c ****     }
 399:../Dave/Generated/CAPTURE/capture.c **** #endif
 400:../Dave/Generated/CAPTURE/capture.c ****   }
 401:../Dave/Generated/CAPTURE/capture.c ****   else
 402:../Dave/Generated/CAPTURE/capture.c ****   {
 403:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_STATUS_FAILURE;
 895              	 .loc 2 403 0
 896 00c2 0123     	 movs r3,#1
 897 00c4 FB75     	 strb r3,[r7,#23]
 898              	.L38:
 404:../Dave/Generated/CAPTURE/capture.c ****   }
 405:../Dave/Generated/CAPTURE/capture.c **** 
 406:../Dave/Generated/CAPTURE/capture.c ****   return (status);
 899              	 .loc 2 406 0
 900 00c6 FB7D     	 ldrb r3,[r7,#23]
 407:../Dave/Generated/CAPTURE/capture.c **** }
 901              	 .loc 2 407 0
 902 00c8 1846     	 mov r0,r3
 903 00ca 1837     	 adds r7,r7,#24
 904              	.LCFI77:
 905              	 .cfi_def_cfa_offset 8
 906 00cc BD46     	 mov sp,r7
 907              	.LCFI78:
 908              	 .cfi_def_cfa_register 13
 909              	 
 910 00ce 80BD     	 pop {r7,pc}
 911              	 .cfi_endproc
 912              	.LFE232:
 914              	 .section .text.CAPTURE_GetCapturedTimeInNanoSec,"ax",%progbits
 915              	 .align 2
 916              	 .global CAPTURE_GetCapturedTimeInNanoSec
 917              	 .thumb
 918              	 .thumb_func
 920              	CAPTURE_GetCapturedTimeInNanoSec:
 921              	.LFB233:
 408:../Dave/Generated/CAPTURE/capture.c **** 
 409:../Dave/Generated/CAPTURE/capture.c **** 
 410:../Dave/Generated/CAPTURE/capture.c **** CAPTURE_STATUS_t CAPTURE_GetCapturedTimeInNanoSec(const CAPTURE_t *const handler, uint32_t *const c
 411:../Dave/Generated/CAPTURE/capture.c **** {
 922              	 .loc 2 411 0
 923              	 .cfi_startproc
 924              	 
 925              	 
 926 0000 80B5     	 push {r7,lr}
 927              	.LCFI79:
 928              	 .cfi_def_cfa_offset 8
 929              	 .cfi_offset 7,-8
 930              	 .cfi_offset 14,-4
 931 0002 86B0     	 sub sp,sp,#24
 932              	.LCFI80:
 933              	 .cfi_def_cfa_offset 32
 934 0004 00AF     	 add r7,sp,#0
 935              	.LCFI81:
 936              	 .cfi_def_cfa_register 7
 937 0006 7860     	 str r0,[r7,#4]
 938 0008 3960     	 str r1,[r7]
 412:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status = CAPTURE_STATUS_SUCCESS;
 939              	 .loc 2 412 0
 940 000a 0023     	 movs r3,#0
 941 000c FB75     	 strb r3,[r7,#23]
 413:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status1 = CAPTURE_STATUS_SUCCESS;
 942              	 .loc 2 413 0
 943 000e 0023     	 movs r3,#0
 944 0010 BB75     	 strb r3,[r7,#22]
 414:../Dave/Generated/CAPTURE/capture.c **** 
 415:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetCapturedTimeInNanoSec:handler NULL", (handler != NULL));
 416:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetCapturedTimeInNanoSec:NULL data pointer", (captured_time != NULL));
 417:../Dave/Generated/CAPTURE/capture.c **** 
 418:../Dave/Generated/CAPTURE/capture.c ****   /* Check for APP instance is initialized or not */
 419:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->initialized)
 945              	 .loc 2 419 0
 946 0012 7B68     	 ldr r3,[r7,#4]
 947 0014 93F83130 	 ldrb r3,[r3,#49]
 948 0018 002B     	 cmp r3,#0
 949 001a 69D0     	 beq .L41
 420:../Dave/Generated/CAPTURE/capture.c ****   {
 421:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 422:../Dave/Generated/CAPTURE/capture.c ****     if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 950              	 .loc 2 422 0
 951 001c 7B68     	 ldr r3,[r7,#4]
 952 001e 93F82D30 	 ldrb r3,[r3,#45]
 953 0022 002B     	 cmp r3,#0
 954 0024 66D1     	 bne .L46
 423:../Dave/Generated/CAPTURE/capture.c ****     {
 424:../Dave/Generated/CAPTURE/capture.c ****       if ((handler->capture_edge_config == CAPTURE_EDGE_RISE_TO_RISE) ||
 955              	 .loc 2 424 0
 956 0026 7B68     	 ldr r3,[r7,#4]
 957 0028 93F82E30 	 ldrb r3,[r3,#46]
 958 002c 002B     	 cmp r3,#0
 959 002e 04D0     	 beq .L43
 425:../Dave/Generated/CAPTURE/capture.c ****           (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 960              	 .loc 2 425 0 discriminator 1
 961 0030 7B68     	 ldr r3,[r7,#4]
 962 0032 93F82E30 	 ldrb r3,[r3,#46]
 424:../Dave/Generated/CAPTURE/capture.c ****           (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 963              	 .loc 2 424 0 discriminator 1
 964 0036 032B     	 cmp r3,#3
 965 0038 41D1     	 bne .L44
 966              	.L43:
 967              	.LBB11:
 426:../Dave/Generated/CAPTURE/capture.c ****       {
 427:../Dave/Generated/CAPTURE/capture.c ****         uint32_t captured_time_low_reg = 0U;
 968              	 .loc 2 427 0
 969 003a 0023     	 movs r3,#0
 970 003c 3B61     	 str r3,[r7,#16]
 428:../Dave/Generated/CAPTURE/capture.c ****         uint32_t captured_time_high_reg = 0U;
 971              	 .loc 2 428 0
 972 003e 0023     	 movs r3,#0
 973 0040 FB60     	 str r3,[r7,#12]
 429:../Dave/Generated/CAPTURE/capture.c **** 
 430:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 974              	 .loc 2 430 0
 975 0042 7B68     	 ldr r3,[r7,#4]
 976 0044 9A69     	 ldr r2,[r3,#24]
 977 0046 07F11003 	 add r3,r7,#16
 978 004a 1046     	 mov r0,r2
 979 004c 0021     	 movs r1,#0
 980 004e 1A46     	 mov r2,r3
 981 0050 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 982 0054 0346     	 mov r3,r0
 983 0056 FB75     	 strb r3,[r7,#23]
 431:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU4_SLICE_CAP_REG_SET_LOW,
 432:../Dave/Generated/CAPTURE/capture.c ****                                                                   &captured_time_low_reg);
 433:../Dave/Generated/CAPTURE/capture.c **** 
 434:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 984              	 .loc 2 434 0
 985 0058 7B68     	 ldr r3,[r7,#4]
 986 005a 9A69     	 ldr r2,[r3,#24]
 987 005c 07F10C03 	 add r3,r7,#12
 988 0060 1046     	 mov r0,r2
 989 0062 0121     	 movs r1,#1
 990 0064 1A46     	 mov r2,r3
 991 0066 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 992 006a 0346     	 mov r3,r0
 993 006c BB75     	 strb r3,[r7,#22]
 435:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU4_SLICE_CAP_REG_SET_HIGH,
 436:../Dave/Generated/CAPTURE/capture.c ****                                                                    &captured_time_high_reg);
 437:../Dave/Generated/CAPTURE/capture.c **** 
 438:../Dave/Generated/CAPTURE/capture.c ****         /*calculate time tick from capture value and pre-scale value of captured register**/
 439:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &captured_time_low_reg, true);
 994              	 .loc 2 439 0
 995 006e 07F11003 	 add r3,r7,#16
 996 0072 7868     	 ldr r0,[r7,#4]
 997 0074 1946     	 mov r1,r3
 998 0076 0122     	 movs r2,#1
 999 0078 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 440:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time in Nanosecond from timer tick and pre-scale value of captured register**/
 441:../Dave/Generated/CAPTURE/capture.c ****         captured_time_low_reg = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, captured_time
 1000              	 .loc 2 441 0
 1001 007c 3B69     	 ldr r3,[r7,#16]
 1002 007e 7868     	 ldr r0,[r7,#4]
 1003 0080 1946     	 mov r1,r3
 1004 0082 FFF7FEFF 	 bl CAPTURE_lCalculateTimeInNanoSecFromTimerTick
 1005 0086 0346     	 mov r3,r0
 1006 0088 3B61     	 str r3,[r7,#16]
 442:../Dave/Generated/CAPTURE/capture.c **** 
 443:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time tick from capture value and pre-scale value of captured register**/
 444:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &captured_time_high_reg, false);
 1007              	 .loc 2 444 0
 1008 008a 07F10C03 	 add r3,r7,#12
 1009 008e 7868     	 ldr r0,[r7,#4]
 1010 0090 1946     	 mov r1,r3
 1011 0092 0022     	 movs r2,#0
 1012 0094 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 445:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time in Nanosecond from timer tick and pre-scale value of captured_time_high_r
 446:../Dave/Generated/CAPTURE/capture.c ****         captured_time_high_reg = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, captured_tim
 1013              	 .loc 2 446 0
 1014 0098 FB68     	 ldr r3,[r7,#12]
 1015 009a 7868     	 ldr r0,[r7,#4]
 1016 009c 1946     	 mov r1,r3
 1017 009e FFF7FEFF 	 bl CAPTURE_lCalculateTimeInNanoSecFromTimerTick
 1018 00a2 0346     	 mov r3,r0
 1019 00a4 FB60     	 str r3,[r7,#12]
 447:../Dave/Generated/CAPTURE/capture.c **** 
 448:../Dave/Generated/CAPTURE/capture.c ****         /* add both high and lower register value*/
 449:../Dave/Generated/CAPTURE/capture.c ****         *captured_time = captured_time_low_reg + captured_time_high_reg;
 1020              	 .loc 2 449 0
 1021 00a6 3A69     	 ldr r2,[r7,#16]
 1022 00a8 FB68     	 ldr r3,[r7,#12]
 1023 00aa 1A44     	 add r2,r2,r3
 1024 00ac 3B68     	 ldr r3,[r7]
 1025 00ae 1A60     	 str r2,[r3]
 450:../Dave/Generated/CAPTURE/capture.c **** 
 451:../Dave/Generated/CAPTURE/capture.c ****         if (status1 == CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED)
 1026              	 .loc 2 451 0
 1027 00b0 BB7D     	 ldrb r3,[r7,#22]
 1028 00b2 022B     	 cmp r3,#2
 1029 00b4 02D1     	 bne .L45
 452:../Dave/Generated/CAPTURE/capture.c ****         {
 453:../Dave/Generated/CAPTURE/capture.c ****           status = CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED;
 1030              	 .loc 2 453 0
 1031 00b6 0223     	 movs r3,#2
 1032 00b8 FB75     	 strb r3,[r7,#23]
 1033              	.LBE11:
 426:../Dave/Generated/CAPTURE/capture.c ****         uint32_t captured_time_low_reg = 0U;
 1034              	 .loc 2 426 0
 1035 00ba 18E0     	 b .L42
 1036              	.L45:
 1037 00bc 17E0     	 b .L42
 1038              	.L44:
 454:../Dave/Generated/CAPTURE/capture.c ****         }
 455:../Dave/Generated/CAPTURE/capture.c ****       }
 456:../Dave/Generated/CAPTURE/capture.c ****       else
 457:../Dave/Generated/CAPTURE/capture.c ****       {
 458:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 1039              	 .loc 2 458 0
 1040 00be 7B68     	 ldr r3,[r7,#4]
 1041 00c0 9B69     	 ldr r3,[r3,#24]
 1042 00c2 1846     	 mov r0,r3
 1043 00c4 0121     	 movs r1,#1
 1044 00c6 3A68     	 ldr r2,[r7]
 1045 00c8 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 1046 00cc 0346     	 mov r3,r0
 1047 00ce FB75     	 strb r3,[r7,#23]
 459:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU4_SLICE_CAP_REG_SET_HIGH,
 460:../Dave/Generated/CAPTURE/capture.c ****                                                                   captured_time);
 461:../Dave/Generated/CAPTURE/capture.c **** 
 462:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time tick from capture value and pre-scale value of captured register**/
 463:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, captured_time, true);
 1048              	 .loc 2 463 0
 1049 00d0 7868     	 ldr r0,[r7,#4]
 1050 00d2 3968     	 ldr r1,[r7]
 1051 00d4 0122     	 movs r2,#1
 1052 00d6 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 464:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time in Nanosecond from timer tick and pre-scale value of captured register**/
 465:../Dave/Generated/CAPTURE/capture.c ****         *captured_time = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, *captured_time);
 1053              	 .loc 2 465 0
 1054 00da 3B68     	 ldr r3,[r7]
 1055 00dc 1B68     	 ldr r3,[r3]
 1056 00de 7868     	 ldr r0,[r7,#4]
 1057 00e0 1946     	 mov r1,r3
 1058 00e2 FFF7FEFF 	 bl CAPTURE_lCalculateTimeInNanoSecFromTimerTick
 1059 00e6 0246     	 mov r2,r0
 1060 00e8 3B68     	 ldr r3,[r7]
 1061 00ea 1A60     	 str r2,[r3]
 1062 00ec 02E0     	 b .L46
 1063              	.L42:
 1064 00ee 01E0     	 b .L46
 1065              	.L41:
 466:../Dave/Generated/CAPTURE/capture.c ****       }
 467:../Dave/Generated/CAPTURE/capture.c ****     }
 468:../Dave/Generated/CAPTURE/capture.c **** #endif
 469:../Dave/Generated/CAPTURE/capture.c **** 
 470:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
 471:../Dave/Generated/CAPTURE/capture.c ****     if (CAPTURE_MODULE_CCU8 == handler->capture_module)
 472:../Dave/Generated/CAPTURE/capture.c ****     {
 473:../Dave/Generated/CAPTURE/capture.c ****       if ((handler->capture_edge_config == CAPTURE_EDGE_RISE_TO_RISE) ||
 474:../Dave/Generated/CAPTURE/capture.c ****           (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 475:../Dave/Generated/CAPTURE/capture.c ****       {
 476:../Dave/Generated/CAPTURE/capture.c ****         uint32_t captured_time_low_reg = 0U;
 477:../Dave/Generated/CAPTURE/capture.c ****         uint32_t captured_time_high_reg = 0U;
 478:../Dave/Generated/CAPTURE/capture.c **** 
 479:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 480:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU8_SLICE_CAP_REG_SET_LOW,
 481:../Dave/Generated/CAPTURE/capture.c ****                                                                   &captured_time_low_reg);
 482:../Dave/Generated/CAPTURE/capture.c **** 
 483:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 484:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU8_SLICE_CAP_REG_SET_HIGH,
 485:../Dave/Generated/CAPTURE/capture.c ****                                                                    &captured_time_high_reg);
 486:../Dave/Generated/CAPTURE/capture.c **** 
 487:../Dave/Generated/CAPTURE/capture.c ****         /*calculate time tick from capture value and pre-scale value of captured register**/
 488:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &captured_time_low_reg, true);
 489:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time in Nanosecond from timer tick and pre-scale value of captured register**/
 490:../Dave/Generated/CAPTURE/capture.c ****         captured_time_low_reg = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, captured_time
 491:../Dave/Generated/CAPTURE/capture.c **** 
 492:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time tick from capture value and pre-scale value of captured register**/
 493:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &captured_time_high_reg, false);
 494:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time in Nanosecond from timer tick and pre-scale value of captured_time_high_r
 495:../Dave/Generated/CAPTURE/capture.c ****         captured_time_high_reg = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, captured_tim
 496:../Dave/Generated/CAPTURE/capture.c **** 
 497:../Dave/Generated/CAPTURE/capture.c ****         /* add both high and lower register value*/
 498:../Dave/Generated/CAPTURE/capture.c ****         *captured_time = captured_time_low_reg + captured_time_high_reg;
 499:../Dave/Generated/CAPTURE/capture.c **** 
 500:../Dave/Generated/CAPTURE/capture.c ****         if (status1 == CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED)
 501:../Dave/Generated/CAPTURE/capture.c ****         {
 502:../Dave/Generated/CAPTURE/capture.c ****           status = CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED;
 503:../Dave/Generated/CAPTURE/capture.c ****         }
 504:../Dave/Generated/CAPTURE/capture.c ****       }
 505:../Dave/Generated/CAPTURE/capture.c ****       else
 506:../Dave/Generated/CAPTURE/capture.c ****       {
 507:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 508:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU8_SLICE_CAP_REG_SET_HIGH,
 509:../Dave/Generated/CAPTURE/capture.c ****                                                                   captured_time);
 510:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time tick from capture value and pre-scale value of captured register**/
 511:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, captured_time, true);
 512:../Dave/Generated/CAPTURE/capture.c ****         /* calculate time in Nanosecond from timer tick and pre-scale value of captured register**/
 513:../Dave/Generated/CAPTURE/capture.c ****         *captured_time = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, *captured_time);
 514:../Dave/Generated/CAPTURE/capture.c ****       }
 515:../Dave/Generated/CAPTURE/capture.c ****     }
 516:../Dave/Generated/CAPTURE/capture.c **** #endif
 517:../Dave/Generated/CAPTURE/capture.c ****   }
 518:../Dave/Generated/CAPTURE/capture.c ****   else
 519:../Dave/Generated/CAPTURE/capture.c ****   {
 520:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_STATUS_FAILURE;
 1066              	 .loc 2 520 0
 1067 00f0 0123     	 movs r3,#1
 1068 00f2 FB75     	 strb r3,[r7,#23]
 1069              	.L46:
 521:../Dave/Generated/CAPTURE/capture.c ****   }
 522:../Dave/Generated/CAPTURE/capture.c **** 
 523:../Dave/Generated/CAPTURE/capture.c ****   return (status);
 1070              	 .loc 2 523 0
 1071 00f4 FB7D     	 ldrb r3,[r7,#23]
 524:../Dave/Generated/CAPTURE/capture.c **** }
 1072              	 .loc 2 524 0
 1073 00f6 1846     	 mov r0,r3
 1074 00f8 1837     	 adds r7,r7,#24
 1075              	.LCFI82:
 1076              	 .cfi_def_cfa_offset 8
 1077 00fa BD46     	 mov sp,r7
 1078              	.LCFI83:
 1079              	 .cfi_def_cfa_register 13
 1080              	 
 1081 00fc 80BD     	 pop {r7,pc}
 1082              	 .cfi_endproc
 1083              	.LFE233:
 1085 00fe 00BF     	 .section .text.CAPTURE_GetDutyCycle,"ax",%progbits
 1086              	 .align 2
 1087              	 .global CAPTURE_GetDutyCycle
 1088              	 .thumb
 1089              	 .thumb_func
 1091              	CAPTURE_GetDutyCycle:
 1092              	.LFB234:
 525:../Dave/Generated/CAPTURE/capture.c **** 
 526:../Dave/Generated/CAPTURE/capture.c **** CAPTURE_STATUS_t CAPTURE_GetDutyCycle(const CAPTURE_t *const handler, uint32_t *const signal_duty)
 527:../Dave/Generated/CAPTURE/capture.c **** {
 1093              	 .loc 2 527 0
 1094              	 .cfi_startproc
 1095              	 
 1096              	 
 1097 0000 80B5     	 push {r7,lr}
 1098              	.LCFI84:
 1099              	 .cfi_def_cfa_offset 8
 1100              	 .cfi_offset 7,-8
 1101              	 .cfi_offset 14,-4
 1102 0002 84B0     	 sub sp,sp,#16
 1103              	.LCFI85:
 1104              	 .cfi_def_cfa_offset 24
 1105 0004 00AF     	 add r7,sp,#0
 1106              	.LCFI86:
 1107              	 .cfi_def_cfa_register 7
 1108 0006 7860     	 str r0,[r7,#4]
 1109 0008 3960     	 str r1,[r7]
 528:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status = CAPTURE_STATUS_SUCCESS;
 1110              	 .loc 2 528 0
 1111 000a 0023     	 movs r3,#0
 1112 000c FB73     	 strb r3,[r7,#15]
 529:../Dave/Generated/CAPTURE/capture.c ****   uint32_t duty_val = 0U;
 1113              	 .loc 2 529 0
 1114 000e 0023     	 movs r3,#0
 1115 0010 BB60     	 str r3,[r7,#8]
 530:../Dave/Generated/CAPTURE/capture.c **** 
 531:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetDutyCycle:handler NULL", (handler != NULL));
 532:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetDutyCycle:NULL data pointer", (signal_duty != NULL));
 533:../Dave/Generated/CAPTURE/capture.c **** 
 534:../Dave/Generated/CAPTURE/capture.c ****   /* Check for APP instance is initialized or not */
 535:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->initialized)
 1116              	 .loc 2 535 0
 1117 0012 7B68     	 ldr r3,[r7,#4]
 1118 0014 93F83130 	 ldrb r3,[r3,#49]
 1119 0018 002B     	 cmp r3,#0
 1120 001a 2FD0     	 beq .L49
 536:../Dave/Generated/CAPTURE/capture.c ****   {
 537:../Dave/Generated/CAPTURE/capture.c ****     if ((handler->capture_edge_config == CAPTURE_EDGE_RISE_TO_RISE) ||
 1121              	 .loc 2 537 0
 1122 001c 7B68     	 ldr r3,[r7,#4]
 1123 001e 93F82E30 	 ldrb r3,[r3,#46]
 1124 0022 002B     	 cmp r3,#0
 1125 0024 04D0     	 beq .L50
 538:../Dave/Generated/CAPTURE/capture.c ****         (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 1126              	 .loc 2 538 0 discriminator 1
 1127 0026 7B68     	 ldr r3,[r7,#4]
 1128 0028 93F82E30 	 ldrb r3,[r3,#46]
 537:../Dave/Generated/CAPTURE/capture.c ****         (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 1129              	 .loc 2 537 0 discriminator 1
 1130 002c 032B     	 cmp r3,#3
 1131 002e 21D1     	 bne .L51
 1132              	.L50:
 539:../Dave/Generated/CAPTURE/capture.c ****     {
 540:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 541:../Dave/Generated/CAPTURE/capture.c ****       if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 1133              	 .loc 2 541 0
 1134 0030 7B68     	 ldr r3,[r7,#4]
 1135 0032 93F82D30 	 ldrb r3,[r3,#45]
 1136 0036 002B     	 cmp r3,#0
 1137 0038 0AD1     	 bne .L52
 542:../Dave/Generated/CAPTURE/capture.c ****       {
 543:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 1138              	 .loc 2 543 0
 1139 003a 7B68     	 ldr r3,[r7,#4]
 1140 003c 9A69     	 ldr r2,[r3,#24]
 1141 003e 07F10803 	 add r3,r7,#8
 1142 0042 1046     	 mov r0,r2
 1143 0044 0121     	 movs r1,#1
 1144 0046 1A46     	 mov r2,r3
 1145 0048 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 1146 004c 0346     	 mov r3,r0
 1147 004e FB73     	 strb r3,[r7,#15]
 1148              	.L52:
 544:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU4_SLICE_CAP_REG_SET_HIGH,
 545:../Dave/Generated/CAPTURE/capture.c ****                                                                   &duty_val);
 546:../Dave/Generated/CAPTURE/capture.c ****       }
 547:../Dave/Generated/CAPTURE/capture.c **** #endif
 548:../Dave/Generated/CAPTURE/capture.c **** 
 549:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
 550:../Dave/Generated/CAPTURE/capture.c ****       if (CAPTURE_MODULE_CCU8 == handler->capture_module)
 551:../Dave/Generated/CAPTURE/capture.c ****       {
 552:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 553:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU8_SLICE_CAP_REG_SET_HIGH,
 554:../Dave/Generated/CAPTURE/capture.c ****                                                                   &duty_val);
 555:../Dave/Generated/CAPTURE/capture.c ****       }
 556:../Dave/Generated/CAPTURE/capture.c **** #endif
 557:../Dave/Generated/CAPTURE/capture.c ****       if (status == CAPTURE_STATUS_SUCCESS)
 1149              	 .loc 2 557 0
 1150 0050 FB7B     	 ldrb r3,[r7,#15]
 1151 0052 002B     	 cmp r3,#0
 1152 0054 0AD1     	 bne .L53
 558:../Dave/Generated/CAPTURE/capture.c ****       {
 559:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &duty_val, false);
 1153              	 .loc 2 559 0
 1154 0056 07F10803 	 add r3,r7,#8
 1155 005a 7868     	 ldr r0,[r7,#4]
 1156 005c 1946     	 mov r1,r3
 1157 005e 0022     	 movs r2,#0
 1158 0060 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 560:../Dave/Generated/CAPTURE/capture.c ****         *signal_duty = duty_val;
 1159              	 .loc 2 560 0
 1160 0064 BA68     	 ldr r2,[r7,#8]
 1161 0066 3B68     	 ldr r3,[r7]
 1162 0068 1A60     	 str r2,[r3]
 557:../Dave/Generated/CAPTURE/capture.c ****       {
 1163              	 .loc 2 557 0
 1164 006a 06E0     	 b .L55
 1165              	.L53:
 561:../Dave/Generated/CAPTURE/capture.c ****       }
 562:../Dave/Generated/CAPTURE/capture.c ****       else
 563:../Dave/Generated/CAPTURE/capture.c ****       {
 564:../Dave/Generated/CAPTURE/capture.c ****         *signal_duty = 0U;
 1166              	 .loc 2 564 0
 1167 006c 3B68     	 ldr r3,[r7]
 1168 006e 0022     	 movs r2,#0
 1169 0070 1A60     	 str r2,[r3]
 557:../Dave/Generated/CAPTURE/capture.c ****       {
 1170              	 .loc 2 557 0
 1171 0072 02E0     	 b .L55
 1172              	.L51:
 565:../Dave/Generated/CAPTURE/capture.c ****       }
 566:../Dave/Generated/CAPTURE/capture.c ****     }
 567:../Dave/Generated/CAPTURE/capture.c ****     else
 568:../Dave/Generated/CAPTURE/capture.c ****     {
 569:../Dave/Generated/CAPTURE/capture.c ****       status = CAPTURE_STATUS_INVALID_CONFIG;
 1173              	 .loc 2 569 0
 1174 0074 0323     	 movs r3,#3
 1175 0076 FB73     	 strb r3,[r7,#15]
 1176 0078 02E0     	 b .L56
 1177              	.L55:
 1178 007a 01E0     	 b .L56
 1179              	.L49:
 570:../Dave/Generated/CAPTURE/capture.c ****     }
 571:../Dave/Generated/CAPTURE/capture.c ****   }
 572:../Dave/Generated/CAPTURE/capture.c ****   else
 573:../Dave/Generated/CAPTURE/capture.c ****   {
 574:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_STATUS_FAILURE;
 1180              	 .loc 2 574 0
 1181 007c 0123     	 movs r3,#1
 1182 007e FB73     	 strb r3,[r7,#15]
 1183              	.L56:
 575:../Dave/Generated/CAPTURE/capture.c ****   }
 576:../Dave/Generated/CAPTURE/capture.c **** 
 577:../Dave/Generated/CAPTURE/capture.c ****   return (status);
 1184              	 .loc 2 577 0
 1185 0080 FB7B     	 ldrb r3,[r7,#15]
 578:../Dave/Generated/CAPTURE/capture.c **** }
 1186              	 .loc 2 578 0
 1187 0082 1846     	 mov r0,r3
 1188 0084 1037     	 adds r7,r7,#16
 1189              	.LCFI87:
 1190              	 .cfi_def_cfa_offset 8
 1191 0086 BD46     	 mov sp,r7
 1192              	.LCFI88:
 1193              	 .cfi_def_cfa_register 13
 1194              	 
 1195 0088 80BD     	 pop {r7,pc}
 1196              	 .cfi_endproc
 1197              	.LFE234:
 1199 008a 00BF     	 .section .text.CAPTURE_GetDutyCycleInPercentage,"ax",%progbits
 1200              	 .align 2
 1201              	 .global CAPTURE_GetDutyCycleInPercentage
 1202              	 .thumb
 1203              	 .thumb_func
 1205              	CAPTURE_GetDutyCycleInPercentage:
 1206              	.LFB235:
 579:../Dave/Generated/CAPTURE/capture.c **** 
 580:../Dave/Generated/CAPTURE/capture.c **** CAPTURE_STATUS_t CAPTURE_GetDutyCycleInPercentage(const CAPTURE_t *const handler, uint32_t *const s
 581:../Dave/Generated/CAPTURE/capture.c **** {
 1207              	 .loc 2 581 0
 1208              	 .cfi_startproc
 1209              	 
 1210              	 
 1211 0000 80B5     	 push {r7,lr}
 1212              	.LCFI89:
 1213              	 .cfi_def_cfa_offset 8
 1214              	 .cfi_offset 7,-8
 1215              	 .cfi_offset 14,-4
 1216 0002 88B0     	 sub sp,sp,#32
 1217              	.LCFI90:
 1218              	 .cfi_def_cfa_offset 40
 1219 0004 00AF     	 add r7,sp,#0
 1220              	.LCFI91:
 1221              	 .cfi_def_cfa_register 7
 1222 0006 7860     	 str r0,[r7,#4]
 1223 0008 3960     	 str r1,[r7]
 582:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status = CAPTURE_STATUS_SUCCESS;
 1224              	 .loc 2 582 0
 1225 000a 0023     	 movs r3,#0
 1226 000c FB77     	 strb r3,[r7,#31]
 583:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status1 = CAPTURE_STATUS_SUCCESS;
 1227              	 .loc 2 583 0
 1228 000e 0023     	 movs r3,#0
 1229 0010 BB77     	 strb r3,[r7,#30]
 584:../Dave/Generated/CAPTURE/capture.c **** 
 585:../Dave/Generated/CAPTURE/capture.c ****   uint32_t period_val = 0U;
 1230              	 .loc 2 585 0
 1231 0012 0023     	 movs r3,#0
 1232 0014 3B61     	 str r3,[r7,#16]
 586:../Dave/Generated/CAPTURE/capture.c ****   uint32_t duty_val = 0U;
 1233              	 .loc 2 586 0
 1234 0016 0023     	 movs r3,#0
 1235 0018 FB60     	 str r3,[r7,#12]
 587:../Dave/Generated/CAPTURE/capture.c ****   uint32_t norm_period_val = 0U;
 1236              	 .loc 2 587 0
 1237 001a 0023     	 movs r3,#0
 1238 001c BB61     	 str r3,[r7,#24]
 588:../Dave/Generated/CAPTURE/capture.c **** 
 589:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetDutyCycleInPercentage:handler NULL", (handler != NULL));
 590:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetDutyCycleInPercentage:NULL data pointer", (signal_duty != NULL));
 591:../Dave/Generated/CAPTURE/capture.c **** 
 592:../Dave/Generated/CAPTURE/capture.c ****   /* Check for APP instance is initialized or not */
 593:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->initialized)
 1239              	 .loc 2 593 0
 1240 001e 7B68     	 ldr r3,[r7,#4]
 1241 0020 93F83130 	 ldrb r3,[r3,#49]
 1242 0024 002B     	 cmp r3,#0
 1243 0026 72D0     	 beq .L59
 594:../Dave/Generated/CAPTURE/capture.c ****   {
 595:../Dave/Generated/CAPTURE/capture.c ****     if ((handler->capture_edge_config == CAPTURE_EDGE_RISE_TO_RISE) ||
 1244              	 .loc 2 595 0
 1245 0028 7B68     	 ldr r3,[r7,#4]
 1246 002a 93F82E30 	 ldrb r3,[r3,#46]
 1247 002e 002B     	 cmp r3,#0
 1248 0030 04D0     	 beq .L60
 596:../Dave/Generated/CAPTURE/capture.c ****         (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 1249              	 .loc 2 596 0 discriminator 1
 1250 0032 7B68     	 ldr r3,[r7,#4]
 1251 0034 93F82E30 	 ldrb r3,[r3,#46]
 595:../Dave/Generated/CAPTURE/capture.c ****         (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 1252              	 .loc 2 595 0 discriminator 1
 1253 0038 032B     	 cmp r3,#3
 1254 003a 64D1     	 bne .L61
 1255              	.L60:
 597:../Dave/Generated/CAPTURE/capture.c ****     {
 598:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 599:../Dave/Generated/CAPTURE/capture.c ****       if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 1256              	 .loc 2 599 0
 1257 003c 7B68     	 ldr r3,[r7,#4]
 1258 003e 93F82D30 	 ldrb r3,[r3,#45]
 1259 0042 002B     	 cmp r3,#0
 1260 0044 23D1     	 bne .L62
 600:../Dave/Generated/CAPTURE/capture.c ****       {
 601:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 1261              	 .loc 2 601 0
 1262 0046 7B68     	 ldr r3,[r7,#4]
 1263 0048 9A69     	 ldr r2,[r3,#24]
 1264 004a 07F11003 	 add r3,r7,#16
 1265 004e 1046     	 mov r0,r2
 1266 0050 0021     	 movs r1,#0
 1267 0052 1A46     	 mov r2,r3
 1268 0054 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 1269 0058 0346     	 mov r3,r0
 1270 005a FB77     	 strb r3,[r7,#31]
 602:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU4_SLICE_CAP_REG_SET_LOW,
 603:../Dave/Generated/CAPTURE/capture.c ****                                                                   &period_val);
 604:../Dave/Generated/CAPTURE/capture.c **** 
 605:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 1271              	 .loc 2 605 0
 1272 005c 7B68     	 ldr r3,[r7,#4]
 1273 005e 9A69     	 ldr r2,[r3,#24]
 1274 0060 07F10C03 	 add r3,r7,#12
 1275 0064 1046     	 mov r0,r2
 1276 0066 0121     	 movs r1,#1
 1277 0068 1A46     	 mov r2,r3
 1278 006a FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 1279 006e 0346     	 mov r3,r0
 1280 0070 BB77     	 strb r3,[r7,#30]
 606:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU4_SLICE_CAP_REG_SET_HIGH,
 607:../Dave/Generated/CAPTURE/capture.c ****                                                                    &duty_val);
 608:../Dave/Generated/CAPTURE/capture.c **** 
 609:../Dave/Generated/CAPTURE/capture.c **** 
 610:../Dave/Generated/CAPTURE/capture.c ****           CAPTURE_lCalculateTimeTickFromTimerValue (handler, &period_val, true);
 1281              	 .loc 2 610 0
 1282 0072 07F11003 	 add r3,r7,#16
 1283 0076 7868     	 ldr r0,[r7,#4]
 1284 0078 1946     	 mov r1,r3
 1285 007a 0122     	 movs r2,#1
 1286 007c FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 611:../Dave/Generated/CAPTURE/capture.c **** 
 612:../Dave/Generated/CAPTURE/capture.c ****           CAPTURE_lCalculateTimeTickFromTimerValue (handler, &duty_val, false);
 1287              	 .loc 2 612 0
 1288 0080 07F10C03 	 add r3,r7,#12
 1289 0084 7868     	 ldr r0,[r7,#4]
 1290 0086 1946     	 mov r1,r3
 1291 0088 0022     	 movs r2,#0
 1292 008a FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 1293              	.L62:
 613:../Dave/Generated/CAPTURE/capture.c **** 
 614:../Dave/Generated/CAPTURE/capture.c ****       }
 615:../Dave/Generated/CAPTURE/capture.c **** #endif
 616:../Dave/Generated/CAPTURE/capture.c **** 
 617:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
 618:../Dave/Generated/CAPTURE/capture.c ****       if (CAPTURE_MODULE_CCU8 == handler->capture_module)
 619:../Dave/Generated/CAPTURE/capture.c ****       {
 620:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 621:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU8_SLICE_CAP_REG_SET_LOW,
 622:../Dave/Generated/CAPTURE/capture.c ****                                                                   &period_val);
 623:../Dave/Generated/CAPTURE/capture.c **** 
 624:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 625:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU8_SLICE_CAP_REG_SET_HIGH,
 626:../Dave/Generated/CAPTURE/capture.c ****                                                                    &duty_val);
 627:../Dave/Generated/CAPTURE/capture.c **** 
 628:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &period_val, true);
 629:../Dave/Generated/CAPTURE/capture.c **** 
 630:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &duty_val, false);
 631:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &period_val, true);
 632:../Dave/Generated/CAPTURE/capture.c ****       }
 633:../Dave/Generated/CAPTURE/capture.c **** #endif
 634:../Dave/Generated/CAPTURE/capture.c ****       period_val += duty_val;
 1294              	 .loc 2 634 0
 1295 008e 3A69     	 ldr r2,[r7,#16]
 1296 0090 FB68     	 ldr r3,[r7,#12]
 1297 0092 1344     	 add r3,r3,r2
 1298 0094 3B61     	 str r3,[r7,#16]
 635:../Dave/Generated/CAPTURE/capture.c ****       norm_period_val = (uint32_t)__CLZ (period_val);
 1299              	 .loc 2 635 0
 1300 0096 3B69     	 ldr r3,[r7,#16]
 1301 0098 7B61     	 str r3,[r7,#20]
 1302              	.LBB12:
 1303              	.LBB13:
 1304              	 .file 3 "C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include/cmsis_gcc.h"
   1:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**************************************************************************//**
   2:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @version  V5.3.0
   5:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * @date     26. March 2020
   6:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  ******************************************************************************/
   7:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /*
   8:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * Copyright (c) 2009-2020 Arm Limited. All rights reserved.
   9:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  *
  10:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  *
  12:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  *
  16:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  *
  18:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * limitations under the License.
  23:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
  24:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  25:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  28:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /* ignore some GCC warnings */
  29:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #pragma GCC diagnostic push
  30:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  34:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef __has_builtin
  36:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  38:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
  39:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __ASM
  41:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __ASM                                  __asm
  42:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  43:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __INLINE
  44:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __INLINE                               inline
  45:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  46:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  49:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif                                           
  52:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  55:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __USED
  56:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  58:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __WEAK
  59:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  61:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __PACKED
  62:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  64:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  67:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  70:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  78:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  86:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
  94:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 102:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 110:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __ALIGNED
 111:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 113:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __RESTRICT
 114:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 116:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef   __COMPILER_BARRIER
 117:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   #define __COMPILER_BARRIER()                   __ASM volatile("":::"memory")
 118:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 119:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 120:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /* #########################  Startup and Lowlevel Init  ######################## */
 121:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 122:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef __PROGRAM_START
 123:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 124:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 125:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Initializes data and bss sections
 126:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details This default implementations initialized all data and additional bss
 127:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            sections relying on .copy.table and .zero.table specified properly
 128:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            in the used linker script.
 129:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   
 130:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 131:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE __NO_RETURN void __cmsis_start(void)
 132:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 133:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   extern void _start(void) __NO_RETURN;
 134:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   
 135:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   typedef struct {
 136:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     uint32_t const* src;
 137:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     uint32_t* dest;
 138:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     uint32_t  wlen;
 139:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   } __copy_table_t;
 140:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   
 141:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   typedef struct {
 142:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     uint32_t* dest;
 143:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     uint32_t  wlen;
 144:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   } __zero_table_t;
 145:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   
 146:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   extern const __copy_table_t __copy_table_start__;
 147:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   extern const __copy_table_t __copy_table_end__;
 148:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   extern const __zero_table_t __zero_table_start__;
 149:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   extern const __zero_table_t __zero_table_end__;
 150:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 151:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable
 152:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 153:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****       pTable->dest[i] = pTable->src[i];
 154:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     }
 155:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   }
 156:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  
 157:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable
 158:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 159:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****       pTable->dest[i] = 0u;
 160:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     }
 161:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   }
 162:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  
 163:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   _start();
 164:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 165:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   
 166:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __PROGRAM_START           __cmsis_start
 167:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 168:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 169:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef __INITIAL_SP
 170:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __INITIAL_SP              __StackTop
 171:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 172:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 173:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef __STACK_LIMIT
 174:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __STACK_LIMIT             __StackLimit
 175:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 176:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 177:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef __VECTOR_TABLE
 178:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __VECTOR_TABLE            __Vectors
 179:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 180:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 181:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #ifndef __VECTOR_TABLE_ATTRIBUTE
 182:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section(".vectors")))
 183:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 184:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 185:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 186:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 187:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 188:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   @{
 189:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 190:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 191:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 192:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 193:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 194:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            Can only be executed in Privileged modes.
 195:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 196:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 197:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 198:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 199:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 200:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 201:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 202:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 203:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 204:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 205:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            Can only be executed in Privileged modes.
 206:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 207:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 208:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 209:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 210:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 211:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 212:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 213:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 214:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Control Register
 215:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the Control Register.
 216:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Control Register value
 217:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 218:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 219:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 220:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 221:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 222:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 223:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 224:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 225:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 226:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 227:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 228:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 229:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 230:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 231:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               non-secure Control Register value
 232:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 233:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 234:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 235:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 236:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 237:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 238:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 239:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 240:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 241:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 242:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 243:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 244:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Control Register
 245:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 246:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 247:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 248:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 249:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 250:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 251:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 252:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 253:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 254:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 255:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 256:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 257:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 258:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 259:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 260:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 261:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 262:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 263:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 264:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 265:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 266:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 267:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 268:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get IPSR Register
 269:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 270:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               IPSR Register value
 271:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 272:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 273:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 274:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 275:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 276:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 277:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 278:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 279:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 280:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 281:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 282:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get APSR Register
 283:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 284:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               APSR Register value
 285:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 286:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 287:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 288:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 289:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 290:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 291:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 292:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 293:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 294:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 295:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 296:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get xPSR Register
 297:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 298:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               xPSR Register value
 299:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 300:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 301:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 302:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 303:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 304:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 305:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 306:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 307:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 308:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 309:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 310:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 311:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 312:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               PSP Register value
 313:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 314:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 315:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 316:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 317:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 318:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 319:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 320:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 321:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 322:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 323:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 324:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 325:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
 326:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 327:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               PSP Register value
 328:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 329:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 330:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 331:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 332:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 333:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 334:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 335:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 336:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 337:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 338:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 339:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 340:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 341:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 342:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 343:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 344:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 345:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 346:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 347:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 348:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 349:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 350:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 352:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 353:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 354:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 355:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 356:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 357:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 358:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 359:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 360:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 361:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 362:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 363:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 364:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 365:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 366:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               MSP Register value
 367:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 368:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 369:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 370:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 371:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 372:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 373:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 374:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 375:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 376:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 377:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 378:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 379:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 380:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 381:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               MSP Register value
 382:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 383:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 384:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 385:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 386:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 387:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 388:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 389:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 390:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 391:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 392:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 393:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 394:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 395:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 396:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 397:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 398:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 399:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 400:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 401:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 402:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 403:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 404:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 405:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 406:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 407:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 408:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 409:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 410:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 411:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 412:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 413:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 414:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 415:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 416:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 417:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 418:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 419:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 420:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 421:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               SP Register value
 422:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 423:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 424:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 425:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 426:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 427:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 428:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 429:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 430:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 431:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 432:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 433:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 434:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 435:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 436:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 437:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 438:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 439:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
 440:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 441:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 442:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 443:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 444:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 445:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Priority Mask
 446:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 447:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Priority Mask value
 448:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 449:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 450:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 451:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 452:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 453:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 454:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 455:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 456:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 457:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 458:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 459:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 460:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 461:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 462:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Priority Mask value
 463:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 464:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 465:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 466:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 467:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 468:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) );
 469:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 470:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 471:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 472:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 473:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 474:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 475:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Priority Mask
 476:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 477:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 478:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 479:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 480:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 481:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 482:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 483:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 484:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 485:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 486:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 487:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 488:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 489:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 490:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 491:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 492:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 493:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 494:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 495:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 496:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 497:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 498:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 499:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 500:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 501:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 502:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Enable FIQ
 503:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 504:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            Can only be executed in Privileged modes.
 505:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 506:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 507:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 508:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 509:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 510:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 511:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 512:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 513:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Disable FIQ
 514:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 515:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            Can only be executed in Privileged modes.
 516:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 517:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 518:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 519:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 520:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 521:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 522:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 523:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 524:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Base Priority
 525:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 526:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Base Priority register value
 527:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 528:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 529:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 530:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 531:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 532:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 533:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 534:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 535:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 536:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 537:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 538:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 539:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 540:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 541:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Base Priority register value
 542:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 543:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 544:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 545:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 546:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 547:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 548:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 549:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 550:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 551:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 552:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 553:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 554:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Base Priority
 555:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 556:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 557:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 558:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 559:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 560:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 561:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 562:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 563:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 564:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 565:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 566:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 567:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 568:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 569:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 570:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 571:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 572:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 573:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 574:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 575:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 576:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 577:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 578:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Base Priority with condition
 579:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 580:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 581:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 582:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 583:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 584:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 585:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 586:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 587:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 588:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 589:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 590:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Fault Mask
 591:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 592:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Fault Mask register value
 593:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 594:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 595:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 596:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 597:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 598:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 599:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 600:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 601:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 602:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 603:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 604:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 605:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 606:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 607:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Fault Mask register value
 608:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 609:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 610:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 611:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 612:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 613:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 614:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 615:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 616:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 617:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 618:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 619:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 620:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Fault Mask
 621:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 622:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 623:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 624:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 625:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 626:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 627:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 628:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 629:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 630:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 631:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 632:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 633:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 634:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 635:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 636:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 637:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 638:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 639:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 640:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 641:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 642:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 643:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 644:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 645:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 646:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 647:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 648:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 649:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 650:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 651:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 652:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 654:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   mode.
 655:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   
 656:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 657:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               PSPLIM Register value
 658:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 659:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 660:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 661:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 662:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 663:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 664:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return 0U;
 665:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 666:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 667:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
 668:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return result;
 669:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 670:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 671:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 672:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 673:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 674:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 675:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 676:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 677:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 678:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 679:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               PSPLIM Register value
 680:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 681:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 682:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 683:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 684:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 685:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return 0U;
 686:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 687:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 688:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 689:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return result;
 690:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 691:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 692:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 693:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 694:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 695:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 696:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 697:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 698:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 699:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   mode.
 700:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   
 701:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 702:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 703:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 704:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 705:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 706:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 707:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 708:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 709:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 710:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 711:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 712:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 713:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 714:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 715:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 716:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 717:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 718:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 719:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 720:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 721:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 722:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 723:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 724:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 725:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 726:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 727:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 728:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 729:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 730:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 731:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 732:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 733:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 734:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 735:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 736:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 737:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 738:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 739:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 740:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 741:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   mode.
 742:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 743:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 744:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               MSPLIM Register value
 745:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 746:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 747:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 748:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 749:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 750:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 751:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return 0U;
 752:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 753:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 754:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 755:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return result;
 756:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 757:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 758:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 759:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 760:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 761:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 762:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 763:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 764:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 765:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 766:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 767:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               MSPLIM Register value
 768:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 769:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 770:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 771:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 772:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 773:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return 0U;
 774:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 775:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 776:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 777:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return result;
 778:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 779:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 780:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 781:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 782:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 783:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 784:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 785:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 786:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 787:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   mode.
 788:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 789:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 790:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 791:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 792:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 793:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 794:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 795:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 796:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 797:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   (void)MainStackPtrLimit;
 798:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 799:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 800:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 801:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 802:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 803:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 804:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 805:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 806:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 807:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 808:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 809:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 810:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 811:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 812:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 813:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 814:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 815:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 816:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 817:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   (void)MainStackPtrLimit;
 818:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 819:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 820:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 821:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 822:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 823:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 824:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 825:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 826:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 827:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 828:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 829:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Get FPSCR
 830:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 831:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 832:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 833:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 834:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 835:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 836:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 837:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 838:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 839:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 840:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 841:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 842:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 843:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 844:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 845:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 846:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(result);
 847:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 848:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 849:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return(0U);
 850:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 851:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 852:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 853:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 854:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 855:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Set FPSCR
 856:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 857:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 858:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 859:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 860:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 861:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 862:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 863:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 864:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 865:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 866:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 867:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 868:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 869:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 870:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 871:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 872:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   (void)fpscr;
 873:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 874:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 875:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 876:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 877:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 878:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 879:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 880:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 881:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 882:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   Access to dedicated instructions
 883:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   @{
 884:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** */
 885:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 886:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 887:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 888:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 889:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 890:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 891:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 892:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 893:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 894:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 895:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 896:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 897:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 898:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 899:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 900:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   No Operation
 901:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 902:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 903:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 904:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 905:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 906:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Wait For Interrupt
 907:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 908:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 909:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi":::"memory")
 910:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 911:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 912:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 913:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Wait For Event
 914:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 915:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 916:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 917:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe":::"memory")
 918:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 919:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 920:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 921:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Send Event
 922:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 923:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 924:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 925:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 926:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 927:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 928:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 929:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 930:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 931:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            after the instruction has been completed.
 932:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 933:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 934:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 935:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 936:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 937:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 938:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 939:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 940:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 941:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 942:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 943:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 944:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 945:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 946:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 947:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 948:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 949:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 950:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 951:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Data Memory Barrier
 952:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 953:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 954:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 955:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 956:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 957:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 958:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 959:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 960:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 961:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 962:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 963:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 964:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    value  Value to reverse
 965:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Reversed value
 966:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 967:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 968:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 969:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 970:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return __builtin_bswap32(value);
 971:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
 972:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 973:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 974:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 975:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return result;
 976:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
 977:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 978:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 979:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 980:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 981:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 982:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 983:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    value  Value to reverse
 984:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Reversed value
 985:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
 986:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 987:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
 988:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
 989:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 990:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 991:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return result;
 992:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
 993:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 994:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
 995:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
 996:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 997:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 998:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    value  Value to reverse
 999:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Reversed value
1000:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
1001:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
1002:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
1003:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
1004:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
1005:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
1006:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   int16_t result;
1007:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
1008:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   __ASM ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
1009:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return result;
1010:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
1011:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
1012:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
1013:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
1014:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
1015:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Rotate Right in unsigned value (32 bit)
1016:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Rotate Right (immediate) provides the value of the contents of a register rotated by a v
1017:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    op1  Value to rotate
1018:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    op2  Number of Bits to rotate
1019:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Rotated value
1020:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
1021:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
1022:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
1023:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   op2 %= 32U;
1024:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   if (op2 == 0U)
1025:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   {
1026:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     return op1;
1027:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   }
1028:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return (op1 >> op2) | (op1 << (32U - op2));
1029:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
1030:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
1031:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
1032:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
1033:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Breakpoint
1034:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Causes the processor to enter Debug state.
1035:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****            Debug tools can use this to investigate system state when the instruction at a particula
1036:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    value  is ignored by the processor.
1037:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****                  If required, a debugger can use it to store additional information about the break
1038:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
1039:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
1040:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
1041:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
1042:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
1043:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Reverse bit order of value
1044:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Reverses the bit order of the given value.
1045:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]    value  Value to reverse
1046:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return               Reversed value
1047:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
1048:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
1049:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
1050:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t result;
1051:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
1052:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
1053:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
1054:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
1055:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
1056:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #else
1057:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
1058:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
1059:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   result = value;                      /* r will be reversed bits of v; first get LSB of v */
1060:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   for (value >>= 1U; value != 0U; value >>= 1U)
1061:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   {
1062:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     result <<= 1U;
1063:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     result |= value & 1U;
1064:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     s--;
1065:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   }
1066:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   result <<= s;                        /* shift when v's highest bits are zero */
1067:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** #endif
1068:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return result;
1069:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** }
1070:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
1071:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** 
1072:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** /**
1073:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \brief   Count leading zeros
1074:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \details Counts the number of leading zeros of a data value.
1075:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \param [in]  value  Value to count the leading zeros
1076:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   \return             number of leading zeros in value
1077:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****  */
1078:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** __STATIC_FORCEINLINE uint8_t __CLZ(uint32_t value)
1079:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h **** {
1080:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   /* Even though __builtin_clz produces a CLZ instruction on ARM, formally
1081:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      __builtin_clz(0) is undefined behaviour, so handle this case specially.
1082:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      This guarantees ARM-compatible results if happening to compile on a non-ARM
1083:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      target, and ensures the compiler doesn't decide to activate any
1084:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      optimisations using the logic "value was passed to __builtin_clz, so it
1085:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      is non-zero".
1086:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
1087:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****      single CLZ instruction.
1088:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****    */
1089:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   if (value == 0U)
 1305              	 .loc 3 1089 0
 1306 009a 7B69     	 ldr r3,[r7,#20]
 1307 009c 002B     	 cmp r3,#0
 1308 009e 01D1     	 bne .L63
1090:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   {
1091:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****     return 32U;
 1309              	 .loc 3 1091 0
 1310 00a0 2023     	 movs r3,#32
 1311 00a2 03E0     	 b .L64
 1312              	.L63:
1092:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   }
1093:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   return __builtin_clz(value);
 1313              	 .loc 3 1093 0
 1314 00a4 7B69     	 ldr r3,[r7,#20]
 1315 00a6 B3FA83F3 	 clz r3,r3
 1316 00aa DBB2     	 uxtb r3,r3
 1317              	.L64:
 1318              	.LBE13:
 1319              	.LBE12:
 1320              	 .loc 2 635 0
 1321 00ac BB61     	 str r3,[r7,#24]
 636:../Dave/Generated/CAPTURE/capture.c ****       period_val = period_val << norm_period_val;
 1322              	 .loc 2 636 0
 1323 00ae 3A69     	 ldr r2,[r7,#16]
 1324 00b0 BB69     	 ldr r3,[r7,#24]
 1325 00b2 02FA03F3 	 lsl r3,r2,r3
 1326 00b6 3B61     	 str r3,[r7,#16]
 637:../Dave/Generated/CAPTURE/capture.c ****       duty_val = duty_val << norm_period_val;
 1327              	 .loc 2 637 0
 1328 00b8 FA68     	 ldr r2,[r7,#12]
 1329 00ba BB69     	 ldr r3,[r7,#24]
 1330 00bc 02FA03F3 	 lsl r3,r2,r3
 1331 00c0 FB60     	 str r3,[r7,#12]
 638:../Dave/Generated/CAPTURE/capture.c **** 
 639:../Dave/Generated/CAPTURE/capture.c ****       period_val = period_val >> 7U;
 1332              	 .loc 2 639 0
 1333 00c2 3B69     	 ldr r3,[r7,#16]
 1334 00c4 DB09     	 lsrs r3,r3,#7
 1335 00c6 3B61     	 str r3,[r7,#16]
 640:../Dave/Generated/CAPTURE/capture.c ****       duty_val = duty_val >> 7U;
 1336              	 .loc 2 640 0
 1337 00c8 FB68     	 ldr r3,[r7,#12]
 1338 00ca DB09     	 lsrs r3,r3,#7
 1339 00cc FB60     	 str r3,[r7,#12]
 641:../Dave/Generated/CAPTURE/capture.c ****       if (period_val > 0U)
 1340              	 .loc 2 641 0
 1341 00ce 3B69     	 ldr r3,[r7,#16]
 1342 00d0 002B     	 cmp r3,#0
 1343 00d2 0CD0     	 beq .L65
 642:../Dave/Generated/CAPTURE/capture.c ****       {
 643:../Dave/Generated/CAPTURE/capture.c ****         /* Rounding Positive for Duty*/
 644:../Dave/Generated/CAPTURE/capture.c ****         *signal_duty = ((duty_val * 100U) + (period_val >> 1)) / period_val;
 1344              	 .loc 2 644 0
 1345 00d4 FB68     	 ldr r3,[r7,#12]
 1346 00d6 6422     	 movs r2,#100
 1347 00d8 02FB03F2 	 mul r2,r2,r3
 1348 00dc 3B69     	 ldr r3,[r7,#16]
 1349 00de 5B08     	 lsrs r3,r3,#1
 1350 00e0 1A44     	 add r2,r2,r3
 1351 00e2 3B69     	 ldr r3,[r7,#16]
 1352 00e4 B2FBF3F2 	 udiv r2,r2,r3
 1353 00e8 3B68     	 ldr r3,[r7]
 1354 00ea 1A60     	 str r2,[r3]
 1355 00ec 04E0     	 b .L66
 1356              	.L65:
 645:../Dave/Generated/CAPTURE/capture.c ****       }
 646:../Dave/Generated/CAPTURE/capture.c ****       else
 647:../Dave/Generated/CAPTURE/capture.c ****       {
 648:../Dave/Generated/CAPTURE/capture.c ****         *signal_duty = 0U;
 1357              	 .loc 2 648 0
 1358 00ee 3B68     	 ldr r3,[r7]
 1359 00f0 0022     	 movs r2,#0
 1360 00f2 1A60     	 str r2,[r3]
 649:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_STATUS_FAILURE;
 1361              	 .loc 2 649 0
 1362 00f4 0123     	 movs r3,#1
 1363 00f6 FB77     	 strb r3,[r7,#31]
 1364              	.L66:
 650:../Dave/Generated/CAPTURE/capture.c ****       }
 651:../Dave/Generated/CAPTURE/capture.c **** 
 652:../Dave/Generated/CAPTURE/capture.c ****       if (status1 == CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED)
 1365              	 .loc 2 652 0
 1366 00f8 BB7F     	 ldrb r3,[r7,#30]
 1367 00fa 022B     	 cmp r3,#2
 1368 00fc 02D1     	 bne .L67
 653:../Dave/Generated/CAPTURE/capture.c ****       {
 654:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED;
 1369              	 .loc 2 654 0
 1370 00fe 0223     	 movs r3,#2
 1371 0100 FB77     	 strb r3,[r7,#31]
 652:../Dave/Generated/CAPTURE/capture.c ****       {
 1372              	 .loc 2 652 0
 1373 0102 03E0     	 b .L68
 1374              	.L67:
 1375 0104 02E0     	 b .L68
 1376              	.L61:
 655:../Dave/Generated/CAPTURE/capture.c ****       }
 656:../Dave/Generated/CAPTURE/capture.c **** 
 657:../Dave/Generated/CAPTURE/capture.c ****     }
 658:../Dave/Generated/CAPTURE/capture.c ****     else
 659:../Dave/Generated/CAPTURE/capture.c ****     {
 660:../Dave/Generated/CAPTURE/capture.c ****       status = CAPTURE_STATUS_INVALID_CONFIG;
 1377              	 .loc 2 660 0
 1378 0106 0323     	 movs r3,#3
 1379 0108 FB77     	 strb r3,[r7,#31]
 1380 010a 02E0     	 b .L69
 1381              	.L68:
 1382 010c 01E0     	 b .L69
 1383              	.L59:
 661:../Dave/Generated/CAPTURE/capture.c ****     }
 662:../Dave/Generated/CAPTURE/capture.c ****   }
 663:../Dave/Generated/CAPTURE/capture.c ****   else
 664:../Dave/Generated/CAPTURE/capture.c ****   {
 665:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_STATUS_FAILURE;
 1384              	 .loc 2 665 0
 1385 010e 0123     	 movs r3,#1
 1386 0110 FB77     	 strb r3,[r7,#31]
 1387              	.L69:
 666:../Dave/Generated/CAPTURE/capture.c ****   }
 667:../Dave/Generated/CAPTURE/capture.c **** 
 668:../Dave/Generated/CAPTURE/capture.c ****   return (status);
 1388              	 .loc 2 668 0
 1389 0112 FB7F     	 ldrb r3,[r7,#31]
 669:../Dave/Generated/CAPTURE/capture.c **** }
 1390              	 .loc 2 669 0
 1391 0114 1846     	 mov r0,r3
 1392 0116 2037     	 adds r7,r7,#32
 1393              	.LCFI92:
 1394              	 .cfi_def_cfa_offset 8
 1395 0118 BD46     	 mov sp,r7
 1396              	.LCFI93:
 1397              	 .cfi_def_cfa_register 13
 1398              	 
 1399 011a 80BD     	 pop {r7,pc}
 1400              	 .cfi_endproc
 1401              	.LFE235:
 1403              	 .section .text.CAPTURE_GetPeriod,"ax",%progbits
 1404              	 .align 2
 1405              	 .global CAPTURE_GetPeriod
 1406              	 .thumb
 1407              	 .thumb_func
 1409              	CAPTURE_GetPeriod:
 1410              	.LFB236:
 670:../Dave/Generated/CAPTURE/capture.c **** 
 671:../Dave/Generated/CAPTURE/capture.c **** CAPTURE_STATUS_t CAPTURE_GetPeriod(const CAPTURE_t *const handler, uint32_t *const signal_period)
 672:../Dave/Generated/CAPTURE/capture.c **** {
 1411              	 .loc 2 672 0
 1412              	 .cfi_startproc
 1413              	 
 1414              	 
 1415 0000 80B5     	 push {r7,lr}
 1416              	.LCFI94:
 1417              	 .cfi_def_cfa_offset 8
 1418              	 .cfi_offset 7,-8
 1419              	 .cfi_offset 14,-4
 1420 0002 86B0     	 sub sp,sp,#24
 1421              	.LCFI95:
 1422              	 .cfi_def_cfa_offset 32
 1423 0004 00AF     	 add r7,sp,#0
 1424              	.LCFI96:
 1425              	 .cfi_def_cfa_register 7
 1426 0006 7860     	 str r0,[r7,#4]
 1427 0008 3960     	 str r1,[r7]
 673:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status = CAPTURE_STATUS_SUCCESS;
 1428              	 .loc 2 673 0
 1429 000a 0023     	 movs r3,#0
 1430 000c FB75     	 strb r3,[r7,#23]
 674:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status1 = CAPTURE_STATUS_SUCCESS;
 1431              	 .loc 2 674 0
 1432 000e 0023     	 movs r3,#0
 1433 0010 BB75     	 strb r3,[r7,#22]
 675:../Dave/Generated/CAPTURE/capture.c ****   uint32_t period_val = 0U;
 1434              	 .loc 2 675 0
 1435 0012 0023     	 movs r3,#0
 1436 0014 3B61     	 str r3,[r7,#16]
 676:../Dave/Generated/CAPTURE/capture.c ****   uint32_t duty_val = 0U;
 1437              	 .loc 2 676 0
 1438 0016 0023     	 movs r3,#0
 1439 0018 FB60     	 str r3,[r7,#12]
 677:../Dave/Generated/CAPTURE/capture.c **** 
 678:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetPeriod:handler NULL", (handler != NULL));
 679:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetPeriod:NULL data pointer", (signal_period != NULL));
 680:../Dave/Generated/CAPTURE/capture.c **** 
 681:../Dave/Generated/CAPTURE/capture.c ****   /* Check for APP instance is initialized or not */
 682:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->initialized)
 1440              	 .loc 2 682 0
 1441 001a 7B68     	 ldr r3,[r7,#4]
 1442 001c 93F83130 	 ldrb r3,[r3,#49]
 1443 0020 002B     	 cmp r3,#0
 1444 0022 42D0     	 beq .L72
 683:../Dave/Generated/CAPTURE/capture.c ****   {
 684:../Dave/Generated/CAPTURE/capture.c ****     if ((handler->capture_edge_config == CAPTURE_EDGE_RISE_TO_RISE) ||
 1445              	 .loc 2 684 0
 1446 0024 7B68     	 ldr r3,[r7,#4]
 1447 0026 93F82E30 	 ldrb r3,[r3,#46]
 1448 002a 002B     	 cmp r3,#0
 1449 002c 04D0     	 beq .L73
 685:../Dave/Generated/CAPTURE/capture.c ****         (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 1450              	 .loc 2 685 0 discriminator 1
 1451 002e 7B68     	 ldr r3,[r7,#4]
 1452 0030 93F82E30 	 ldrb r3,[r3,#46]
 684:../Dave/Generated/CAPTURE/capture.c ****         (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 1453              	 .loc 2 684 0 discriminator 1
 1454 0034 032B     	 cmp r3,#3
 1455 0036 34D1     	 bne .L74
 1456              	.L73:
 686:../Dave/Generated/CAPTURE/capture.c ****     {
 687:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 688:../Dave/Generated/CAPTURE/capture.c ****       if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 1457              	 .loc 2 688 0
 1458 0038 7B68     	 ldr r3,[r7,#4]
 1459 003a 93F82D30 	 ldrb r3,[r3,#45]
 1460 003e 002B     	 cmp r3,#0
 1461 0040 23D1     	 bne .L75
 689:../Dave/Generated/CAPTURE/capture.c ****       {
 690:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 1462              	 .loc 2 690 0
 1463 0042 7B68     	 ldr r3,[r7,#4]
 1464 0044 9A69     	 ldr r2,[r3,#24]
 1465 0046 07F11003 	 add r3,r7,#16
 1466 004a 1046     	 mov r0,r2
 1467 004c 0021     	 movs r1,#0
 1468 004e 1A46     	 mov r2,r3
 1469 0050 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 1470 0054 0346     	 mov r3,r0
 1471 0056 FB75     	 strb r3,[r7,#23]
 691:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU4_SLICE_CAP_REG_SET_LOW,
 692:../Dave/Generated/CAPTURE/capture.c ****                                                                   &period_val);
 693:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 1472              	 .loc 2 693 0
 1473 0058 7B68     	 ldr r3,[r7,#4]
 1474 005a 9A69     	 ldr r2,[r3,#24]
 1475 005c 07F10C03 	 add r3,r7,#12
 1476 0060 1046     	 mov r0,r2
 1477 0062 0121     	 movs r1,#1
 1478 0064 1A46     	 mov r2,r3
 1479 0066 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 1480 006a 0346     	 mov r3,r0
 1481 006c BB75     	 strb r3,[r7,#22]
 694:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU4_SLICE_CAP_REG_SET_HIGH,
 695:../Dave/Generated/CAPTURE/capture.c ****                                                                    &duty_val);
 696:../Dave/Generated/CAPTURE/capture.c **** 
 697:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &period_val, true);
 1482              	 .loc 2 697 0
 1483 006e 07F11003 	 add r3,r7,#16
 1484 0072 7868     	 ldr r0,[r7,#4]
 1485 0074 1946     	 mov r1,r3
 1486 0076 0122     	 movs r2,#1
 1487 0078 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 698:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &duty_val, false);
 1488              	 .loc 2 698 0
 1489 007c 07F10C03 	 add r3,r7,#12
 1490 0080 7868     	 ldr r0,[r7,#4]
 1491 0082 1946     	 mov r1,r3
 1492 0084 0022     	 movs r2,#0
 1493 0086 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 1494              	.L75:
 699:../Dave/Generated/CAPTURE/capture.c ****       }
 700:../Dave/Generated/CAPTURE/capture.c **** #endif
 701:../Dave/Generated/CAPTURE/capture.c **** 
 702:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
 703:../Dave/Generated/CAPTURE/capture.c ****       if (CAPTURE_MODULE_CCU8 == handler->capture_module)
 704:../Dave/Generated/CAPTURE/capture.c ****       {
 705:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 706:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU8_SLICE_CAP_REG_SET_LOW,
 707:../Dave/Generated/CAPTURE/capture.c ****                                                                   &period_val);
 708:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 709:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU8_SLICE_CAP_REG_SET_HIGH,
 710:../Dave/Generated/CAPTURE/capture.c ****                                                                    &duty_val);
 711:../Dave/Generated/CAPTURE/capture.c **** 
 712:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &period_val, true);
 713:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &duty_val, false);
 714:../Dave/Generated/CAPTURE/capture.c ****       }
 715:../Dave/Generated/CAPTURE/capture.c **** #endif
 716:../Dave/Generated/CAPTURE/capture.c ****       *signal_period = period_val + duty_val;
 1495              	 .loc 2 716 0
 1496 008a 3A69     	 ldr r2,[r7,#16]
 1497 008c FB68     	 ldr r3,[r7,#12]
 1498 008e 1A44     	 add r2,r2,r3
 1499 0090 3B68     	 ldr r3,[r7]
 1500 0092 1A60     	 str r2,[r3]
 717:../Dave/Generated/CAPTURE/capture.c **** 
 718:../Dave/Generated/CAPTURE/capture.c ****       if (status1 == CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED)
 1501              	 .loc 2 718 0
 1502 0094 BB7D     	 ldrb r3,[r7,#22]
 1503 0096 022B     	 cmp r3,#2
 1504 0098 02D1     	 bne .L76
 719:../Dave/Generated/CAPTURE/capture.c ****       {
 720:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED;
 1505              	 .loc 2 720 0
 1506 009a 0223     	 movs r3,#2
 1507 009c FB75     	 strb r3,[r7,#23]
 718:../Dave/Generated/CAPTURE/capture.c ****       {
 1508              	 .loc 2 718 0
 1509 009e 03E0     	 b .L77
 1510              	.L76:
 1511 00a0 02E0     	 b .L77
 1512              	.L74:
 721:../Dave/Generated/CAPTURE/capture.c ****       }
 722:../Dave/Generated/CAPTURE/capture.c ****     }
 723:../Dave/Generated/CAPTURE/capture.c ****     else
 724:../Dave/Generated/CAPTURE/capture.c ****     {
 725:../Dave/Generated/CAPTURE/capture.c ****       status = CAPTURE_STATUS_INVALID_CONFIG;
 1513              	 .loc 2 725 0
 1514 00a2 0323     	 movs r3,#3
 1515 00a4 FB75     	 strb r3,[r7,#23]
 1516 00a6 02E0     	 b .L78
 1517              	.L77:
 1518 00a8 01E0     	 b .L78
 1519              	.L72:
 726:../Dave/Generated/CAPTURE/capture.c ****     }
 727:../Dave/Generated/CAPTURE/capture.c ****   }
 728:../Dave/Generated/CAPTURE/capture.c ****   else
 729:../Dave/Generated/CAPTURE/capture.c ****   {
 730:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_STATUS_FAILURE;
 1520              	 .loc 2 730 0
 1521 00aa 0123     	 movs r3,#1
 1522 00ac FB75     	 strb r3,[r7,#23]
 1523              	.L78:
 731:../Dave/Generated/CAPTURE/capture.c ****   }
 732:../Dave/Generated/CAPTURE/capture.c **** 
 733:../Dave/Generated/CAPTURE/capture.c ****   return (status);
 1524              	 .loc 2 733 0
 1525 00ae FB7D     	 ldrb r3,[r7,#23]
 734:../Dave/Generated/CAPTURE/capture.c **** }
 1526              	 .loc 2 734 0
 1527 00b0 1846     	 mov r0,r3
 1528 00b2 1837     	 adds r7,r7,#24
 1529              	.LCFI97:
 1530              	 .cfi_def_cfa_offset 8
 1531 00b4 BD46     	 mov sp,r7
 1532              	.LCFI98:
 1533              	 .cfi_def_cfa_register 13
 1534              	 
 1535 00b6 80BD     	 pop {r7,pc}
 1536              	 .cfi_endproc
 1537              	.LFE236:
 1539              	 .section .text.CAPTURE_GetPeriodInNanoSec,"ax",%progbits
 1540              	 .align 2
 1541              	 .global CAPTURE_GetPeriodInNanoSec
 1542              	 .thumb
 1543              	 .thumb_func
 1545              	CAPTURE_GetPeriodInNanoSec:
 1546              	.LFB237:
 735:../Dave/Generated/CAPTURE/capture.c **** 
 736:../Dave/Generated/CAPTURE/capture.c **** CAPTURE_STATUS_t CAPTURE_GetPeriodInNanoSec(const CAPTURE_t *const handler,
 737:../Dave/Generated/CAPTURE/capture.c ****                                             uint32_t *const signal_period)
 738:../Dave/Generated/CAPTURE/capture.c **** {
 1547              	 .loc 2 738 0
 1548              	 .cfi_startproc
 1549              	 
 1550              	 
 1551 0000 80B5     	 push {r7,lr}
 1552              	.LCFI99:
 1553              	 .cfi_def_cfa_offset 8
 1554              	 .cfi_offset 7,-8
 1555              	 .cfi_offset 14,-4
 1556 0002 86B0     	 sub sp,sp,#24
 1557              	.LCFI100:
 1558              	 .cfi_def_cfa_offset 32
 1559 0004 00AF     	 add r7,sp,#0
 1560              	.LCFI101:
 1561              	 .cfi_def_cfa_register 7
 1562 0006 7860     	 str r0,[r7,#4]
 1563 0008 3960     	 str r1,[r7]
 739:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status = CAPTURE_STATUS_SUCCESS;
 1564              	 .loc 2 739 0
 1565 000a 0023     	 movs r3,#0
 1566 000c FB75     	 strb r3,[r7,#23]
 740:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status1 = CAPTURE_STATUS_SUCCESS;
 1567              	 .loc 2 740 0
 1568 000e 0023     	 movs r3,#0
 1569 0010 BB75     	 strb r3,[r7,#22]
 741:../Dave/Generated/CAPTURE/capture.c ****   uint32_t period_val = 0U;
 1570              	 .loc 2 741 0
 1571 0012 0023     	 movs r3,#0
 1572 0014 3B61     	 str r3,[r7,#16]
 742:../Dave/Generated/CAPTURE/capture.c ****   uint32_t duty_val = 0U;
 1573              	 .loc 2 742 0
 1574 0016 0023     	 movs r3,#0
 1575 0018 FB60     	 str r3,[r7,#12]
 743:../Dave/Generated/CAPTURE/capture.c **** 
 744:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetPeriodInNanoSec:handler NULL", (handler != NULL));
 745:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetPeriodInNanoSec:NULL data pointer", (signal_period != NULL));
 746:../Dave/Generated/CAPTURE/capture.c **** 
 747:../Dave/Generated/CAPTURE/capture.c ****   /* Check for APP instance is initialized or not */
 748:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->initialized)
 1576              	 .loc 2 748 0
 1577 001a 7B68     	 ldr r3,[r7,#4]
 1578 001c 93F83130 	 ldrb r3,[r3,#49]
 1579 0020 002B     	 cmp r3,#0
 1580 0022 50D0     	 beq .L81
 749:../Dave/Generated/CAPTURE/capture.c ****   {
 750:../Dave/Generated/CAPTURE/capture.c ****     if ((handler->capture_edge_config == CAPTURE_EDGE_RISE_TO_RISE) ||
 1581              	 .loc 2 750 0
 1582 0024 7B68     	 ldr r3,[r7,#4]
 1583 0026 93F82E30 	 ldrb r3,[r3,#46]
 1584 002a 002B     	 cmp r3,#0
 1585 002c 04D0     	 beq .L82
 751:../Dave/Generated/CAPTURE/capture.c ****         (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 1586              	 .loc 2 751 0 discriminator 1
 1587 002e 7B68     	 ldr r3,[r7,#4]
 1588 0030 93F82E30 	 ldrb r3,[r3,#46]
 750:../Dave/Generated/CAPTURE/capture.c ****         (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 1589              	 .loc 2 750 0 discriminator 1
 1590 0034 032B     	 cmp r3,#3
 1591 0036 42D1     	 bne .L83
 1592              	.L82:
 752:../Dave/Generated/CAPTURE/capture.c ****     {
 753:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 754:../Dave/Generated/CAPTURE/capture.c ****       if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 1593              	 .loc 2 754 0
 1594 0038 7B68     	 ldr r3,[r7,#4]
 1595 003a 93F82D30 	 ldrb r3,[r3,#45]
 1596 003e 002B     	 cmp r3,#0
 1597 0040 31D1     	 bne .L84
 755:../Dave/Generated/CAPTURE/capture.c ****       {
 756:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 1598              	 .loc 2 756 0
 1599 0042 7B68     	 ldr r3,[r7,#4]
 1600 0044 9A69     	 ldr r2,[r3,#24]
 1601 0046 07F11003 	 add r3,r7,#16
 1602 004a 1046     	 mov r0,r2
 1603 004c 0021     	 movs r1,#0
 1604 004e 1A46     	 mov r2,r3
 1605 0050 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 1606 0054 0346     	 mov r3,r0
 1607 0056 FB75     	 strb r3,[r7,#23]
 757:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU4_SLICE_CAP_REG_SET_LOW,
 758:../Dave/Generated/CAPTURE/capture.c ****                                                                   &period_val);
 759:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue(handler, &period_val, true);
 1608              	 .loc 2 759 0
 1609 0058 07F11003 	 add r3,r7,#16
 1610 005c 7868     	 ldr r0,[r7,#4]
 1611 005e 1946     	 mov r1,r3
 1612 0060 0122     	 movs r2,#1
 1613 0062 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 760:../Dave/Generated/CAPTURE/capture.c ****         period_val = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, period_val);
 1614              	 .loc 2 760 0
 1615 0066 3B69     	 ldr r3,[r7,#16]
 1616 0068 7868     	 ldr r0,[r7,#4]
 1617 006a 1946     	 mov r1,r3
 1618 006c FFF7FEFF 	 bl CAPTURE_lCalculateTimeInNanoSecFromTimerTick
 1619 0070 0346     	 mov r3,r0
 1620 0072 3B61     	 str r3,[r7,#16]
 761:../Dave/Generated/CAPTURE/capture.c **** 
 762:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 1621              	 .loc 2 762 0
 1622 0074 7B68     	 ldr r3,[r7,#4]
 1623 0076 9A69     	 ldr r2,[r3,#24]
 1624 0078 07F10C03 	 add r3,r7,#12
 1625 007c 1046     	 mov r0,r2
 1626 007e 0121     	 movs r1,#1
 1627 0080 1A46     	 mov r2,r3
 1628 0082 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 1629 0086 0346     	 mov r3,r0
 1630 0088 BB75     	 strb r3,[r7,#22]
 763:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU4_SLICE_CAP_REG_SET_HIGH,
 764:../Dave/Generated/CAPTURE/capture.c ****                                                                    &duty_val);
 765:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue(handler, &duty_val, false);
 1631              	 .loc 2 765 0
 1632 008a 07F10C03 	 add r3,r7,#12
 1633 008e 7868     	 ldr r0,[r7,#4]
 1634 0090 1946     	 mov r1,r3
 1635 0092 0022     	 movs r2,#0
 1636 0094 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 766:../Dave/Generated/CAPTURE/capture.c ****         duty_val = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, duty_val);
 1637              	 .loc 2 766 0
 1638 0098 FB68     	 ldr r3,[r7,#12]
 1639 009a 7868     	 ldr r0,[r7,#4]
 1640 009c 1946     	 mov r1,r3
 1641 009e FFF7FEFF 	 bl CAPTURE_lCalculateTimeInNanoSecFromTimerTick
 1642 00a2 0346     	 mov r3,r0
 1643 00a4 FB60     	 str r3,[r7,#12]
 1644              	.L84:
 767:../Dave/Generated/CAPTURE/capture.c ****       }
 768:../Dave/Generated/CAPTURE/capture.c **** #endif
 769:../Dave/Generated/CAPTURE/capture.c **** 
 770:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
 771:../Dave/Generated/CAPTURE/capture.c ****       if (CAPTURE_MODULE_CCU8 == handler->capture_module)
 772:../Dave/Generated/CAPTURE/capture.c ****       {
 773:../Dave/Generated/CAPTURE/capture.c ****         status =  CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 774:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU8_SLICE_CAP_REG_SET_LOW,
 775:../Dave/Generated/CAPTURE/capture.c ****                                                                    &period_val);
 776:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue(handler, &period_val, true);
 777:../Dave/Generated/CAPTURE/capture.c ****         period_val = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, period_val);
 778:../Dave/Generated/CAPTURE/capture.c **** 
 779:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 780:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU8_SLICE_CAP_REG_SET_HIGH,
 781:../Dave/Generated/CAPTURE/capture.c ****                                                                    &duty_val);
 782:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue(handler, &duty_val, false);
 783:../Dave/Generated/CAPTURE/capture.c ****         duty_val = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, duty_val);
 784:../Dave/Generated/CAPTURE/capture.c ****       }
 785:../Dave/Generated/CAPTURE/capture.c **** #endif
 786:../Dave/Generated/CAPTURE/capture.c ****       *signal_period = period_val + duty_val;
 1645              	 .loc 2 786 0
 1646 00a6 3A69     	 ldr r2,[r7,#16]
 1647 00a8 FB68     	 ldr r3,[r7,#12]
 1648 00aa 1A44     	 add r2,r2,r3
 1649 00ac 3B68     	 ldr r3,[r7]
 1650 00ae 1A60     	 str r2,[r3]
 787:../Dave/Generated/CAPTURE/capture.c **** 
 788:../Dave/Generated/CAPTURE/capture.c ****       if (status1 == CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED)
 1651              	 .loc 2 788 0
 1652 00b0 BB7D     	 ldrb r3,[r7,#22]
 1653 00b2 022B     	 cmp r3,#2
 1654 00b4 02D1     	 bne .L85
 789:../Dave/Generated/CAPTURE/capture.c ****       {
 790:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED;
 1655              	 .loc 2 790 0
 1656 00b6 0223     	 movs r3,#2
 1657 00b8 FB75     	 strb r3,[r7,#23]
 788:../Dave/Generated/CAPTURE/capture.c ****       {
 1658              	 .loc 2 788 0
 1659 00ba 03E0     	 b .L86
 1660              	.L85:
 1661 00bc 02E0     	 b .L86
 1662              	.L83:
 791:../Dave/Generated/CAPTURE/capture.c ****       }
 792:../Dave/Generated/CAPTURE/capture.c ****     }
 793:../Dave/Generated/CAPTURE/capture.c ****     else
 794:../Dave/Generated/CAPTURE/capture.c ****     {
 795:../Dave/Generated/CAPTURE/capture.c ****       status = CAPTURE_STATUS_INVALID_CONFIG;
 1663              	 .loc 2 795 0
 1664 00be 0323     	 movs r3,#3
 1665 00c0 FB75     	 strb r3,[r7,#23]
 1666 00c2 02E0     	 b .L87
 1667              	.L86:
 1668 00c4 01E0     	 b .L87
 1669              	.L81:
 796:../Dave/Generated/CAPTURE/capture.c ****     }
 797:../Dave/Generated/CAPTURE/capture.c ****   }
 798:../Dave/Generated/CAPTURE/capture.c ****   else
 799:../Dave/Generated/CAPTURE/capture.c ****   {
 800:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_STATUS_FAILURE;
 1670              	 .loc 2 800 0
 1671 00c6 0123     	 movs r3,#1
 1672 00c8 FB75     	 strb r3,[r7,#23]
 1673              	.L87:
 801:../Dave/Generated/CAPTURE/capture.c ****   }
 802:../Dave/Generated/CAPTURE/capture.c **** 
 803:../Dave/Generated/CAPTURE/capture.c ****   return (status);
 1674              	 .loc 2 803 0
 1675 00ca FB7D     	 ldrb r3,[r7,#23]
 804:../Dave/Generated/CAPTURE/capture.c **** }
 1676              	 .loc 2 804 0
 1677 00cc 1846     	 mov r0,r3
 1678 00ce 1837     	 adds r7,r7,#24
 1679              	.LCFI102:
 1680              	 .cfi_def_cfa_offset 8
 1681 00d0 BD46     	 mov sp,r7
 1682              	.LCFI103:
 1683              	 .cfi_def_cfa_register 13
 1684              	 
 1685 00d2 80BD     	 pop {r7,pc}
 1686              	 .cfi_endproc
 1687              	.LFE237:
 1689              	 .section .text.CAPTURE_GetPeriodDutyCycle,"ax",%progbits
 1690              	 .align 2
 1691              	 .global CAPTURE_GetPeriodDutyCycle
 1692              	 .thumb
 1693              	 .thumb_func
 1695              	CAPTURE_GetPeriodDutyCycle:
 1696              	.LFB238:
 805:../Dave/Generated/CAPTURE/capture.c **** 
 806:../Dave/Generated/CAPTURE/capture.c **** CAPTURE_STATUS_t CAPTURE_GetPeriodDutyCycle(const CAPTURE_t *const handler,
 807:../Dave/Generated/CAPTURE/capture.c ****                                             uint32_t *const signal_period,
 808:../Dave/Generated/CAPTURE/capture.c ****                                             uint32_t *const signal_duty)
 809:../Dave/Generated/CAPTURE/capture.c **** {
 1697              	 .loc 2 809 0
 1698              	 .cfi_startproc
 1699              	 
 1700              	 
 1701 0000 80B5     	 push {r7,lr}
 1702              	.LCFI104:
 1703              	 .cfi_def_cfa_offset 8
 1704              	 .cfi_offset 7,-8
 1705              	 .cfi_offset 14,-4
 1706 0002 88B0     	 sub sp,sp,#32
 1707              	.LCFI105:
 1708              	 .cfi_def_cfa_offset 40
 1709 0004 00AF     	 add r7,sp,#0
 1710              	.LCFI106:
 1711              	 .cfi_def_cfa_register 7
 1712 0006 F860     	 str r0,[r7,#12]
 1713 0008 B960     	 str r1,[r7,#8]
 1714 000a 7A60     	 str r2,[r7,#4]
 810:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status = CAPTURE_STATUS_SUCCESS;
 1715              	 .loc 2 810 0
 1716 000c 0023     	 movs r3,#0
 1717 000e FB77     	 strb r3,[r7,#31]
 811:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status1 = CAPTURE_STATUS_SUCCESS;
 1718              	 .loc 2 811 0
 1719 0010 0023     	 movs r3,#0
 1720 0012 BB77     	 strb r3,[r7,#30]
 812:../Dave/Generated/CAPTURE/capture.c ****   uint32_t period_val = 0U;
 1721              	 .loc 2 812 0
 1722 0014 0023     	 movs r3,#0
 1723 0016 BB61     	 str r3,[r7,#24]
 813:../Dave/Generated/CAPTURE/capture.c ****   uint32_t duty_val = 0U;
 1724              	 .loc 2 813 0
 1725 0018 0023     	 movs r3,#0
 1726 001a 7B61     	 str r3,[r7,#20]
 814:../Dave/Generated/CAPTURE/capture.c **** 
 815:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetPeriodDutyCycle:handler NULL", (handler != NULL));
 816:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetPeriodDutyCycle:NULL data pointer", (signal_period != NULL));
 817:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetPeriodDutyCycle:NULL data pointer", (signal_duty != NULL));
 818:../Dave/Generated/CAPTURE/capture.c **** 
 819:../Dave/Generated/CAPTURE/capture.c ****   /* Check for APP instance is initialized or not */
 820:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->initialized)
 1727              	 .loc 2 820 0
 1728 001c FB68     	 ldr r3,[r7,#12]
 1729 001e 93F83130 	 ldrb r3,[r3,#49]
 1730 0022 002B     	 cmp r3,#0
 1731 0024 47D0     	 beq .L90
 821:../Dave/Generated/CAPTURE/capture.c ****   {
 822:../Dave/Generated/CAPTURE/capture.c ****     if ((handler->capture_edge_config == CAPTURE_EDGE_RISE_TO_RISE) ||
 1732              	 .loc 2 822 0
 1733 0026 FB68     	 ldr r3,[r7,#12]
 1734 0028 93F82E30 	 ldrb r3,[r3,#46]
 1735 002c 002B     	 cmp r3,#0
 1736 002e 04D0     	 beq .L91
 823:../Dave/Generated/CAPTURE/capture.c ****         (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 1737              	 .loc 2 823 0 discriminator 1
 1738 0030 FB68     	 ldr r3,[r7,#12]
 1739 0032 93F82E30 	 ldrb r3,[r3,#46]
 822:../Dave/Generated/CAPTURE/capture.c ****         (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 1740              	 .loc 2 822 0 discriminator 1
 1741 0036 032B     	 cmp r3,#3
 1742 0038 39D1     	 bne .L92
 1743              	.L91:
 824:../Dave/Generated/CAPTURE/capture.c ****     {
 825:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 826:../Dave/Generated/CAPTURE/capture.c ****       if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 1744              	 .loc 2 826 0
 1745 003a FB68     	 ldr r3,[r7,#12]
 1746 003c 93F82D30 	 ldrb r3,[r3,#45]
 1747 0040 002B     	 cmp r3,#0
 1748 0042 23D1     	 bne .L93
 827:../Dave/Generated/CAPTURE/capture.c ****       {
 828:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 1749              	 .loc 2 828 0
 1750 0044 FB68     	 ldr r3,[r7,#12]
 1751 0046 9A69     	 ldr r2,[r3,#24]
 1752 0048 07F11803 	 add r3,r7,#24
 1753 004c 1046     	 mov r0,r2
 1754 004e 0021     	 movs r1,#0
 1755 0050 1A46     	 mov r2,r3
 1756 0052 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 1757 0056 0346     	 mov r3,r0
 1758 0058 FB77     	 strb r3,[r7,#31]
 829:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU4_SLICE_CAP_REG_SET_LOW,
 830:../Dave/Generated/CAPTURE/capture.c ****                                                                   &period_val);
 831:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &period_val, true);
 1759              	 .loc 2 831 0
 1760 005a 07F11803 	 add r3,r7,#24
 1761 005e F868     	 ldr r0,[r7,#12]
 1762 0060 1946     	 mov r1,r3
 1763 0062 0122     	 movs r2,#1
 1764 0064 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 832:../Dave/Generated/CAPTURE/capture.c **** 
 833:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 1765              	 .loc 2 833 0
 1766 0068 FB68     	 ldr r3,[r7,#12]
 1767 006a 9A69     	 ldr r2,[r3,#24]
 1768 006c 07F11403 	 add r3,r7,#20
 1769 0070 1046     	 mov r0,r2
 1770 0072 0121     	 movs r1,#1
 1771 0074 1A46     	 mov r2,r3
 1772 0076 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 1773 007a 0346     	 mov r3,r0
 1774 007c BB77     	 strb r3,[r7,#30]
 834:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU4_SLICE_CAP_REG_SET_HIGH,
 835:../Dave/Generated/CAPTURE/capture.c ****                                                                    &duty_val);
 836:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &duty_val, false);
 1775              	 .loc 2 836 0
 1776 007e 07F11403 	 add r3,r7,#20
 1777 0082 F868     	 ldr r0,[r7,#12]
 1778 0084 1946     	 mov r1,r3
 1779 0086 0022     	 movs r2,#0
 1780 0088 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 1781              	.L93:
 837:../Dave/Generated/CAPTURE/capture.c ****       }
 838:../Dave/Generated/CAPTURE/capture.c **** #endif
 839:../Dave/Generated/CAPTURE/capture.c **** 
 840:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
 841:../Dave/Generated/CAPTURE/capture.c ****       if (CAPTURE_MODULE_CCU8 == handler->capture_module)
 842:../Dave/Generated/CAPTURE/capture.c ****       {
 843:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 844:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU8_SLICE_CAP_REG_SET_LOW,
 845:../Dave/Generated/CAPTURE/capture.c ****                                                                   &period_val);
 846:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &period_val, true);
 847:../Dave/Generated/CAPTURE/capture.c **** 
 848:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 849:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU8_SLICE_CAP_REG_SET_HIGH,
 850:../Dave/Generated/CAPTURE/capture.c ****                                                                    &duty_val);
 851:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &duty_val, false);
 852:../Dave/Generated/CAPTURE/capture.c ****       }
 853:../Dave/Generated/CAPTURE/capture.c **** #endif
 854:../Dave/Generated/CAPTURE/capture.c **** 
 855:../Dave/Generated/CAPTURE/capture.c ****       period_val = period_val + duty_val;
 1782              	 .loc 2 855 0
 1783 008c BA69     	 ldr r2,[r7,#24]
 1784 008e 7B69     	 ldr r3,[r7,#20]
 1785 0090 1344     	 add r3,r3,r2
 1786 0092 BB61     	 str r3,[r7,#24]
 856:../Dave/Generated/CAPTURE/capture.c ****       *signal_duty = duty_val;
 1787              	 .loc 2 856 0
 1788 0094 7A69     	 ldr r2,[r7,#20]
 1789 0096 7B68     	 ldr r3,[r7,#4]
 1790 0098 1A60     	 str r2,[r3]
 857:../Dave/Generated/CAPTURE/capture.c ****       *signal_period = period_val;
 1791              	 .loc 2 857 0
 1792 009a BA69     	 ldr r2,[r7,#24]
 1793 009c BB68     	 ldr r3,[r7,#8]
 1794 009e 1A60     	 str r2,[r3]
 858:../Dave/Generated/CAPTURE/capture.c **** 
 859:../Dave/Generated/CAPTURE/capture.c ****       if (status1 == CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED)
 1795              	 .loc 2 859 0
 1796 00a0 BB7F     	 ldrb r3,[r7,#30]
 1797 00a2 022B     	 cmp r3,#2
 1798 00a4 02D1     	 bne .L94
 860:../Dave/Generated/CAPTURE/capture.c ****       {
 861:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED;
 1799              	 .loc 2 861 0
 1800 00a6 0223     	 movs r3,#2
 1801 00a8 FB77     	 strb r3,[r7,#31]
 859:../Dave/Generated/CAPTURE/capture.c ****       {
 1802              	 .loc 2 859 0
 1803 00aa 03E0     	 b .L95
 1804              	.L94:
 1805 00ac 02E0     	 b .L95
 1806              	.L92:
 862:../Dave/Generated/CAPTURE/capture.c ****       }
 863:../Dave/Generated/CAPTURE/capture.c ****     }
 864:../Dave/Generated/CAPTURE/capture.c ****     else
 865:../Dave/Generated/CAPTURE/capture.c ****     {
 866:../Dave/Generated/CAPTURE/capture.c ****       status = CAPTURE_STATUS_INVALID_CONFIG;
 1807              	 .loc 2 866 0
 1808 00ae 0323     	 movs r3,#3
 1809 00b0 FB77     	 strb r3,[r7,#31]
 1810 00b2 02E0     	 b .L96
 1811              	.L95:
 1812 00b4 01E0     	 b .L96
 1813              	.L90:
 867:../Dave/Generated/CAPTURE/capture.c ****     }
 868:../Dave/Generated/CAPTURE/capture.c ****   }
 869:../Dave/Generated/CAPTURE/capture.c ****   else
 870:../Dave/Generated/CAPTURE/capture.c ****   {
 871:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_STATUS_FAILURE;
 1814              	 .loc 2 871 0
 1815 00b6 0123     	 movs r3,#1
 1816 00b8 FB77     	 strb r3,[r7,#31]
 1817              	.L96:
 872:../Dave/Generated/CAPTURE/capture.c ****   }
 873:../Dave/Generated/CAPTURE/capture.c **** 
 874:../Dave/Generated/CAPTURE/capture.c ****   return (status);
 1818              	 .loc 2 874 0
 1819 00ba FB7F     	 ldrb r3,[r7,#31]
 875:../Dave/Generated/CAPTURE/capture.c **** }
 1820              	 .loc 2 875 0
 1821 00bc 1846     	 mov r0,r3
 1822 00be 2037     	 adds r7,r7,#32
 1823              	.LCFI107:
 1824              	 .cfi_def_cfa_offset 8
 1825 00c0 BD46     	 mov sp,r7
 1826              	.LCFI108:
 1827              	 .cfi_def_cfa_register 13
 1828              	 
 1829 00c2 80BD     	 pop {r7,pc}
 1830              	 .cfi_endproc
 1831              	.LFE238:
 1833              	 .section .text.CAPTURE_GetPeriodInNanoSecDutyCycleInPercentage,"ax",%progbits
 1834              	 .align 2
 1835              	 .global CAPTURE_GetPeriodInNanoSecDutyCycleInPercentage
 1836              	 .thumb
 1837              	 .thumb_func
 1839              	CAPTURE_GetPeriodInNanoSecDutyCycleInPercentage:
 1840              	.LFB239:
 876:../Dave/Generated/CAPTURE/capture.c **** 
 877:../Dave/Generated/CAPTURE/capture.c **** CAPTURE_STATUS_t CAPTURE_GetPeriodInNanoSecDutyCycleInPercentage(const CAPTURE_t *const handler,
 878:../Dave/Generated/CAPTURE/capture.c ****                                                                  uint32_t *const signal_period,
 879:../Dave/Generated/CAPTURE/capture.c ****                                                                  uint32_t *const signal_duty)
 880:../Dave/Generated/CAPTURE/capture.c **** {
 1841              	 .loc 2 880 0
 1842              	 .cfi_startproc
 1843              	 
 1844              	 
 1845 0000 80B5     	 push {r7,lr}
 1846              	.LCFI109:
 1847              	 .cfi_def_cfa_offset 8
 1848              	 .cfi_offset 7,-8
 1849              	 .cfi_offset 14,-4
 1850 0002 8CB0     	 sub sp,sp,#48
 1851              	.LCFI110:
 1852              	 .cfi_def_cfa_offset 56
 1853 0004 00AF     	 add r7,sp,#0
 1854              	.LCFI111:
 1855              	 .cfi_def_cfa_register 7
 1856 0006 F860     	 str r0,[r7,#12]
 1857 0008 B960     	 str r1,[r7,#8]
 1858 000a 7A60     	 str r2,[r7,#4]
 881:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status = CAPTURE_STATUS_SUCCESS;
 1859              	 .loc 2 881 0
 1860 000c 0023     	 movs r3,#0
 1861 000e 87F82F30 	 strb r3,[r7,#47]
 882:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t status1 = CAPTURE_STATUS_SUCCESS;
 1862              	 .loc 2 882 0
 1863 0012 0023     	 movs r3,#0
 1864 0014 87F82E30 	 strb r3,[r7,#46]
 883:../Dave/Generated/CAPTURE/capture.c ****   uint32_t period_val = 0U;
 1865              	 .loc 2 883 0
 1866 0018 0023     	 movs r3,#0
 1867 001a BB61     	 str r3,[r7,#24]
 884:../Dave/Generated/CAPTURE/capture.c ****   uint32_t duty_val = 0U;
 1868              	 .loc 2 884 0
 1869 001c 0023     	 movs r3,#0
 1870 001e 7B61     	 str r3,[r7,#20]
 885:../Dave/Generated/CAPTURE/capture.c ****   uint32_t period_val_nanosec = 0U;
 1871              	 .loc 2 885 0
 1872 0020 0023     	 movs r3,#0
 1873 0022 BB62     	 str r3,[r7,#40]
 886:../Dave/Generated/CAPTURE/capture.c ****   uint32_t duty_val_nanosec = 0U;
 1874              	 .loc 2 886 0
 1875 0024 0023     	 movs r3,#0
 1876 0026 7B62     	 str r3,[r7,#36]
 887:../Dave/Generated/CAPTURE/capture.c ****   uint32_t norm_period_val = 0U;
 1877              	 .loc 2 887 0
 1878 0028 0023     	 movs r3,#0
 1879 002a 3B62     	 str r3,[r7,#32]
 888:../Dave/Generated/CAPTURE/capture.c **** 
 889:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetPeriodInNanoSecDutyCycleInPercentage:handler NULL", (handler != NULL));
 890:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetPeriodInNanoSecDutyCycleInPercentage:NULL data pointer", (signal_period !
 891:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_GetPeriodInNanoSecDutyCycleInPercentage:NULL data pointer", (signal_duty != 
 892:../Dave/Generated/CAPTURE/capture.c **** 
 893:../Dave/Generated/CAPTURE/capture.c ****   /* Check for APP instance is initialized or not */
 894:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->initialized)
 1880              	 .loc 2 894 0
 1881 002c FB68     	 ldr r3,[r7,#12]
 1882 002e 93F83130 	 ldrb r3,[r3,#49]
 1883 0032 002B     	 cmp r3,#0
 1884 0034 00F08C80 	 beq .L99
 895:../Dave/Generated/CAPTURE/capture.c ****   {
 896:../Dave/Generated/CAPTURE/capture.c ****     if ((handler->capture_edge_config == CAPTURE_EDGE_RISE_TO_RISE) ||
 1885              	 .loc 2 896 0
 1886 0038 FB68     	 ldr r3,[r7,#12]
 1887 003a 93F82E30 	 ldrb r3,[r3,#46]
 1888 003e 002B     	 cmp r3,#0
 1889 0040 04D0     	 beq .L100
 897:../Dave/Generated/CAPTURE/capture.c ****         (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 1890              	 .loc 2 897 0 discriminator 1
 1891 0042 FB68     	 ldr r3,[r7,#12]
 1892 0044 93F82E30 	 ldrb r3,[r3,#46]
 896:../Dave/Generated/CAPTURE/capture.c ****         (handler->capture_edge_config == CAPTURE_EDGE_FALL_TO_FALL))
 1893              	 .loc 2 896 0 discriminator 1
 1894 0048 032B     	 cmp r3,#3
 1895 004a 7CD1     	 bne .L101
 1896              	.L100:
 898:../Dave/Generated/CAPTURE/capture.c ****     {
 899:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 900:../Dave/Generated/CAPTURE/capture.c ****       if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 1897              	 .loc 2 900 0
 1898 004c FB68     	 ldr r3,[r7,#12]
 1899 004e 93F82D30 	 ldrb r3,[r3,#45]
 1900 0052 002B     	 cmp r3,#0
 1901 0054 31D1     	 bne .L102
 901:../Dave/Generated/CAPTURE/capture.c ****       {
 902:../Dave/Generated/CAPTURE/capture.c ****         status = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 1902              	 .loc 2 902 0
 1903 0056 FB68     	 ldr r3,[r7,#12]
 1904 0058 9A69     	 ldr r2,[r3,#24]
 1905 005a 07F11803 	 add r3,r7,#24
 1906 005e 1046     	 mov r0,r2
 1907 0060 0021     	 movs r1,#0
 1908 0062 1A46     	 mov r2,r3
 1909 0064 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 1910 0068 0346     	 mov r3,r0
 1911 006a 87F82F30 	 strb r3,[r7,#47]
 903:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU4_SLICE_CAP_REG_SET_LOW,
 904:../Dave/Generated/CAPTURE/capture.c ****                                                                   &period_val);
 905:../Dave/Generated/CAPTURE/capture.c **** 
 906:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &period_val, true);
 1912              	 .loc 2 906 0
 1913 006e 07F11803 	 add r3,r7,#24
 1914 0072 F868     	 ldr r0,[r7,#12]
 1915 0074 1946     	 mov r1,r3
 1916 0076 0122     	 movs r2,#1
 1917 0078 FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 907:../Dave/Generated/CAPTURE/capture.c ****         period_val_nanosec = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, period_val);
 1918              	 .loc 2 907 0
 1919 007c BB69     	 ldr r3,[r7,#24]
 1920 007e F868     	 ldr r0,[r7,#12]
 1921 0080 1946     	 mov r1,r3
 1922 0082 FFF7FEFF 	 bl CAPTURE_lCalculateTimeInNanoSecFromTimerTick
 1923 0086 B862     	 str r0,[r7,#40]
 908:../Dave/Generated/CAPTURE/capture.c **** 
 909:../Dave/Generated/CAPTURE/capture.c **** 
 910:../Dave/Generated/CAPTURE/capture.c ****         status1 = CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(handler->ccu4_slice_ptr,
 1924              	 .loc 2 910 0
 1925 0088 FB68     	 ldr r3,[r7,#12]
 1926 008a 9A69     	 ldr r2,[r3,#24]
 1927 008c 07F11403 	 add r3,r7,#20
 1928 0090 1046     	 mov r0,r2
 1929 0092 0121     	 movs r1,#1
 1930 0094 1A46     	 mov r2,r3
 1931 0096 FFF7FEFF 	 bl CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
 1932 009a 0346     	 mov r3,r0
 1933 009c 87F82E30 	 strb r3,[r7,#46]
 911:../Dave/Generated/CAPTURE/capture.c ****                                                                    XMC_CCU4_SLICE_CAP_REG_SET_HIGH,
 912:../Dave/Generated/CAPTURE/capture.c ****                                                                    &duty_val);
 913:../Dave/Generated/CAPTURE/capture.c **** 
 914:../Dave/Generated/CAPTURE/capture.c ****         CAPTURE_lCalculateTimeTickFromTimerValue (handler, &duty_val, false);
 1934              	 .loc 2 914 0
 1935 00a0 07F11403 	 add r3,r7,#20
 1936 00a4 F868     	 ldr r0,[r7,#12]
 1937 00a6 1946     	 mov r1,r3
 1938 00a8 0022     	 movs r2,#0
 1939 00aa FFF7FEFF 	 bl CAPTURE_lCalculateTimeTickFromTimerValue
 915:../Dave/Generated/CAPTURE/capture.c ****         duty_val_nanosec = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, duty_val);
 1940              	 .loc 2 915 0
 1941 00ae 7B69     	 ldr r3,[r7,#20]
 1942 00b0 F868     	 ldr r0,[r7,#12]
 1943 00b2 1946     	 mov r1,r3
 1944 00b4 FFF7FEFF 	 bl CAPTURE_lCalculateTimeInNanoSecFromTimerTick
 1945 00b8 7862     	 str r0,[r7,#36]
 1946              	.L102:
 916:../Dave/Generated/CAPTURE/capture.c **** 
 917:../Dave/Generated/CAPTURE/capture.c ****       }
 918:../Dave/Generated/CAPTURE/capture.c **** #endif
 919:../Dave/Generated/CAPTURE/capture.c **** 
 920:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
 921:../Dave/Generated/CAPTURE/capture.c ****      if (CAPTURE_MODULE_CCU8 == handler->capture_module)
 922:../Dave/Generated/CAPTURE/capture.c ****      {
 923:../Dave/Generated/CAPTURE/capture.c ****        status = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 924:../Dave/Generated/CAPTURE/capture.c ****                                                                  XMC_CCU8_SLICE_CAP_REG_SET_LOW,
 925:../Dave/Generated/CAPTURE/capture.c ****                                                                  &period_val);
 926:../Dave/Generated/CAPTURE/capture.c **** 
 927:../Dave/Generated/CAPTURE/capture.c ****        CAPTURE_lCalculateTimeTickFromTimerValue (handler, &period_val, true);
 928:../Dave/Generated/CAPTURE/capture.c ****        period_val_nanosec = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, period_val);
 929:../Dave/Generated/CAPTURE/capture.c **** 
 930:../Dave/Generated/CAPTURE/capture.c **** 
 931:../Dave/Generated/CAPTURE/capture.c ****        status1 = CAPTURE_CCU8_lSLICE_GetLastestCapturedTimerValue(handler->ccu8_slice_ptr,
 932:../Dave/Generated/CAPTURE/capture.c ****                                                                   XMC_CCU8_SLICE_CAP_REG_SET_HIGH,
 933:../Dave/Generated/CAPTURE/capture.c ****                                                                   &duty_val);
 934:../Dave/Generated/CAPTURE/capture.c ****        CAPTURE_lCalculateTimeTickFromTimerValue (handler, &duty_val, false);
 935:../Dave/Generated/CAPTURE/capture.c ****        duty_val_nanosec = CAPTURE_lCalculateTimeInNanoSecFromTimerTick(handler, duty_val);
 936:../Dave/Generated/CAPTURE/capture.c ****      }
 937:../Dave/Generated/CAPTURE/capture.c **** #endif
 938:../Dave/Generated/CAPTURE/capture.c ****      period_val_nanosec = period_val_nanosec + duty_val_nanosec;
 1947              	 .loc 2 938 0
 1948 00ba BA6A     	 ldr r2,[r7,#40]
 1949 00bc 7B6A     	 ldr r3,[r7,#36]
 1950 00be 1344     	 add r3,r3,r2
 1951 00c0 BB62     	 str r3,[r7,#40]
 939:../Dave/Generated/CAPTURE/capture.c ****      *signal_period = period_val_nanosec;
 1952              	 .loc 2 939 0
 1953 00c2 BB68     	 ldr r3,[r7,#8]
 1954 00c4 BA6A     	 ldr r2,[r7,#40]
 1955 00c6 1A60     	 str r2,[r3]
 940:../Dave/Generated/CAPTURE/capture.c **** 
 941:../Dave/Generated/CAPTURE/capture.c ****      period_val += duty_val;
 1956              	 .loc 2 941 0
 1957 00c8 BA69     	 ldr r2,[r7,#24]
 1958 00ca 7B69     	 ldr r3,[r7,#20]
 1959 00cc 1344     	 add r3,r3,r2
 1960 00ce BB61     	 str r3,[r7,#24]
 942:../Dave/Generated/CAPTURE/capture.c **** 
 943:../Dave/Generated/CAPTURE/capture.c ****      norm_period_val = (uint32_t)__CLZ (period_val);
 1961              	 .loc 2 943 0
 1962 00d0 BB69     	 ldr r3,[r7,#24]
 1963 00d2 FB61     	 str r3,[r7,#28]
 1964              	.LBB14:
 1965              	.LBB15:
1089:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   {
 1966              	 .loc 3 1089 0
 1967 00d4 FB69     	 ldr r3,[r7,#28]
 1968 00d6 002B     	 cmp r3,#0
 1969 00d8 01D1     	 bne .L103
1091:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   }
 1970              	 .loc 3 1091 0
 1971 00da 2023     	 movs r3,#32
 1972 00dc 03E0     	 b .L104
 1973              	.L103:
 1974              	 .loc 3 1093 0
 1975 00de FB69     	 ldr r3,[r7,#28]
 1976 00e0 B3FA83F3 	 clz r3,r3
 1977 00e4 DBB2     	 uxtb r3,r3
 1978              	.L104:
 1979              	.LBE15:
 1980              	.LBE14:
 1981              	 .loc 2 943 0
 1982 00e6 3B62     	 str r3,[r7,#32]
 944:../Dave/Generated/CAPTURE/capture.c **** 
 945:../Dave/Generated/CAPTURE/capture.c ****      period_val = period_val << norm_period_val;
 1983              	 .loc 2 945 0
 1984 00e8 BA69     	 ldr r2,[r7,#24]
 1985 00ea 3B6A     	 ldr r3,[r7,#32]
 1986 00ec 02FA03F3 	 lsl r3,r2,r3
 1987 00f0 BB61     	 str r3,[r7,#24]
 946:../Dave/Generated/CAPTURE/capture.c ****      duty_val = duty_val << norm_period_val;
 1988              	 .loc 2 946 0
 1989 00f2 7A69     	 ldr r2,[r7,#20]
 1990 00f4 3B6A     	 ldr r3,[r7,#32]
 1991 00f6 02FA03F3 	 lsl r3,r2,r3
 1992 00fa 7B61     	 str r3,[r7,#20]
 947:../Dave/Generated/CAPTURE/capture.c **** 
 948:../Dave/Generated/CAPTURE/capture.c ****      period_val = period_val >> 7U;
 1993              	 .loc 2 948 0
 1994 00fc BB69     	 ldr r3,[r7,#24]
 1995 00fe DB09     	 lsrs r3,r3,#7
 1996 0100 BB61     	 str r3,[r7,#24]
 949:../Dave/Generated/CAPTURE/capture.c ****      duty_val = duty_val >> 7U;
 1997              	 .loc 2 949 0
 1998 0102 7B69     	 ldr r3,[r7,#20]
 1999 0104 DB09     	 lsrs r3,r3,#7
 2000 0106 7B61     	 str r3,[r7,#20]
 950:../Dave/Generated/CAPTURE/capture.c **** 
 951:../Dave/Generated/CAPTURE/capture.c ****      if (period_val > 0U)
 2001              	 .loc 2 951 0
 2002 0108 BB69     	 ldr r3,[r7,#24]
 2003 010a 002B     	 cmp r3,#0
 2004 010c 13D0     	 beq .L105
 952:../Dave/Generated/CAPTURE/capture.c ****      {
 953:../Dave/Generated/CAPTURE/capture.c ****        /* Rounding Positive*/
 954:../Dave/Generated/CAPTURE/capture.c ****        *signal_duty = ((duty_val * 100U) + (period_val >> 1)) / period_val;
 2005              	 .loc 2 954 0
 2006 010e 7B69     	 ldr r3,[r7,#20]
 2007 0110 6422     	 movs r2,#100
 2008 0112 02FB03F2 	 mul r2,r2,r3
 2009 0116 BB69     	 ldr r3,[r7,#24]
 2010 0118 5B08     	 lsrs r3,r3,#1
 2011 011a 1A44     	 add r2,r2,r3
 2012 011c BB69     	 ldr r3,[r7,#24]
 2013 011e B2FBF3F2 	 udiv r2,r2,r3
 2014 0122 7B68     	 ldr r3,[r7,#4]
 2015 0124 1A60     	 str r2,[r3]
 955:../Dave/Generated/CAPTURE/capture.c ****        if (status1 != CAPTURE_STATUS_SUCCESS)
 2016              	 .loc 2 955 0
 2017 0126 97F82E30 	 ldrb r3,[r7,#46]
 2018 012a 002B     	 cmp r3,#0
 2019 012c 0AD0     	 beq .L107
 956:../Dave/Generated/CAPTURE/capture.c ****        {
 957:../Dave/Generated/CAPTURE/capture.c ****          status = CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED;
 2020              	 .loc 2 957 0
 2021 012e 0223     	 movs r3,#2
 2022 0130 87F82F30 	 strb r3,[r7,#47]
 951:../Dave/Generated/CAPTURE/capture.c ****      {
 2023              	 .loc 2 951 0
 2024 0134 0BE0     	 b .L108
 2025              	.L105:
 958:../Dave/Generated/CAPTURE/capture.c ****        }
 959:../Dave/Generated/CAPTURE/capture.c ****      }
 960:../Dave/Generated/CAPTURE/capture.c ****      else
 961:../Dave/Generated/CAPTURE/capture.c ****      {
 962:../Dave/Generated/CAPTURE/capture.c ****        *signal_duty = 0U;
 2026              	 .loc 2 962 0
 2027 0136 7B68     	 ldr r3,[r7,#4]
 2028 0138 0022     	 movs r2,#0
 2029 013a 1A60     	 str r2,[r3]
 963:../Dave/Generated/CAPTURE/capture.c ****        status = CAPTURE_STATUS_FAILURE;
 2030              	 .loc 2 963 0
 2031 013c 0123     	 movs r3,#1
 2032 013e 87F82F30 	 strb r3,[r7,#47]
 951:../Dave/Generated/CAPTURE/capture.c ****      {
 2033              	 .loc 2 951 0
 2034 0142 04E0     	 b .L108
 2035              	.L107:
 951:../Dave/Generated/CAPTURE/capture.c ****      {
 2036              	 .loc 2 951 0 is_stmt 0 discriminator 1
 2037 0144 03E0     	 b .L108
 2038              	.L101:
 964:../Dave/Generated/CAPTURE/capture.c ****      }
 965:../Dave/Generated/CAPTURE/capture.c ****     }
 966:../Dave/Generated/CAPTURE/capture.c ****     else
 967:../Dave/Generated/CAPTURE/capture.c ****     {
 968:../Dave/Generated/CAPTURE/capture.c ****       status = CAPTURE_STATUS_INVALID_CONFIG;
 2039              	 .loc 2 968 0 is_stmt 1
 2040 0146 0323     	 movs r3,#3
 2041 0148 87F82F30 	 strb r3,[r7,#47]
 2042 014c 03E0     	 b .L109
 2043              	.L108:
 2044 014e 02E0     	 b .L109
 2045              	.L99:
 969:../Dave/Generated/CAPTURE/capture.c ****     }
 970:../Dave/Generated/CAPTURE/capture.c ****   }
 971:../Dave/Generated/CAPTURE/capture.c ****   else
 972:../Dave/Generated/CAPTURE/capture.c ****   {
 973:../Dave/Generated/CAPTURE/capture.c ****     status = CAPTURE_STATUS_FAILURE;
 2046              	 .loc 2 973 0
 2047 0150 0123     	 movs r3,#1
 2048 0152 87F82F30 	 strb r3,[r7,#47]
 2049              	.L109:
 974:../Dave/Generated/CAPTURE/capture.c ****   }
 975:../Dave/Generated/CAPTURE/capture.c **** 
 976:../Dave/Generated/CAPTURE/capture.c ****   return (status);
 2050              	 .loc 2 976 0
 2051 0156 97F82F30 	 ldrb r3,[r7,#47]
 977:../Dave/Generated/CAPTURE/capture.c **** }
 2052              	 .loc 2 977 0
 2053 015a 1846     	 mov r0,r3
 2054 015c 3037     	 adds r7,r7,#48
 2055              	.LCFI112:
 2056              	 .cfi_def_cfa_offset 8
 2057 015e BD46     	 mov sp,r7
 2058              	.LCFI113:
 2059              	 .cfi_def_cfa_register 13
 2060              	 
 2061 0160 80BD     	 pop {r7,pc}
 2062              	 .cfi_endproc
 2063              	.LFE239:
 2065 0162 00BF     	 .section .text.CAPTURE_CCU4_lInit,"ax",%progbits
 2066              	 .align 2
 2067              	 .thumb
 2068              	 .thumb_func
 2070              	CAPTURE_CCU4_lInit:
 2071              	.LFB240:
 978:../Dave/Generated/CAPTURE/capture.c **** /**************************************************************************************************
 979:../Dave/Generated/CAPTURE/capture.c **** * PRIVATE API IMPLEMENTATION
 980:../Dave/Generated/CAPTURE/capture.c **** ***************************************************************************************************
 981:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
 982:../Dave/Generated/CAPTURE/capture.c **** static void CAPTURE_CCU4_lInit(const CAPTURE_t *const handler)
 983:../Dave/Generated/CAPTURE/capture.c **** {
 2072              	 .loc 2 983 0
 2073              	 .cfi_startproc
 2074              	 
 2075              	 
 2076 0000 80B5     	 push {r7,lr}
 2077              	.LCFI114:
 2078              	 .cfi_def_cfa_offset 8
 2079              	 .cfi_offset 7,-8
 2080              	 .cfi_offset 14,-4
 2081 0002 82B0     	 sub sp,sp,#8
 2082              	.LCFI115:
 2083              	 .cfi_def_cfa_offset 16
 2084 0004 00AF     	 add r7,sp,#0
 2085              	.LCFI116:
 2086              	 .cfi_def_cfa_register 7
 2087 0006 7860     	 str r0,[r7,#4]
 984:../Dave/Generated/CAPTURE/capture.c ****   /* Configure the timer with required settings */
 985:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU4_SLICE_CaptureInit(handler->ccu4_slice_ptr, handler->ccu4_slice_config_ptr);
 2088              	 .loc 2 985 0
 2089 0008 7B68     	 ldr r3,[r7,#4]
 2090 000a 9A69     	 ldr r2,[r3,#24]
 2091 000c 7B68     	 ldr r3,[r7,#4]
 2092 000e DB69     	 ldr r3,[r3,#28]
 2093 0010 1046     	 mov r0,r2
 2094 0012 1946     	 mov r1,r3
 2095 0014 FFF7FEFF 	 bl XMC_CCU4_SLICE_CaptureInit
 986:../Dave/Generated/CAPTURE/capture.c ****   /* programs the timer period and compare register according to time interval value and do the sha
 987:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_CCU4_lShadowTransfer(handler);
 2096              	 .loc 2 987 0
 2097 0018 7868     	 ldr r0,[r7,#4]
 2098 001a FFF7FEFF 	 bl CAPTURE_CCU4_lShadowTransfer
 988:../Dave/Generated/CAPTURE/capture.c **** 
 989:../Dave/Generated/CAPTURE/capture.c ****   /************Configure External Events***************/
 990:../Dave/Generated/CAPTURE/capture.c ****   /* Configure slice to a external event 0 */
 991:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU4_SLICE_ConfigureEvent(handler->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_0, handler->ccu4_even
 2099              	 .loc 2 991 0
 2100 001e 7B68     	 ldr r3,[r7,#4]
 2101 0020 9A69     	 ldr r2,[r3,#24]
 2102 0022 7B68     	 ldr r3,[r7,#4]
 2103 0024 DB68     	 ldr r3,[r3,#12]
 2104 0026 1046     	 mov r0,r2
 2105 0028 0121     	 movs r1,#1
 2106 002a 1A46     	 mov r2,r3
 2107 002c FFF7FEFF 	 bl XMC_CCU4_SLICE_ConfigureEvent
 992:../Dave/Generated/CAPTURE/capture.c ****   /* Configure slice to a external event 1 */
 993:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU4_SLICE_ConfigureEvent(handler->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_1, handler->ccu4_even
 2108              	 .loc 2 993 0
 2109 0030 7B68     	 ldr r3,[r7,#4]
 2110 0032 9A69     	 ldr r2,[r3,#24]
 2111 0034 7B68     	 ldr r3,[r7,#4]
 2112 0036 1B69     	 ldr r3,[r3,#16]
 2113 0038 1046     	 mov r0,r2
 2114 003a 0221     	 movs r1,#2
 2115 003c 1A46     	 mov r2,r3
 2116 003e FFF7FEFF 	 bl XMC_CCU4_SLICE_ConfigureEvent
 994:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU4_SLICE_Capture0Config(handler->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_0);
 2117              	 .loc 2 994 0
 2118 0042 7B68     	 ldr r3,[r7,#4]
 2119 0044 9B69     	 ldr r3,[r3,#24]
 2120 0046 1846     	 mov r0,r3
 2121 0048 0121     	 movs r1,#1
 2122 004a FFF7FEFF 	 bl XMC_CCU4_SLICE_Capture0Config
 995:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU4_SLICE_Capture1Config(handler->ccu4_slice_ptr, XMC_CCU4_SLICE_EVENT_1);
 2123              	 .loc 2 995 0
 2124 004e 7B68     	 ldr r3,[r7,#4]
 2125 0050 9B69     	 ldr r3,[r3,#24]
 2126 0052 1846     	 mov r0,r3
 2127 0054 0221     	 movs r1,#2
 2128 0056 FFF7FEFF 	 bl XMC_CCU4_SLICE_Capture1Config
 996:../Dave/Generated/CAPTURE/capture.c **** 
 997:../Dave/Generated/CAPTURE/capture.c ****   #ifdef  CAPTURE_INTERRUPT_ENABLED
 998:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->capture_event_enable)
 999:../Dave/Generated/CAPTURE/capture.c ****   {
1000:../Dave/Generated/CAPTURE/capture.c ****     /* Binds a period match event to an NVIC node  */
1001:../Dave/Generated/CAPTURE/capture.c ****     XMC_CCU4_SLICE_SetInterruptNode(handler->ccu4_slice_ptr,
1002:../Dave/Generated/CAPTURE/capture.c ****                                    XMC_CCU4_SLICE_IRQ_ID_EVENT0,
1003:../Dave/Generated/CAPTURE/capture.c ****                                    handler->ccu4_capture_event_node);
1004:../Dave/Generated/CAPTURE/capture.c ****     /* Enables a timer(period match) event  */
1005:../Dave/Generated/CAPTURE/capture.c ****     XMC_CCU4_SLICE_EnableEvent(handler->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_EVENT0);
1006:../Dave/Generated/CAPTURE/capture.c ****   }
1007:../Dave/Generated/CAPTURE/capture.c ****   #endif
1008:../Dave/Generated/CAPTURE/capture.c **** 
1009:../Dave/Generated/CAPTURE/capture.c ****   /* Enable the clock for selected timer */
1010:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU4_EnableClock(handler->global_ccu4_handler->module_ptr, handler->ccu_slice_number);
 2129              	 .loc 2 1010 0
 2130 005a 7B68     	 ldr r3,[r7,#4]
 2131 005c 5B69     	 ldr r3,[r3,#20]
 2132 005e 9A68     	 ldr r2,[r3,#8]
 2133 0060 7B68     	 ldr r3,[r7,#4]
 2134 0062 93F82C30 	 ldrb r3,[r3,#44]
 2135 0066 1046     	 mov r0,r2
 2136 0068 1946     	 mov r1,r3
 2137 006a FFF7FEFF 	 bl XMC_CCU4_EnableClock
1011:../Dave/Generated/CAPTURE/capture.c **** }
 2138              	 .loc 2 1011 0
 2139 006e 0837     	 adds r7,r7,#8
 2140              	.LCFI117:
 2141              	 .cfi_def_cfa_offset 8
 2142 0070 BD46     	 mov sp,r7
 2143              	.LCFI118:
 2144              	 .cfi_def_cfa_register 13
 2145              	 
 2146 0072 80BD     	 pop {r7,pc}
 2147              	 .cfi_endproc
 2148              	.LFE240:
 2150              	 .section .text.CAPTURE_CCU4_lShadowTransfer,"ax",%progbits
 2151              	 .align 2
 2152              	 .thumb
 2153              	 .thumb_func
 2155              	CAPTURE_CCU4_lShadowTransfer:
 2156              	.LFB241:
1012:../Dave/Generated/CAPTURE/capture.c **** 
1013:../Dave/Generated/CAPTURE/capture.c **** static void CAPTURE_CCU4_lShadowTransfer(const CAPTURE_t *const handler)
1014:../Dave/Generated/CAPTURE/capture.c **** {
 2157              	 .loc 2 1014 0
 2158              	 .cfi_startproc
 2159              	 
 2160              	 
 2161 0000 80B5     	 push {r7,lr}
 2162              	.LCFI119:
 2163              	 .cfi_def_cfa_offset 8
 2164              	 .cfi_offset 7,-8
 2165              	 .cfi_offset 14,-4
 2166 0002 82B0     	 sub sp,sp,#8
 2167              	.LCFI120:
 2168              	 .cfi_def_cfa_offset 16
 2169 0004 00AF     	 add r7,sp,#0
 2170              	.LCFI121:
 2171              	 .cfi_def_cfa_register 7
 2172 0006 7860     	 str r0,[r7,#4]
1015:../Dave/Generated/CAPTURE/capture.c ****   /* programs the timer period register according to time interval value */
1016:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU4_SLICE_SetTimerPeriodMatch(handler->ccu4_slice_ptr, CAPTURE_PERIOD_16BIT_MAX);
 2173              	 .loc 2 1016 0
 2174 0008 7B68     	 ldr r3,[r7,#4]
 2175 000a 9B69     	 ldr r3,[r3,#24]
 2176 000c 1846     	 mov r0,r3
 2177 000e 4FF6FF71 	 movw r1,#65535
 2178 0012 FFF7FEFF 	 bl XMC_CCU4_SLICE_SetTimerPeriodMatch
1017:../Dave/Generated/CAPTURE/capture.c ****   /* programs the timer compare register for 50% duty cycle */
1018:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU4_SLICE_SetTimerCompareMatch(handler->ccu4_slice_ptr, 0x0U);
 2179              	 .loc 2 1018 0
 2180 0016 7B68     	 ldr r3,[r7,#4]
 2181 0018 9B69     	 ldr r3,[r3,#24]
 2182 001a 1846     	 mov r0,r3
 2183 001c 0021     	 movs r1,#0
 2184 001e FFF7FEFF 	 bl XMC_CCU4_SLICE_SetTimerCompareMatch
1019:../Dave/Generated/CAPTURE/capture.c ****   /* Transfers value from shadow timer registers to actual timer registers */
1020:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU4_EnableShadowTransfer(handler->global_ccu4_handler->module_ptr, handler->shadow_mask);
 2185              	 .loc 2 1020 0
 2186 0022 7B68     	 ldr r3,[r7,#4]
 2187 0024 5B69     	 ldr r3,[r3,#20]
 2188 0026 9A68     	 ldr r2,[r3,#8]
 2189 0028 7B68     	 ldr r3,[r7,#4]
 2190 002a 9B68     	 ldr r3,[r3,#8]
 2191 002c 1046     	 mov r0,r2
 2192 002e 1946     	 mov r1,r3
 2193 0030 FFF7FEFF 	 bl XMC_CCU4_EnableShadowTransfer
1021:../Dave/Generated/CAPTURE/capture.c **** }
 2194              	 .loc 2 1021 0
 2195 0034 0837     	 adds r7,r7,#8
 2196              	.LCFI122:
 2197              	 .cfi_def_cfa_offset 8
 2198 0036 BD46     	 mov sp,r7
 2199              	.LCFI123:
 2200              	 .cfi_def_cfa_register 13
 2201              	 
 2202 0038 80BD     	 pop {r7,pc}
 2203              	 .cfi_endproc
 2204              	.LFE241:
 2206 003a 00BF     	 .section .text.CAPTURE_lCalculateTimeTickFromTimerValue,"ax",%progbits
 2207              	 .align 2
 2208              	 .thumb
 2209              	 .thumb_func
 2211              	CAPTURE_lCalculateTimeTickFromTimerValue:
 2212              	.LFB242:
1022:../Dave/Generated/CAPTURE/capture.c **** #endif
1023:../Dave/Generated/CAPTURE/capture.c **** 
1024:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
1025:../Dave/Generated/CAPTURE/capture.c **** static void CAPTURE_CCU8_lInit(const CAPTURE_t *const handler)
1026:../Dave/Generated/CAPTURE/capture.c **** {
1027:../Dave/Generated/CAPTURE/capture.c ****   /* Configure the timer with required settings */
1028:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU8_SLICE_CaptureInit(handler->ccu8_slice_ptr, handler->ccu8_slice_config_ptr);
1029:../Dave/Generated/CAPTURE/capture.c ****   /* programs the timer period and compare register according to time interval value and do the sha
1030:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_CCU8_lShadowTransfer(handler);
1031:../Dave/Generated/CAPTURE/capture.c **** 
1032:../Dave/Generated/CAPTURE/capture.c ****   /************Configure External Events***************/
1033:../Dave/Generated/CAPTURE/capture.c ****   /* Configure slice to a external event 0 */
1034:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU8_SLICE_ConfigureEvent(handler->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_0, handler->ccu8_even
1035:../Dave/Generated/CAPTURE/capture.c ****   /* Configure slice to a external event 1 */
1036:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU8_SLICE_ConfigureEvent(handler->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_1, handler->ccu8_even
1037:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU8_SLICE_Capture0Config(handler->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_0);
1038:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU8_SLICE_Capture1Config(handler->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_1);
1039:../Dave/Generated/CAPTURE/capture.c **** 
1040:../Dave/Generated/CAPTURE/capture.c ****   #ifdef  CAPTURE_INTERRUPT_ENABLED
1041:../Dave/Generated/CAPTURE/capture.c ****   if (true == handler->capture_event_enable)
1042:../Dave/Generated/CAPTURE/capture.c ****   {
1043:../Dave/Generated/CAPTURE/capture.c ****     /* Binds a period match event to an NVIC node  */
1044:../Dave/Generated/CAPTURE/capture.c ****     XMC_CCU8_SLICE_SetInterruptNode(handler->ccu8_slice_ptr,
1045:../Dave/Generated/CAPTURE/capture.c ****                                     XMC_CCU8_SLICE_IRQ_ID_EVENT0,
1046:../Dave/Generated/CAPTURE/capture.c ****                                     handler->ccu8_capture_event_node);
1047:../Dave/Generated/CAPTURE/capture.c ****     /* Enables a timer(period match) event  */
1048:../Dave/Generated/CAPTURE/capture.c ****     XMC_CCU8_SLICE_EnableEvent(handler->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT0);
1049:../Dave/Generated/CAPTURE/capture.c ****   }
1050:../Dave/Generated/CAPTURE/capture.c ****   #endif
1051:../Dave/Generated/CAPTURE/capture.c **** 
1052:../Dave/Generated/CAPTURE/capture.c **** 
1053:../Dave/Generated/CAPTURE/capture.c ****   /* Enable the clock for selected timer */
1054:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU8_EnableClock(handler->global_ccu8_handler->module_ptr, handler->ccu_slice_number);
1055:../Dave/Generated/CAPTURE/capture.c **** }
1056:../Dave/Generated/CAPTURE/capture.c **** 
1057:../Dave/Generated/CAPTURE/capture.c **** static void CAPTURE_CCU8_lShadowTransfer(const CAPTURE_t *const handler)
1058:../Dave/Generated/CAPTURE/capture.c **** {
1059:../Dave/Generated/CAPTURE/capture.c ****   /* programs the timer period register according to time interval value */
1060:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU8_SLICE_SetTimerPeriodMatch(handler->ccu8_slice_ptr, CAPTURE_PERIOD_16BIT_MAX);
1061:../Dave/Generated/CAPTURE/capture.c ****   /* programs the timer compare register for 50% duty cycle */
1062:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU8_SLICE_SetTimerCompareMatch(handler->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1, 0x
1063:../Dave/Generated/CAPTURE/capture.c ****   /* Transfers value from shadow timer registers to actual timer registers */
1064:../Dave/Generated/CAPTURE/capture.c ****   XMC_CCU8_EnableShadowTransfer(handler->global_ccu8_handler->module_ptr, handler->shadow_mask);
1065:../Dave/Generated/CAPTURE/capture.c **** }
1066:../Dave/Generated/CAPTURE/capture.c **** #endif
1067:../Dave/Generated/CAPTURE/capture.c **** 
1068:../Dave/Generated/CAPTURE/capture.c **** static void CAPTURE_lCalculateTimeTickFromTimerValue(const CAPTURE_t *const handler,
1069:../Dave/Generated/CAPTURE/capture.c ****                                                      uint32_t *const timer_val_ptr,
1070:../Dave/Generated/CAPTURE/capture.c ****                                                      bool is_increment)
1071:../Dave/Generated/CAPTURE/capture.c **** {
 2213              	 .loc 2 1071 0
 2214              	 .cfi_startproc
 2215              	 
 2216              	 
 2217              	 
 2218 0000 80B4     	 push {r7}
 2219              	.LCFI124:
 2220              	 .cfi_def_cfa_offset 4
 2221              	 .cfi_offset 7,-4
 2222 0002 8DB0     	 sub sp,sp,#52
 2223              	.LCFI125:
 2224              	 .cfi_def_cfa_offset 56
 2225 0004 00AF     	 add r7,sp,#0
 2226              	.LCFI126:
 2227              	 .cfi_def_cfa_register 7
 2228 0006 F860     	 str r0,[r7,#12]
 2229 0008 B960     	 str r1,[r7,#8]
 2230 000a 1346     	 mov r3,r2
 2231 000c FB71     	 strb r3,[r7,#7]
1072:../Dave/Generated/CAPTURE/capture.c ****   /* Check for APP instance is initialized or not */
1073:../Dave/Generated/CAPTURE/capture.c ****   uint32_t psc_psiv_val = 0U;
 2232              	 .loc 2 1073 0
 2233 000e 0023     	 movs r3,#0
 2234 0010 FB62     	 str r3,[r7,#44]
1074:../Dave/Generated/CAPTURE/capture.c ****   bool is_float_prescaler = false;
 2235              	 .loc 2 1074 0
 2236 0012 0023     	 movs r3,#0
 2237 0014 87F82B30 	 strb r3,[r7,#43]
1075:../Dave/Generated/CAPTURE/capture.c ****   uint32_t cxv_captv_val = (uint32_t)((uint32_t)*timer_val_ptr & 0xFFFFU);
 2238              	 .loc 2 1075 0
 2239 0018 BB68     	 ldr r3,[r7,#8]
 2240 001a 1B68     	 ldr r3,[r3]
 2241 001c 9BB2     	 uxth r3,r3
 2242 001e 7B62     	 str r3,[r7,#36]
1076:../Dave/Generated/CAPTURE/capture.c ****   uint32_t cxv_fpcv_val = (uint32_t)((uint32_t)*timer_val_ptr >> 16U) & 0xFU;
 2243              	 .loc 2 1076 0
 2244 0020 BB68     	 ldr r3,[r7,#8]
 2245 0022 1B68     	 ldr r3,[r3]
 2246 0024 1B0C     	 lsrs r3,r3,#16
 2247 0026 03F00F03 	 and r3,r3,#15
 2248 002a BB61     	 str r3,[r7,#24]
1077:../Dave/Generated/CAPTURE/capture.c **** 
1078:../Dave/Generated/CAPTURE/capture.c ****   /* Period measured should be added 1 to get actual value*/
1079:../Dave/Generated/CAPTURE/capture.c ****   if (is_increment == true)
 2249              	 .loc 2 1079 0
 2250 002c FB79     	 ldrb r3,[r7,#7]
 2251 002e 002B     	 cmp r3,#0
 2252 0030 02D0     	 beq .L114
1080:../Dave/Generated/CAPTURE/capture.c ****   {
1081:../Dave/Generated/CAPTURE/capture.c ****     cxv_captv_val = cxv_captv_val + 1U;
 2253              	 .loc 2 1081 0
 2254 0032 7B6A     	 ldr r3,[r7,#36]
 2255 0034 0133     	 adds r3,r3,#1
 2256 0036 7B62     	 str r3,[r7,#36]
 2257              	.L114:
1082:../Dave/Generated/CAPTURE/capture.c ****   }
1083:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
1084:../Dave/Generated/CAPTURE/capture.c ****   if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 2258              	 .loc 2 1084 0
 2259 0038 FB68     	 ldr r3,[r7,#12]
 2260 003a 93F82D30 	 ldrb r3,[r3,#45]
 2261 003e 002B     	 cmp r3,#0
 2262 0040 11D1     	 bne .L115
1085:../Dave/Generated/CAPTURE/capture.c ****   {
1086:../Dave/Generated/CAPTURE/capture.c ****     psc_psiv_val = handler->ccu4_slice_config_ptr->prescaler_initval;
 2263              	 .loc 2 1086 0
 2264 0042 FB68     	 ldr r3,[r7,#12]
 2265 0044 DB69     	 ldr r3,[r3,#28]
 2266 0046 1B79     	 ldrb r3,[r3,#4]
 2267 0048 C3F30303 	 ubfx r3,r3,#0,#4
 2268 004c DBB2     	 uxtb r3,r3
 2269 004e FB62     	 str r3,[r7,#44]
1087:../Dave/Generated/CAPTURE/capture.c ****     if (handler->ccu4_slice_config_ptr->prescaler_mode == (uint32_t)XMC_CCU4_SLICE_PRESCALER_MODE_F
 2270              	 .loc 2 1087 0
 2271 0050 FB68     	 ldr r3,[r7,#12]
 2272 0052 DB69     	 ldr r3,[r3,#28]
 2273 0054 9B78     	 ldrb r3,[r3,#2]
 2274 0056 03F00103 	 and r3,r3,#1
 2275 005a DBB2     	 uxtb r3,r3
 2276 005c 002B     	 cmp r3,#0
 2277 005e 02D0     	 beq .L115
1088:../Dave/Generated/CAPTURE/capture.c ****     {
1089:../Dave/Generated/CAPTURE/capture.c ****       is_float_prescaler =  true;
 2278              	 .loc 2 1089 0
 2279 0060 0123     	 movs r3,#1
 2280 0062 87F82B30 	 strb r3,[r7,#43]
 2281              	.L115:
1090:../Dave/Generated/CAPTURE/capture.c ****     }
1091:../Dave/Generated/CAPTURE/capture.c ****   }
1092:../Dave/Generated/CAPTURE/capture.c **** #endif
1093:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
1094:../Dave/Generated/CAPTURE/capture.c ****   if (CAPTURE_MODULE_CCU8 == handler->capture_module)
1095:../Dave/Generated/CAPTURE/capture.c ****   {
1096:../Dave/Generated/CAPTURE/capture.c ****     psc_psiv_val = handler->ccu8_slice_config_ptr->prescaler_initval;
1097:../Dave/Generated/CAPTURE/capture.c ****     if (handler->ccu8_slice_config_ptr->prescaler_mode == (uint32_t)XMC_CCU8_SLICE_PRESCALER_MODE_F
1098:../Dave/Generated/CAPTURE/capture.c ****     {
1099:../Dave/Generated/CAPTURE/capture.c ****       is_float_prescaler =  true;
1100:../Dave/Generated/CAPTURE/capture.c ****     }
1101:../Dave/Generated/CAPTURE/capture.c ****   }
1102:../Dave/Generated/CAPTURE/capture.c **** #endif
1103:../Dave/Generated/CAPTURE/capture.c **** 
1104:../Dave/Generated/CAPTURE/capture.c ****   if (is_float_prescaler == true)
 2282              	 .loc 2 1104 0
 2283 0066 97F82B30 	 ldrb r3,[r7,#43]
 2284 006a 002B     	 cmp r3,#0
 2285 006c 23D0     	 beq .L116
 2286              	.LBB16:
1105:../Dave/Generated/CAPTURE/capture.c ****   {
1106:../Dave/Generated/CAPTURE/capture.c ****     int32_t loop = 0;
 2287              	 .loc 2 1106 0
 2288 006e 0023     	 movs r3,#0
 2289 0070 3B62     	 str r3,[r7,#32]
1107:../Dave/Generated/CAPTURE/capture.c ****     uint32_t prescaler_value;
1108:../Dave/Generated/CAPTURE/capture.c ****     uint32_t timer_val = 0U;
 2290              	 .loc 2 1108 0
 2291 0072 0023     	 movs r3,#0
 2292 0074 FB61     	 str r3,[r7,#28]
1109:../Dave/Generated/CAPTURE/capture.c **** 
1110:../Dave/Generated/CAPTURE/capture.c ****     prescaler_value = cxv_fpcv_val - psc_psiv_val;
 2293              	 .loc 2 1110 0
 2294 0076 BA69     	 ldr r2,[r7,#24]
 2295 0078 FB6A     	 ldr r3,[r7,#44]
 2296 007a D31A     	 subs r3,r2,r3
 2297 007c 7B61     	 str r3,[r7,#20]
1111:../Dave/Generated/CAPTURE/capture.c **** 
1112:../Dave/Generated/CAPTURE/capture.c ****     for (loop = (int32_t)prescaler_value; loop > 0; loop--)
 2298              	 .loc 2 1112 0
 2299 007e 7B69     	 ldr r3,[r7,#20]
 2300 0080 3B62     	 str r3,[r7,#32]
 2301 0082 0AE0     	 b .L117
 2302              	.L118:
1113:../Dave/Generated/CAPTURE/capture.c ****     {
1114:../Dave/Generated/CAPTURE/capture.c ****       timer_val = (uint32_t)timer_val << 1U;
 2303              	 .loc 2 1114 0 discriminator 3
 2304 0084 FB69     	 ldr r3,[r7,#28]
 2305 0086 5B00     	 lsls r3,r3,#1
 2306 0088 FB61     	 str r3,[r7,#28]
1115:../Dave/Generated/CAPTURE/capture.c ****       timer_val += 65535U;
 2307              	 .loc 2 1115 0 discriminator 3
 2308 008a FB69     	 ldr r3,[r7,#28]
 2309 008c 03F57F43 	 add r3,r3,#65280
 2310 0090 FF33     	 adds r3,r3,#255
 2311 0092 FB61     	 str r3,[r7,#28]
1112:../Dave/Generated/CAPTURE/capture.c ****     {
 2312              	 .loc 2 1112 0 discriminator 3
 2313 0094 3B6A     	 ldr r3,[r7,#32]
 2314 0096 013B     	 subs r3,r3,#1
 2315 0098 3B62     	 str r3,[r7,#32]
 2316              	.L117:
1112:../Dave/Generated/CAPTURE/capture.c ****     {
 2317              	 .loc 2 1112 0 is_stmt 0 discriminator 1
 2318 009a 3B6A     	 ldr r3,[r7,#32]
 2319 009c 002B     	 cmp r3,#0
 2320 009e F1DC     	 bgt .L118
1116:../Dave/Generated/CAPTURE/capture.c ****     }
1117:../Dave/Generated/CAPTURE/capture.c **** 
1118:../Dave/Generated/CAPTURE/capture.c ****     timer_val += (uint32_t)(cxv_captv_val * (1UL << prescaler_value));
 2321              	 .loc 2 1118 0 is_stmt 1
 2322 00a0 7B69     	 ldr r3,[r7,#20]
 2323 00a2 7A6A     	 ldr r2,[r7,#36]
 2324 00a4 02FA03F3 	 lsl r3,r2,r3
 2325 00a8 FA69     	 ldr r2,[r7,#28]
 2326 00aa 1344     	 add r3,r3,r2
 2327 00ac FB61     	 str r3,[r7,#28]
1119:../Dave/Generated/CAPTURE/capture.c ****     *timer_val_ptr = timer_val;
 2328              	 .loc 2 1119 0
 2329 00ae BB68     	 ldr r3,[r7,#8]
 2330 00b0 FA69     	 ldr r2,[r7,#28]
 2331 00b2 1A60     	 str r2,[r3]
 2332              	.LBE16:
 2333 00b4 02E0     	 b .L113
 2334              	.L116:
1120:../Dave/Generated/CAPTURE/capture.c ****   }
1121:../Dave/Generated/CAPTURE/capture.c ****   else
1122:../Dave/Generated/CAPTURE/capture.c ****   {
1123:../Dave/Generated/CAPTURE/capture.c ****     *timer_val_ptr = cxv_captv_val;
 2335              	 .loc 2 1123 0
 2336 00b6 BB68     	 ldr r3,[r7,#8]
 2337 00b8 7A6A     	 ldr r2,[r7,#36]
 2338 00ba 1A60     	 str r2,[r3]
 2339              	.L113:
1124:../Dave/Generated/CAPTURE/capture.c ****   }
1125:../Dave/Generated/CAPTURE/capture.c **** }
 2340              	 .loc 2 1125 0
 2341 00bc 3437     	 adds r7,r7,#52
 2342              	.LCFI127:
 2343              	 .cfi_def_cfa_offset 4
 2344 00be BD46     	 mov sp,r7
 2345              	.LCFI128:
 2346              	 .cfi_def_cfa_register 13
 2347              	 
 2348 00c0 5DF8047B 	 ldr r7,[sp],#4
 2349              	.LCFI129:
 2350              	 .cfi_restore 7
 2351              	 .cfi_def_cfa_offset 0
 2352 00c4 7047     	 bx lr
 2353              	 .cfi_endproc
 2354              	.LFE242:
 2356              	 .global __aeabi_uldivmod
 2357 00c6 00BF     	 .section .text.CAPTURE_lCalculateTimeInNanoSecFromTimerTick,"ax",%progbits
 2358              	 .align 2
 2359              	 .thumb
 2360              	 .thumb_func
 2362              	CAPTURE_lCalculateTimeInNanoSecFromTimerTick:
 2363              	.LFB243:
1126:../Dave/Generated/CAPTURE/capture.c **** 
1127:../Dave/Generated/CAPTURE/capture.c **** static uint32_t CAPTURE_lCalculateTimeInNanoSecFromTimerTick(const CAPTURE_t *const handler, uint32
1128:../Dave/Generated/CAPTURE/capture.c **** {
 2364              	 .loc 2 1128 0
 2365              	 .cfi_startproc
 2366              	 
 2367              	 
 2368 0000 B0B5     	 push {r4,r5,r7,lr}
 2369              	.LCFI130:
 2370              	 .cfi_def_cfa_offset 16
 2371              	 .cfi_offset 4,-16
 2372              	 .cfi_offset 5,-12
 2373              	 .cfi_offset 7,-8
 2374              	 .cfi_offset 14,-4
 2375 0002 8CB0     	 sub sp,sp,#48
 2376              	.LCFI131:
 2377              	 .cfi_def_cfa_offset 64
 2378 0004 00AF     	 add r7,sp,#0
 2379              	.LCFI132:
 2380              	 .cfi_def_cfa_register 7
 2381 0006 7860     	 str r0,[r7,#4]
 2382 0008 3960     	 str r1,[r7]
1129:../Dave/Generated/CAPTURE/capture.c ****   uint64_t singal_period_long_long;
1130:../Dave/Generated/CAPTURE/capture.c ****   uint32_t inv_sig_resolution_in_sec = 1U;
 2383              	 .loc 2 1130 0
 2384 000a 0123     	 movs r3,#1
 2385 000c FB62     	 str r3,[r7,#44]
1131:../Dave/Generated/CAPTURE/capture.c ****   uint32_t norm_timer_val;
1132:../Dave/Generated/CAPTURE/capture.c ****   uint32_t norm_inv_sig_resolution_in_sec;
1133:../Dave/Generated/CAPTURE/capture.c ****   uint32_t min_norm;
1134:../Dave/Generated/CAPTURE/capture.c ****   uint32_t psc_psiv_val = 0U;
 2386              	 .loc 2 1134 0
 2387 000e 0023     	 movs r3,#0
 2388 0010 7B62     	 str r3,[r7,#36]
1135:../Dave/Generated/CAPTURE/capture.c **** 
1136:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU4_USED
1137:../Dave/Generated/CAPTURE/capture.c ****   if (CAPTURE_MODULE_CCU4 == handler->capture_module)
 2389              	 .loc 2 1137 0
 2390 0012 7B68     	 ldr r3,[r7,#4]
 2391 0014 93F82D30 	 ldrb r3,[r3,#45]
 2392 0018 002B     	 cmp r3,#0
 2393 001a 0DD1     	 bne .L121
1138:../Dave/Generated/CAPTURE/capture.c ****   {
1139:../Dave/Generated/CAPTURE/capture.c ****     psc_psiv_val = handler->ccu4_slice_config_ptr->prescaler_initval;
 2394              	 .loc 2 1139 0
 2395 001c 7B68     	 ldr r3,[r7,#4]
 2396 001e DB69     	 ldr r3,[r3,#28]
 2397 0020 1B79     	 ldrb r3,[r3,#4]
 2398 0022 C3F30303 	 ubfx r3,r3,#0,#4
 2399 0026 DBB2     	 uxtb r3,r3
 2400 0028 7B62     	 str r3,[r7,#36]
1140:../Dave/Generated/CAPTURE/capture.c ****     inv_sig_resolution_in_sec = handler->global_ccu4_handler->module_frequency >> psc_psiv_val;
 2401              	 .loc 2 1140 0
 2402 002a 7B68     	 ldr r3,[r7,#4]
 2403 002c 5B69     	 ldr r3,[r3,#20]
 2404 002e 1A68     	 ldr r2,[r3]
 2405 0030 7B6A     	 ldr r3,[r7,#36]
 2406 0032 22FA03F3 	 lsr r3,r2,r3
 2407 0036 FB62     	 str r3,[r7,#44]
 2408              	.L121:
 2409 0038 3B68     	 ldr r3,[r7]
 2410 003a FB60     	 str r3,[r7,#12]
 2411              	.LBB17:
 2412              	.LBB18:
1089:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   {
 2413              	 .loc 3 1089 0
 2414 003c FB68     	 ldr r3,[r7,#12]
 2415 003e 002B     	 cmp r3,#0
 2416 0040 01D1     	 bne .L122
1091:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   }
 2417              	 .loc 3 1091 0
 2418 0042 2023     	 movs r3,#32
 2419 0044 03E0     	 b .L123
 2420              	.L122:
 2421              	 .loc 3 1093 0
 2422 0046 FB68     	 ldr r3,[r7,#12]
 2423 0048 B3FA83F3 	 clz r3,r3
 2424 004c DBB2     	 uxtb r3,r3
 2425              	.L123:
 2426              	.LBE18:
 2427              	.LBE17:
1141:../Dave/Generated/CAPTURE/capture.c ****   }
1142:../Dave/Generated/CAPTURE/capture.c **** #endif
1143:../Dave/Generated/CAPTURE/capture.c **** #ifdef CAPTURE_CCU8_USED
1144:../Dave/Generated/CAPTURE/capture.c ****   if (CAPTURE_MODULE_CCU8 == handler->capture_module)
1145:../Dave/Generated/CAPTURE/capture.c ****   {
1146:../Dave/Generated/CAPTURE/capture.c ****     psc_psiv_val = handler->ccu8_slice_config_ptr->prescaler_initval;
1147:../Dave/Generated/CAPTURE/capture.c ****     inv_sig_resolution_in_sec = handler->global_ccu8_handler->module_frequency >> psc_psiv_val;
1148:../Dave/Generated/CAPTURE/capture.c ****   }
1149:../Dave/Generated/CAPTURE/capture.c **** #endif
1150:../Dave/Generated/CAPTURE/capture.c **** 
1151:../Dave/Generated/CAPTURE/capture.c ****   norm_timer_val = (uint32_t)__CLZ(timer_val);
 2428              	 .loc 2 1151 0
 2429 004e 3B62     	 str r3,[r7,#32]
 2430 0050 FB6A     	 ldr r3,[r7,#44]
 2431 0052 BB60     	 str r3,[r7,#8]
 2432              	.LBB19:
 2433              	.LBB20:
1089:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   {
 2434              	 .loc 3 1089 0
 2435 0054 BB68     	 ldr r3,[r7,#8]
 2436 0056 002B     	 cmp r3,#0
 2437 0058 01D1     	 bne .L124
1091:C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include\cmsis_gcc.h ****   }
 2438              	 .loc 3 1091 0
 2439 005a 2023     	 movs r3,#32
 2440 005c 03E0     	 b .L125
 2441              	.L124:
 2442              	 .loc 3 1093 0
 2443 005e BB68     	 ldr r3,[r7,#8]
 2444 0060 B3FA83F3 	 clz r3,r3
 2445 0064 DBB2     	 uxtb r3,r3
 2446              	.L125:
 2447              	.LBE20:
 2448              	.LBE19:
1152:../Dave/Generated/CAPTURE/capture.c ****   norm_inv_sig_resolution_in_sec = (uint32_t)__CLZ(inv_sig_resolution_in_sec);
 2449              	 .loc 2 1152 0
 2450 0066 FB61     	 str r3,[r7,#28]
1153:../Dave/Generated/CAPTURE/capture.c **** 
1154:../Dave/Generated/CAPTURE/capture.c ****   if (norm_timer_val > norm_inv_sig_resolution_in_sec)
 2451              	 .loc 2 1154 0
 2452 0068 3A6A     	 ldr r2,[r7,#32]
 2453 006a FB69     	 ldr r3,[r7,#28]
 2454 006c 9A42     	 cmp r2,r3
 2455 006e 02D9     	 bls .L126
1155:../Dave/Generated/CAPTURE/capture.c ****   {
1156:../Dave/Generated/CAPTURE/capture.c ****     min_norm = norm_inv_sig_resolution_in_sec;
 2456              	 .loc 2 1156 0
 2457 0070 FB69     	 ldr r3,[r7,#28]
 2458 0072 BB62     	 str r3,[r7,#40]
 2459 0074 01E0     	 b .L127
 2460              	.L126:
1157:../Dave/Generated/CAPTURE/capture.c ****   }
1158:../Dave/Generated/CAPTURE/capture.c ****   else
1159:../Dave/Generated/CAPTURE/capture.c ****   {
1160:../Dave/Generated/CAPTURE/capture.c ****     min_norm = norm_timer_val;
 2461              	 .loc 2 1160 0
 2462 0076 3B6A     	 ldr r3,[r7,#32]
 2463 0078 BB62     	 str r3,[r7,#40]
 2464              	.L127:
1161:../Dave/Generated/CAPTURE/capture.c ****   }
1162:../Dave/Generated/CAPTURE/capture.c **** 
1163:../Dave/Generated/CAPTURE/capture.c ****   /* Normalized the value to get better precision*/
1164:../Dave/Generated/CAPTURE/capture.c ****   timer_val = timer_val << min_norm;
 2465              	 .loc 2 1164 0
 2466 007a BB6A     	 ldr r3,[r7,#40]
 2467 007c 3A68     	 ldr r2,[r7]
 2468 007e 02FA03F3 	 lsl r3,r2,r3
 2469 0082 3B60     	 str r3,[r7]
1165:../Dave/Generated/CAPTURE/capture.c ****   inv_sig_resolution_in_sec = inv_sig_resolution_in_sec << min_norm;
 2470              	 .loc 2 1165 0
 2471 0084 BB6A     	 ldr r3,[r7,#40]
 2472 0086 FA6A     	 ldr r2,[r7,#44]
 2473 0088 02FA03F3 	 lsl r3,r2,r3
 2474 008c FB62     	 str r3,[r7,#44]
1166:../Dave/Generated/CAPTURE/capture.c **** 
1167:../Dave/Generated/CAPTURE/capture.c ****   singal_period_long_long = (((uint64_t) timer_val) * 1000000000U) / inv_sig_resolution_in_sec;
 2475              	 .loc 2 1167 0
 2476 008e 3B68     	 ldr r3,[r7]
 2477 0090 1A46     	 mov r2,r3
 2478 0092 4FF00003 	 mov r3,#0
 2479 0096 0F49     	 ldr r1,.L129
 2480 0098 01FB03F0 	 mul r0,r1,r3
 2481 009c 0021     	 movs r1,#0
 2482 009e 01FB02F1 	 mul r1,r1,r2
 2483 00a2 0144     	 add r1,r1,r0
 2484 00a4 0B48     	 ldr r0,.L129
 2485 00a6 A2FB0023 	 umull r2,r3,r2,r0
 2486 00aa 1944     	 add r1,r1,r3
 2487 00ac 0B46     	 mov r3,r1
 2488 00ae F96A     	 ldr r1,[r7,#44]
 2489 00b0 0C46     	 mov r4,r1
 2490 00b2 4FF00005 	 mov r5,#0
 2491 00b6 1046     	 mov r0,r2
 2492 00b8 1946     	 mov r1,r3
 2493 00ba 2246     	 mov r2,r4
 2494 00bc 2B46     	 mov r3,r5
 2495 00be FFF7FEFF 	 bl __aeabi_uldivmod
 2496 00c2 0246     	 mov r2,r0
 2497 00c4 0B46     	 mov r3,r1
 2498 00c6 C7E90423 	 strd r2,[r7,#16]
1168:../Dave/Generated/CAPTURE/capture.c **** 
1169:../Dave/Generated/CAPTURE/capture.c ****   return ((uint32_t)singal_period_long_long);
 2499              	 .loc 2 1169 0
 2500 00ca 3B69     	 ldr r3,[r7,#16]
1170:../Dave/Generated/CAPTURE/capture.c **** }
 2501              	 .loc 2 1170 0
 2502 00cc 1846     	 mov r0,r3
 2503 00ce 3037     	 adds r7,r7,#48
 2504              	.LCFI133:
 2505              	 .cfi_def_cfa_offset 16
 2506 00d0 BD46     	 mov sp,r7
 2507              	.LCFI134:
 2508              	 .cfi_def_cfa_register 13
 2509              	 
 2510 00d2 B0BD     	 pop {r4,r5,r7,pc}
 2511              	.L130:
 2512              	 .align 2
 2513              	.L129:
 2514 00d4 00CA9A3B 	 .word 1000000000
 2515              	 .cfi_endproc
 2516              	.LFE243:
 2518              	 .section .text.CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue,"ax",%progbits
 2519              	 .align 2
 2520              	 .thumb
 2521              	 .thumb_func
 2523              	CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue:
 2524              	.LFB244:
1171:../Dave/Generated/CAPTURE/capture.c **** 
1172:../Dave/Generated/CAPTURE/capture.c **** #ifdef  CAPTURE_CCU4_USED
1173:../Dave/Generated/CAPTURE/capture.c **** /* @brief Retrieves the latest captured timer value from CCU4*/
1174:../Dave/Generated/CAPTURE/capture.c **** static CAPTURE_STATUS_t CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue(const XMC_CCU4_SLICE_t * c
1175:../Dave/Generated/CAPTURE/capture.c ****                                                                          const XMC_CCU4_SLICE_CAP_R
1176:../Dave/Generated/CAPTURE/capture.c ****                                                                          uint32_t * const val_ptr)
1177:../Dave/Generated/CAPTURE/capture.c **** {
 2525              	 .loc 2 1177 0
 2526              	 .cfi_startproc
 2527              	 
 2528              	 
 2529              	 
 2530 0000 80B4     	 push {r7}
 2531              	.LCFI135:
 2532              	 .cfi_def_cfa_offset 4
 2533              	 .cfi_offset 7,-4
 2534 0002 89B0     	 sub sp,sp,#36
 2535              	.LCFI136:
 2536              	 .cfi_def_cfa_offset 40
 2537 0004 00AF     	 add r7,sp,#0
 2538              	.LCFI137:
 2539              	 .cfi_def_cfa_register 7
 2540 0006 F860     	 str r0,[r7,#12]
 2541 0008 0B46     	 mov r3,r1
 2542 000a 7A60     	 str r2,[r7,#4]
 2543 000c FB72     	 strb r3,[r7,#11]
1178:../Dave/Generated/CAPTURE/capture.c ****   CAPTURE_STATUS_t retval;
1179:../Dave/Generated/CAPTURE/capture.c **** 
1180:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue:Invalid Register Set",
1181:../Dave/Generated/CAPTURE/capture.c ****               ((set == XMC_CCU4_SLICE_CAP_REG_SET_LOW) || (set == XMC_CCU4_SLICE_CAP_REG_SET_HIGH))
1182:../Dave/Generated/CAPTURE/capture.c **** 
1183:../Dave/Generated/CAPTURE/capture.c ****   XMC_ASSERT ("CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue:Invalid Extended Capture Mode ",
1184:../Dave/Generated/CAPTURE/capture.c ****               ((slice->TC) & CCU4_CC4_TC_ECM_Msk) == 0);
1185:../Dave/Generated/CAPTURE/capture.c **** 
1186:../Dave/Generated/CAPTURE/capture.c ****   retval = CAPTURE_STATUS_NEW_VAL_NOT_CAPTURED;
 2544              	 .loc 2 1186 0
 2545 000e 0223     	 movs r3,#2
 2546 0010 FB77     	 strb r3,[r7,#31]
1187:../Dave/Generated/CAPTURE/capture.c **** 
1188:../Dave/Generated/CAPTURE/capture.c ****   if (set == XMC_CCU4_SLICE_CAP_REG_SET_HIGH)
 2547              	 .loc 2 1188 0
 2548 0012 FB7A     	 ldrb r3,[r7,#11]
 2549 0014 012B     	 cmp r3,#1
 2550 0016 1CD1     	 bne .L132
1189:../Dave/Generated/CAPTURE/capture.c ****   {
1190:../Dave/Generated/CAPTURE/capture.c ****     /* read capture values*/
1191:../Dave/Generated/CAPTURE/capture.c ****     *val_ptr = slice->CV[CAPTURE_SLICE_CAP_REGISTER_3];
 2551              	 .loc 2 1191 0
 2552 0018 FB68     	 ldr r3,[r7,#12]
 2553 001a D3F88020 	 ldr r2,[r3,#128]
 2554 001e 7B68     	 ldr r3,[r7,#4]
 2555 0020 1A60     	 str r2,[r3]
1192:../Dave/Generated/CAPTURE/capture.c ****     /* check for new data or full Flag*/
1193:../Dave/Generated/CAPTURE/capture.c ****     if ((*val_ptr) & CCU4_CC4_CV_FFL_Msk)
 2556              	 .loc 2 1193 0
 2557 0022 7B68     	 ldr r3,[r7,#4]
 2558 0024 1B68     	 ldr r3,[r3]
 2559 0026 03F48013 	 and r3,r3,#1048576
 2560 002a 002B     	 cmp r3,#0
 2561 002c 02D0     	 beq .L133
1194:../Dave/Generated/CAPTURE/capture.c ****     {
1195:../Dave/Generated/CAPTURE/capture.c ****       retval = CAPTURE_STATUS_SUCCESS;
 2562              	 .loc 2 1195 0
 2563 002e 0023     	 movs r3,#0
 2564 0030 FB77     	 strb r3,[r7,#31]
 2565 0032 28E0     	 b .L135
 2566              	.L133:
 2567              	.LBB21:
1196:../Dave/Generated/CAPTURE/capture.c ****     }
1197:../Dave/Generated/CAPTURE/capture.c ****     else
1198:../Dave/Generated/CAPTURE/capture.c ****     {
1199:../Dave/Generated/CAPTURE/capture.c ****       volatile uint32_t capture_reg_value_low;
1200:../Dave/Generated/CAPTURE/capture.c ****       capture_reg_value_low = slice->CV[CAPTURE_SLICE_CAP_REGISTER_2];
 2568              	 .loc 2 1200 0
 2569 0034 FB68     	 ldr r3,[r7,#12]
 2570 0036 DB6F     	 ldr r3,[r3,#124]
 2571 0038 BB61     	 str r3,[r7,#24]
1201:../Dave/Generated/CAPTURE/capture.c ****       /* check for new data or full Flag*/
1202:../Dave/Generated/CAPTURE/capture.c ****       if (capture_reg_value_low & CCU4_CC4_CV_FFL_Msk)
 2572              	 .loc 2 1202 0
 2573 003a BB69     	 ldr r3,[r7,#24]
 2574 003c 03F48013 	 and r3,r3,#1048576
 2575 0040 002B     	 cmp r3,#0
 2576 0042 05D0     	 beq .L134
1203:../Dave/Generated/CAPTURE/capture.c ****       {
1204:../Dave/Generated/CAPTURE/capture.c ****         retval = CAPTURE_STATUS_SUCCESS;
 2577              	 .loc 2 1204 0
 2578 0044 0023     	 movs r3,#0
 2579 0046 FB77     	 strb r3,[r7,#31]
1205:../Dave/Generated/CAPTURE/capture.c ****         *val_ptr = capture_reg_value_low;
 2580              	 .loc 2 1205 0
 2581 0048 BA69     	 ldr r2,[r7,#24]
 2582 004a 7B68     	 ldr r3,[r7,#4]
 2583 004c 1A60     	 str r2,[r3]
 2584              	.LBE21:
 2585 004e 1AE0     	 b .L135
 2586              	.L134:
 2587 0050 19E0     	 b .L135
 2588              	.L132:
1206:../Dave/Generated/CAPTURE/capture.c ****       }
1207:../Dave/Generated/CAPTURE/capture.c ****     }
1208:../Dave/Generated/CAPTURE/capture.c ****   }
1209:../Dave/Generated/CAPTURE/capture.c ****   else
1210:../Dave/Generated/CAPTURE/capture.c ****   {
1211:../Dave/Generated/CAPTURE/capture.c ****     /* read capture values*/
1212:../Dave/Generated/CAPTURE/capture.c ****     *val_ptr = slice->CV[CAPTURE_SLICE_CAP_REGISTER_1];
 2589              	 .loc 2 1212 0
 2590 0052 FB68     	 ldr r3,[r7,#12]
 2591 0054 9A6F     	 ldr r2,[r3,#120]
 2592 0056 7B68     	 ldr r3,[r7,#4]
 2593 0058 1A60     	 str r2,[r3]
1213:../Dave/Generated/CAPTURE/capture.c ****     /* check for new data or full Flag*/
1214:../Dave/Generated/CAPTURE/capture.c ****     if ((*val_ptr) & CCU4_CC4_CV_FFL_Msk)
 2594              	 .loc 2 1214 0
 2595 005a 7B68     	 ldr r3,[r7,#4]
 2596 005c 1B68     	 ldr r3,[r3]
 2597 005e 03F48013 	 and r3,r3,#1048576
 2598 0062 002B     	 cmp r3,#0
 2599 0064 02D0     	 beq .L136
1215:../Dave/Generated/CAPTURE/capture.c ****     {
1216:../Dave/Generated/CAPTURE/capture.c ****       retval = CAPTURE_STATUS_SUCCESS;
 2600              	 .loc 2 1216 0
 2601 0066 0023     	 movs r3,#0
 2602 0068 FB77     	 strb r3,[r7,#31]
 2603 006a 0CE0     	 b .L135
 2604              	.L136:
 2605              	.LBB22:
1217:../Dave/Generated/CAPTURE/capture.c ****     }
1218:../Dave/Generated/CAPTURE/capture.c ****     else
1219:../Dave/Generated/CAPTURE/capture.c ****     {
1220:../Dave/Generated/CAPTURE/capture.c ****       volatile uint32_t capture_reg_value_low;
1221:../Dave/Generated/CAPTURE/capture.c ****       capture_reg_value_low = slice->CV[CAPTURE_SLICE_CAP_REGISTER_0];
 2606              	 .loc 2 1221 0
 2607 006c FB68     	 ldr r3,[r7,#12]
 2608 006e 5B6F     	 ldr r3,[r3,#116]
 2609 0070 7B61     	 str r3,[r7,#20]
1222:../Dave/Generated/CAPTURE/capture.c ****       /* check for new data or full Flag*/
1223:../Dave/Generated/CAPTURE/capture.c ****       if (capture_reg_value_low & CCU4_CC4_CV_FFL_Msk)
 2610              	 .loc 2 1223 0
 2611 0072 7B69     	 ldr r3,[r7,#20]
 2612 0074 03F48013 	 and r3,r3,#1048576
 2613 0078 002B     	 cmp r3,#0
 2614 007a 04D0     	 beq .L135
1224:../Dave/Generated/CAPTURE/capture.c ****       {
1225:../Dave/Generated/CAPTURE/capture.c ****         retval = CAPTURE_STATUS_SUCCESS;
 2615              	 .loc 2 1225 0
 2616 007c 0023     	 movs r3,#0
 2617 007e FB77     	 strb r3,[r7,#31]
1226:../Dave/Generated/CAPTURE/capture.c ****         *val_ptr = capture_reg_value_low;
 2618              	 .loc 2 1226 0
 2619 0080 7A69     	 ldr r2,[r7,#20]
 2620 0082 7B68     	 ldr r3,[r7,#4]
 2621 0084 1A60     	 str r2,[r3]
 2622              	.L135:
 2623              	.LBE22:
1227:../Dave/Generated/CAPTURE/capture.c ****       }
1228:../Dave/Generated/CAPTURE/capture.c ****     }
1229:../Dave/Generated/CAPTURE/capture.c ****   }
1230:../Dave/Generated/CAPTURE/capture.c **** 
1231:../Dave/Generated/CAPTURE/capture.c ****   return retval;
 2624              	 .loc 2 1231 0
 2625 0086 FB7F     	 ldrb r3,[r7,#31]
1232:../Dave/Generated/CAPTURE/capture.c **** }
 2626              	 .loc 2 1232 0
 2627 0088 1846     	 mov r0,r3
 2628 008a 2437     	 adds r7,r7,#36
 2629              	.LCFI138:
 2630              	 .cfi_def_cfa_offset 4
 2631 008c BD46     	 mov sp,r7
 2632              	.LCFI139:
 2633              	 .cfi_def_cfa_register 13
 2634              	 
 2635 008e 5DF8047B 	 ldr r7,[sp],#4
 2636              	.LCFI140:
 2637              	 .cfi_restore 7
 2638              	 .cfi_def_cfa_offset 0
 2639 0092 7047     	 bx lr
 2640              	 .cfi_endproc
 2641              	.LFE244:
 2643              	 .text
 2644              	.Letext0:
 2645              	 .file 4 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 2646              	 .file 5 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 2647              	 .file 6 "C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Infineon/XMC4700_series/Include/XMC4700.h"
 2648              	 .file 7 "C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc/xmc4_scu.h"
 2649              	 .file 8 "C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Dave/Generated/DAVE_Common.h"
 2650              	 .file 9 "C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Dave/Generated/GLOBAL_CCU4/global_ccu4.h"
 2651              	 .file 10 "C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc/xmc_gpio.h"
 2652              	 .file 11 "C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/XMCLib/inc/xmc4_gpio.h"
 2653              	 .file 12 "../Dave/Generated/CAPTURE/capture.h"
 2654              	 .file 13 "C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Include/core_cm4.h"
 2655              	 .file 14 "C:/daveProjects/autoomes-fahren-und-intelligente-sensoren/xmc_Antrieb_lenkung/Libraries/CMSIS/Infineon/XMC4700_series/Include/system_XMC4700.h"
DEFINED SYMBOLS
                            *ABS*:00000000 capture.c
    {standard input}:20     .text.XMC_CCU4_EnableClock:00000000 $t
    {standard input}:24     .text.XMC_CCU4_EnableClock:00000000 XMC_CCU4_EnableClock
    {standard input}:68     .text.XMC_CCU4_SLICE_IsTimerRunning:00000000 $t
    {standard input}:72     .text.XMC_CCU4_SLICE_IsTimerRunning:00000000 XMC_CCU4_SLICE_IsTimerRunning
    {standard input}:117    .text.XMC_CCU4_SLICE_StartTimer:00000000 $t
    {standard input}:121    .text.XMC_CCU4_SLICE_StartTimer:00000000 XMC_CCU4_SLICE_StartTimer
    {standard input}:160    .text.XMC_CCU4_SLICE_StopTimer:00000000 $t
    {standard input}:164    .text.XMC_CCU4_SLICE_StopTimer:00000000 XMC_CCU4_SLICE_StopTimer
    {standard input}:203    .text.XMC_CCU4_SLICE_ClearTimer:00000000 $t
    {standard input}:207    .text.XMC_CCU4_SLICE_ClearTimer:00000000 XMC_CCU4_SLICE_ClearTimer
    {standard input}:246    .text.XMC_CCU4_SLICE_SetTimerPeriodMatch:00000000 $t
    {standard input}:250    .text.XMC_CCU4_SLICE_SetTimerPeriodMatch:00000000 XMC_CCU4_SLICE_SetTimerPeriodMatch
    {standard input}:291    .text.XMC_CCU4_SLICE_SetTimerCompareMatch:00000000 $t
    {standard input}:295    .text.XMC_CCU4_SLICE_SetTimerCompareMatch:00000000 XMC_CCU4_SLICE_SetTimerCompareMatch
    {standard input}:336    .text.XMC_CCU4_EnableShadowTransfer:00000000 $t
    {standard input}:340    .text.XMC_CCU4_EnableShadowTransfer:00000000 XMC_CCU4_EnableShadowTransfer
    {standard input}:380    .text.CAPTURE_GetAppVersion:00000000 $t
    {standard input}:385    .text.CAPTURE_GetAppVersion:00000000 CAPTURE_GetAppVersion
    {standard input}:446    .text.CAPTURE_Init:00000000 $t
    {standard input}:451    .text.CAPTURE_Init:00000000 CAPTURE_Init
    {standard input}:2070   .text.CAPTURE_CCU4_lInit:00000000 CAPTURE_CCU4_lInit
    {standard input}:554    .text.CAPTURE_Start:00000000 CAPTURE_Start
    {standard input}:549    .text.CAPTURE_Start:00000000 $t
    {standard input}:634    .text.CAPTURE_Stop:00000000 $t
    {standard input}:639    .text.CAPTURE_Stop:00000000 CAPTURE_Stop
    {standard input}:698    .text.CAPTURE_GetTimerStatus:00000000 $t
    {standard input}:703    .text.CAPTURE_GetTimerStatus:00000000 CAPTURE_GetTimerStatus
    {standard input}:767    .text.CAPTURE_GetCapturedTime:00000000 $t
    {standard input}:772    .text.CAPTURE_GetCapturedTime:00000000 CAPTURE_GetCapturedTime
    {standard input}:2523   .text.CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue:00000000 CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue
    {standard input}:2211   .text.CAPTURE_lCalculateTimeTickFromTimerValue:00000000 CAPTURE_lCalculateTimeTickFromTimerValue
    {standard input}:915    .text.CAPTURE_GetCapturedTimeInNanoSec:00000000 $t
    {standard input}:920    .text.CAPTURE_GetCapturedTimeInNanoSec:00000000 CAPTURE_GetCapturedTimeInNanoSec
    {standard input}:2362   .text.CAPTURE_lCalculateTimeInNanoSecFromTimerTick:00000000 CAPTURE_lCalculateTimeInNanoSecFromTimerTick
    {standard input}:1086   .text.CAPTURE_GetDutyCycle:00000000 $t
    {standard input}:1091   .text.CAPTURE_GetDutyCycle:00000000 CAPTURE_GetDutyCycle
    {standard input}:1200   .text.CAPTURE_GetDutyCycleInPercentage:00000000 $t
    {standard input}:1205   .text.CAPTURE_GetDutyCycleInPercentage:00000000 CAPTURE_GetDutyCycleInPercentage
    {standard input}:1404   .text.CAPTURE_GetPeriod:00000000 $t
    {standard input}:1409   .text.CAPTURE_GetPeriod:00000000 CAPTURE_GetPeriod
    {standard input}:1540   .text.CAPTURE_GetPeriodInNanoSec:00000000 $t
    {standard input}:1545   .text.CAPTURE_GetPeriodInNanoSec:00000000 CAPTURE_GetPeriodInNanoSec
    {standard input}:1690   .text.CAPTURE_GetPeriodDutyCycle:00000000 $t
    {standard input}:1695   .text.CAPTURE_GetPeriodDutyCycle:00000000 CAPTURE_GetPeriodDutyCycle
    {standard input}:1834   .text.CAPTURE_GetPeriodInNanoSecDutyCycleInPercentage:00000000 $t
    {standard input}:1839   .text.CAPTURE_GetPeriodInNanoSecDutyCycleInPercentage:00000000 CAPTURE_GetPeriodInNanoSecDutyCycleInPercentage
    {standard input}:2066   .text.CAPTURE_CCU4_lInit:00000000 $t
    {standard input}:2155   .text.CAPTURE_CCU4_lShadowTransfer:00000000 CAPTURE_CCU4_lShadowTransfer
    {standard input}:2151   .text.CAPTURE_CCU4_lShadowTransfer:00000000 $t
    {standard input}:2207   .text.CAPTURE_lCalculateTimeTickFromTimerValue:00000000 $t
    {standard input}:2358   .text.CAPTURE_lCalculateTimeInNanoSecFromTimerTick:00000000 $t
    {standard input}:2514   .text.CAPTURE_lCalculateTimeInNanoSecFromTimerTick:000000d4 $d
    {standard input}:2519   .text.CAPTURE_CCU4_lSLICE_GetLastestCapturedTimerValue:00000000 $t
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
GLOBAL_CCU4_Init
XMC_GPIO_Init
XMC_CCU4_SLICE_CaptureInit
XMC_CCU4_SLICE_ConfigureEvent
XMC_CCU4_SLICE_Capture0Config
XMC_CCU4_SLICE_Capture1Config
__aeabi_uldivmod
